# 跳表

## 如何理解“跳表”？

> 带索引的有序链表

![image-20210215223037797](09_跳表.assets/image-20210215223037797.png)

## 用跳表查询到底有多快？

当每两个结点会抽出一个结点作为上一级索引的结点，那么在跳表中查询任意数据的时间复杂度就是 O(logn)。相当于基于链表的二分查找

## 跳表是不是很浪费内存？

>  空间复杂度还是 O(n)
>
>  与索引的间隔有关

实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。

## 高效的动态插入和删除

跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。

## 跳表索引动态更新

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

![image-20210215223514443](09_跳表.assets/image-20210215223514443.png)

跳表是通过随机函数来维护前面提到的“平衡性”。

我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。

![image-20210215223551704](09_跳表.assets/image-20210215223551704.png)

## 为什么 Redis 要用跳表来实现有序集合，而不是红黑树？

Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。

Redis 中的有序集合支持的核心操作主要有下面这几个：

* 插入一个数据；删除一个数据；
* 查找一个数据；
* 按照区间查找数据（比如查找值在[100, 356]之间的数据）；
* 迭代输出有序序列。

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。

当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。

不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。

## 参考资料

[Redis 为什么用跳表而不用平衡树？](https://juejin.cn/post/6844903446475177998)

