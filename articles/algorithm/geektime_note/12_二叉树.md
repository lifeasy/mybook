# 二叉树

## 树（Tree）

* 父节点
* 子节点
* 兄弟节点：父节点是同一个节点
* 根节点：没有父节点的节点叫做根节点

### 节点的高度、深度、层

<img src="12_二叉树.assets/image-20210220002040071.png" alt="image-20210220002040071" style="zoom: 33%;" />

<img src="12_二叉树.assets/image-20210220002051485.png" alt="image-20210220002051485" style="zoom: 33%;" />

## 二叉树（Binary Tree）

> 每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。

**满二叉树：**叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做满二叉树

**完全二叉树：**叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树

满二叉树是一种特殊的完全二叉树

## 如何表示（或者存储）一棵二叉树

### 二叉链式存储法

需要额外存储空间存放指针

<img src="12_二叉树.assets/image-20210220002401692.png" alt="image-20210220002401692" style="zoom:33%;" />

### 基于数组的顺序存储法

把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。

<img src="12_二叉树.assets/image-20210220002520580.png" alt="image-20210220002520580" style="zoom:33%;" />

如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。

**完全二叉树仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间**

**堆其实就是一种完全二叉树，最常用的存储方式就是数组。**

## 二叉树的遍历

* 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
* 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
* 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

<img src="12_二叉树.assets/image-20210220002724076.png" alt="image-20210220002724076" style="zoom:33%;" />

```c
void preOrder(Node* root) {
  if (root == null) return;
  print root // 此处为伪代码，表示打印root节点
  preOrder(root->left);
  preOrder(root->right);
}

void inOrder(Node* root) {
  if (root == null) return;
  inOrder(root->left);
  print root // 此处为伪代码，表示打印root节点
  inOrder(root->right);
}

void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  print root // 此处为伪代码，表示打印root节点
}
```

二叉树遍历的时间复杂度是 O(n)。