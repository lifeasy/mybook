# 汇编之条件、循环、选择

## if

```
# 减法，不改变寄存器值，改变标记寄存器的值
cmp w8, w9
# 小于等于就跳转，否则继续往下执行
b.le loc_109323 
.....

# 上面代码还原就表示
if (w8 <= w9) {
	goto loc_109323
}
```

### cmp（Compare）比较指令

&emsp;&emsp;&ensp;CMP 把一个寄存器的内容和另一个寄存器的内容或立即数进行比较。但不存储结果，只是正确的更改标志。
&emsp;&emsp;&ensp;一般CMP做完判断后会进行跳转，后面通常会跟上B指令！

* BL 标号：跳转到标号处执行
* B.GT  标号：比较结果是**大于（greater than）**，执行标号，否则不跳转
* B.GE  标号：比较结果是**大于等于（greater than or equal to）**，执行标号，否则不跳转
* B.EQ  标号：比较结果是**等于**，执行标号，否则不跳转
* B.HI  标号：比较结果是**无符号大于**，执行标号，否则不跳转

## LOOP

本质还是`if`

##Switch
1、假设switch语句的分支比较少的时候（例如3，少于4的时候没有意义）没有必要使用此结构，相当于if。
2、各个分支常量的差值较大的时候，编译器会在效率还是内存进行取舍，这个时候编译器还是会编译成类似于if，else的结构。
3、在分支比较多的时候：在编译的时候会生成一个表（跳转表每个地址四个字节）。通过查表找到执行代码的地址值进行执行。

* switch代码分支的代码是连续的

* 通过一些列的运算，找到case中或者default中代码块指向的地址
* case中算偏移值，用switch的参数和选择最小的case进行减法
* 然后cmp用上面计算的偏移值和（最大的case和最小的case之间的差值）进行比较，**无符号大于比较`b.hi`**
  * 可计算是否在区间内
* 如果在区间内，进行查表
  * switch参数减去最小case算出偏移值进行后续查表运算
  * 表放在这个函数代码段的最后一个地址后面。代码中是通过`adrp`找到的
  * 表里面放了一些负数，个数等于最小的case到最大的case的个数（最大case-最小case+1），就是区间内每一个值对应一个负数，通过这个后续的计算(ldrsw)，可以跳转到对应的case或者default中执行
  * 用表空间换找到对应case代码块时间。case越多，效率越高
  * 表中为什么不放地址：因为aslr，放偏移更好，而且地址占空间

```
ubfx x9, x9, #0, #32
//保留x9中，从第0位开始，保留32位，其他的用0补齐，然后赋值给x9。相当于把x9中的高32位清零
// 0x0123456789abcdef  运算后得-> 0x0000000089abcdef

br x9
// 根据x9寄存器中的值，进行跳转

ldrsw x10, [x8, x11, lsl #2]
// x11的值左移两位加上x8的值，指向的地址空间的值，赋值给x10
```

## 编译器优化

* 会优化掉对程序执行结果没有影响的代码
* 有可能会直接算出值
* NSLog的第一个参数是format，x0中存的一个指针，例如字符串`%d`的指针
* Release的优化默认就是fastest，smaller

## 指针

* 指针8字节
* sizeof是一个运算符，汇编层面直接就可以看到运算结果
* 指针的自增自减或者加减法和指向的数据类型有关：`int *a; a = (int *)100; a++; `,这里a就等于`104`
* 自增自减和编译器有关
* 总结下就是指针的运算都是和指向的数据类型优化，运算结果类似于计算以数据类型为宽度的步长个数。指针的运算单位是指向的数据类型的宽度

## 指针的反汇编

* 指针变量->理论上保存的就是sp偏移一个位置的地址值
* 数组名就是一个指针。`int *a == &arr[0] == arr == &arr`,其中`&arr`编译器可能会报警告，类似的还有函数名也是一个指针

## 指针的基本用法

