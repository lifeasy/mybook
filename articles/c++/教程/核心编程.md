# 核心编程

## 内存四大区

* 代码区
* 全局区
* 栈区
* 堆区

## C++中的new

* c++中使用new操作符在堆区开辟空间
* 堆区由程序员手动管理，释放时使用delete，释放数组时要加[]
* 语法：new 数据类型
* 使用new创建的数据，会返回该数据类型的指针

```c++
// 开辟普通数据类型空间
struct Student {
    string name;
    int age;
    int score;
};
int main(int argc, const char * argv[]) {
    // insert code here...
    Student *p = new Student({"lisi",18,99});
    cout << p->name << "," << p->age << "," << p->score << endl;
    delete p;
    cout << p->name << "," << p->age << "," << p->score << endl; // 会发生错误
    cout << "Hello, World!\n";
    return 0;
}
// 开辟数组空间
int *arr = new int[5];
*arr = 1;
*(arr + 1) = 2;
*(arr + 2) = 3;
*(arr + 3) = 4;
*(arr + 4) = 5;
cout << arr[1] << endl;
delete [] arr;
```

## 引用

* 作用：给一个变量起别名
* 语法：数据类型 &别名 = 原名；
* 必须初始化
* 初始化后不能发生改变

```c++
int a = 10;
int &b = a;
b = 100;
cout << a << endl; // 100
```

* 引用传递：可以作为函数形参方便修饰实参，替代指针传递

```c++
// 引用传递
void mySwap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
int c = 10;
int d = 100;
mySwap(c, d);
cout << c << "," << d << endl;
```

* 引用作为函数的返回值
  * 注意不要返回局部变量，会释放
  * 如果函数返回值作为左值，必须返回引用

```c++
int& test() {
    int a = 10;
    return a;
}
int &ref = test();
cout << ref << endl; // 10
cout << ref << endl; // 32767 第二次乱码 栈空间释放

int &ref2 = test01();
    cout << ref2 << endl; // 10
    test01() = 100; // 作为左值，函数必须返回引用
    cout << ref2 << endl; // 100
```

### 引用的本质

引用的本质，在C++内部是一个指针常量

### 常量引用

常量引用主要用来修饰函数参数，防止参数修改导致原数据修改，导致误操作

```c++
void showValue(const int &a) {
    cout << a << endl;
}
```

## 函数的高级用法

### 函数的默认参数

* 如果从某个位置开始有默认参数，那么从这个位置开始，后面的参数都要有默认参数
* 如果函数声明有默认参数，那么函数实现就不能有默认参数

```c++
int add(int a = 10, int b = 100) {
    return a + b;
}
cout << add() << endl; // 110
cout << add(11) << endl; // 111
cout << add(11,12) << endl; // 23
```

### 函数的占位参数

函数参数列表中用来占位，调用时必须传递该位置

占位参数也可以有默认值

```c++
// 第二个int为占位参数，调用函数时必须要传递一个参数
void showValue(int a, int) {
    cout << "show" << endl;
}
showValue(2,10);
// 带默认值
void showValue(int a, int = 10) {
    cout << "show" << endl;
}
showValue(2); //调用可以不传
```

### 函数重载

函数名相同，提高复用性

**重载条件**

* 同一个作用域下
* 函数名称相同
* 函数参数类型不同、个数不同或者顺序不同
* 函数返回值不可以作为函数重载的条件

**注意事项**

* 引用作为参数的重载

```c++
void func(int &a) {
    cout << "func" << endl;
}
void func(const int &a) {
    cout << "func const" << endl;
}
int a = 10;
func(a); //调用 func
func(10); // 调用func const 字面量是常量
```

* 函数重载遇到默认参数

```c++
void func(int a, int b = 10) {
    cout << "func a b" << endl;
}
void func(int a) {
    cout << "func a" << endl;
}
func(10); // 存在二义性，不知道调用哪个出错
func(10,11); // 调用func a b
```

## 类

### 声明

```c++
class Student {
public:
    string name;
    int id;
    void showStudent() {
        cout << "名字：" << name << ", id：" << id << endl;
    }
    void setName(string newName) {
        name = newName;
    }
};
int main(int argc, const char * argv[]) {
    // insert code here...
    Student stu;
    stu.name = "zhangsan";
    stu.id = 1;
    stu.showStudent(); // 名字：zhangsan, id：1
    stu.setName("wangwu");
    stu.showStudent(); // 名字：wangwu, id：1
    return 0;
}
```

### 访问权限

* public：内部可以访问、子类可以访问、外部可以访问
* protected：内部可以访问、子类可以访问、外部不可以访问
* private：内部可以访问、子类不可以访问、外部不可以访问

### 类和结构体的区别

* `class`默认权限为private
* `struct`默认权限为public

### 成员属性设置为私有

* 自己控制读写权限
* 写权限判断数据有效性
* 抛出public的设置/获取方法给外部