{"./":{"url":"./","title":"前言","keywords":"","body":"前言 士不可以不弘毅 任重而道远 运行 安装gitbook 运行gitbook install build gitbook build 本地运行 gitbook serve 部署到服务器 目前直接通过git上传到服务端 1、在服务端创建git仓库 $ cd /var/repo $ git init --bare gitbookBlog.git $ ls gitbookBlog.git hexoBlog.git 2、设置post-receive钩子 $ cd gitbookBlog.git $ cd hooks $ touch post-receive $ vi post-receive # 根据服务路径自行配置 # git --work-tree=/var/www/html/myGitbook --git-dir=/var/repo/gitbookBlog.git checkout -f $ chmod +x post-receive 3、配置本地的gitbook的git config，增加remote # 测试加在第一个，source tree不受影响，source tree读取的是最后一个url，但是同时都会上传 [remote \"origin\"] url = root@1.2.3.4:/var/repo/gitbookBlog url = git@github.com:lifeasy/mybook.git fetch = +refs/heads/*:refs/remotes/origin/* 参考：gitbook部署到服务器 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-09-16 10:52:35 "},"articles/iOS/lldb/LLDB常用命令.html":{"url":"articles/iOS/lldb/LLDB常用命令.html","title":"LLDB常用命令","keywords":"","body":"LLDB常用命令 LLDB语法 [ [...]] [-options [option-value]] [argument[argument...]] （命令）和（子命令）：LLDB调试命令的名称 ：执行命令的操作 ：命令选项 ：命令的参数 []：表示命令是可选的，可以有也可以没有 bt 查看函数调用栈 (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1 * frame #0: 0x000000010012e6bc InjectDemo`-[ViewController test2](self=0x0000000100709bd0, _cmd=\"test2\") at ViewController.m:41:5 frame #1: 0x000000010012e694 InjectDemo`-[ViewController test1](self=0x0000000100709bd0, _cmd=\"test1\") at ViewController.m:38:5 ... up/down up、down挪动函数调用 1 个距离 (lldb) up frame #1: 0x000000010012e694 InjectDemo`-[ViewController test1](self=0x0000000100709bd0, _cmd=\"test1\") at ViewController.m:38:5 35 [self test1]; 36 } 37 - (void)test1 { -> 38 [self test2]; ^ 39 } 40 - (void)test2 { 41 NSLog(@\"haha\"); (lldb) down frame #1: 0x000000010012e694 InjectDemo`-[ViewController test1](self=0x0000000100709bd0, _cmd=\"test1\") at ViewController.m:38:5 35 [self test1]; 36 } 37 - (void)test1 { -> 38 [self test2]; ^ 39 } 40 - (void)test2 { 41 NSLog(@\"haha\"); frame frame select 数字——跳转函数调用（0表示当前方法，2表示2个方法前） frame variable——查看当前函数属性：内存地址、方法名、参数 (lldb) frame select 1 frame #1: 0x000000010012e694 InjectDemo`-[ViewController test1](self=0x0000000100709bd0, _cmd=\"test1\") at ViewController.m:38:5 35 [self test1]; 36 } 37 - (void)test1 { -> 38 [self test2]; ^ 39 } 40 - (void)test2 { 41 NSLog(@\"haha\"); (lldb) frame variable (ViewController *) self = 0x0000000100709bd0 (SEL) _cmd = \"test1\" thread thread return——结束当前函数调用，跳转回上一个调用栈的下一步 watchpoint 通过watchpoint set variable self->_name就可以给对应的属性内存下断点 修改内存地址的值就会来到断点处（此时相当于KVO机制）同时也能看到函数调用栈 watchpoint list watchpoint delete (lldb) watchpoint set variable self->_name Watchpoint created: Watchpoint 1: addr = 0x100d07eb0 size = 8 state = enabled type = w watchpoint spec = 'self->_name' new value: 0x0000000000000000 Watchpoint 1 hit: old value: 0x0000000000000000 new value: 0x00000001006fc0a0 breakpoint 设置断点 命令 意义 简写 breakpoint list 查看断点列表 breakpoint l breakpoint set -n cMethod 设置单个断点 b -n cMethod breakpoint set -n \"[ViewController ocMethod1]\" -n \"[ViewController ocMethod2]\" 设置一组断点 b -n \"[ViewController ocMethod1]\" -n \"[ViewController ocMethod2]\" breakpoint set --selector touchesBegan:withEvent: 设置某一个方法的断点 b -selector touchesBegan:withEvent: breakpoint set --file ViewController.m --selector touchesBegan:withEvent: 设置某文件下某一个方法的断点 b -f ViewController.m --selector touchesBegan:withEvent: breakpoint set -r ocMethod 设置所有匹配方法名的断点 b -r ocMethod breakpoint enable 1 启用某一组断点 breakpoint en 1 breakpoint disable 1 禁用某一组断点 breakpoint dis 1 breakpoint enable 1.1 启用某一个断点 breakpoint en 1.1 breakpoint disable 1.1 禁用某一个断点 breakpoint dis 1.1 breakpoint delete 删除所有断点 breakpoint d continue 退出LLDB模式 c next 单步运行，将子函数当做整体一起执行 n stpe 单步运行，将子函数当做整体一起执行 s 关于简写： b：breakpoint set l：list -n：--name --f：--file dis：disable en：enable 断点添加命令 通过breakpoint command add 1就可以给指定断点添加命令 1是对应的断点编号，不传默认给所有的加 通过DONE结束断点命令添加 类似于给程序添加脚本命令，断点执行也可以添加命令，断点到来时就会执行先前的命令了 (lldb) breakpoint command add 4 Enter your debugger command(s). Type 'DONE' to end. > po self > po temp > p temp = @\"666\" > DONE po self .... # 执行断点4之前打印 po self po temp hehe p temp = @\"666\" (NSTaggedPointerString *) $2 = 0xbbc20ccc64e318e6 @\"666\" 2021-03-13 15:27:29.681323+0800 InjectDemo[5226:1237648] 666 target stop-hook target stop-hook是一个给所有断点添加命令的指令——在每次stop的时候去执行一些命令（只对breakpoint、watchpoint有效） target stop-hook list target stop-hook disable target stop-hook delete/undisplay 1 (lldb) target stop-hook add Enter your stop hook command(s). Type 'DONE' to end. > frame variable > DONE Stop hook #1 added. .... (ViewController *) self = 0x0000000115f076a0 (SEL) _cmd = \"test1\" (ViewController *) self = 0x0000000115f076a0 (SEL) _cmd = \"test2\" x/8g x/8g 内存地址 查看内存地址里的值 (lldb) x/8g 0x101840890 0x101840890: 0x0000000100008168 0x0000000200000003 0x1018408a0: 0x0000000000000014 0x0002000000000000 0x1018408b0: 0x0000000080080000 0x00007fff806e4fa0 0x1018408c0: 0x0000000000000000 0x00007fff8849b4f8 register read 读取寄存器 (lldb) register read General Purpose Registers: rax = 0x00007fff80be7fe8 libswiftCore.dylib`type metadata for Any + 8 rbx = 0x0000000000000000 rcx = 0x0000000000000000 rdx = 0x000000000003efe0 rdi = 0x0000000100435080 rsi = 0x00000000000bcfa0 rbp = 0x00007ffeefbff440 rsp = 0x00007ffeefbff3c0 r8 = 0x0000000000005d09 r9 = 0x0000000000000003 r10 = 0x0000000100500000 r11 = 0x0000000000000000 r12 = 0x0000000000000000 r13 = 0x0000000000000000 r14 = 0x0000000000000000 r15 = 0x0000000000000000 rip = 0x0000000100003c12 LGSwift`main + 178 at main.swift:19:7 rflags = 0x0000000000000206 cs = 0x000000000000002b fs = 0x0000000000000000 gs = 0x0000000000000000 memory read memory read 内存地址 读取内存中的值 dis -s dis -s 内存地址 查看汇编 image list 程序运行加载image (lldb) image list [ 0] BB914D93-708D-35F5-BD97-2AEE2D59FC3B 0x0000000100000000 /Users/360jr/Library/Developer/Xcode/DerivedData/LGSwift-fvgrncxxsmdtgkdnysjqhlyzosii/Build/Products/Debug/LGSwift [ 1] 2705F0D8-C104-3DE9-BEB5-B1EF6E28656D 0x0000000100014000 /usr/lib/dyld ... (lldb) image list -o -f [ 0] 0x0000000001164000 /var/containers/Bundle/Application/C4BD67F6-5D1E-4FB8-AAAC-CD9EE05248E9/ChangeColor.app/ChangeColor(0x0000000101164000) [ 1] 0x0000000101490000 /Users/360jr/Library/Developer/Xcode/iOS DeviceSupport/12.4.8 (16G201)/Symbols/usr/lib/dyld [ 2] 0x000000010117c000 /usr/lib/substitute-inserter.dylib(0x000000010117c000) [ 3] 0x00000000263a8000 /Users/360jr/Library/Developer/Xcode/iOS DeviceSupport/12.4.8 (16G201)/Symbols/System/Library/Frameworks/Foundation.framework/Foundation [ 4] 0x00000000263a8000 /Users/360jr/Library/Developer/Xcode/iOS DeviceSupport/12.4.8 (16G201)/Symbols/usr/lib/libobjc.A.dylib process # 链接到某个debugserver (lldb) process connect connect://127.0.0.1:10086 Process 14359 stopped * thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP frame #0: 0x00000001a6dff0f4 libsystem_kernel.dylib`mach_msg_trap + 8 libsystem_kernel.dylib`mach_msg_trap: -> 0x1a6dff0f4 : ret Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-13 17:49:17 "},"articles/iOS/swift/Swift常用命令.html":{"url":"articles/iOS/swift/Swift常用命令.html","title":"Swift常用命令","keywords":"","body":"Swift常用命令 swiftc swift编译相关 # 源码编译为sil中间文件 | 编译后的符号解析 swiftc -emit-sil main.swift | xcrun swift-demangle >> ./main.sil && open main.sil # 生成抽象语法树 $ swiftc -dump-ast main.swift cat address 使用lldb插件 libfooplugin.dylib (lldb) cat address 0x100511630 &0x100511630, (char *) $4 = 0x00007ffeefbff2a0 \"0x100511630 heap pointer, (0x30 bytes), zone: 0x7fff88ac1000\" Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-15 15:29:42 "},"articles/iOS/swift/Swift源码编译.html":{"url":"articles/iOS/swift/Swift源码编译.html","title":"Swift源码编译","keywords":"","body":"Swift源码编译 Clone源码 注意源码与本地Xcode版本，不对应的话会编译失败 # 查看本机swift版本 $ xcrun swift -version Apple Swift version 5.3.1 (swiftlang-1200.0.41 clang-1200.0.32.8) Target: x86_64-apple-darwin20.1.0 $ mkdir swift-source $ cd swift-source $ git clone --branch swift-5.3.1-RELEASE https://github.com/apple/swift.git .... # 等待clone完成 # 克隆swift编译相关的库 $ ./swift/utils/update-checkout --tag swift-5.3.1-RELEASE --clone ... # 等待clone完成 遇到ascii相关报错，修改路径，不能出现中文 遇到部分依赖库clone出现SSL链接失败，使用翻墙解决 编译 $ ./swift/utils/build-script -r --debug-swift-stdlib --lldb Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-15 15:29:42 "},"articles/iOS/swift/logicEdu/01_类、对象、属性.html":{"url":"articles/iOS/swift/logicEdu/01_类、对象、属性.html","title":"01_类、对象、属性","keywords":"","body":"一、类、对象、属性 1 类 1.1 类初始化 调用__allocating_init ->swift_allocObject->_swift_allocObject_，返回一个HeapObject static HeapObject *_swift_allocObject_(HeapMetadata const *metadata, size_t requiredSize, size_t requiredAlignmentMask) { assert(isAlignmentMask(requiredAlignmentMask)); auto object = reinterpret_cast( swift_slowAlloc(requiredSize, requiredAlignmentMask)); // NOTE: this relies on the C++17 guaranteed semantics of no null-pointer // check on the placement new allocator which we have observed on Windows, // Linux, and macOS. new (object) HeapObject(metadata); // If leak tracking is enabled, start tracking this object. SWIFT_LEAKS_START_TRACKING_OBJECT(object); SWIFT_RT_TRACK_INVOCATION(object, swift_allocObject); return object; } _swift_allocObject_调用swift_slowAlloc开辟内存空间，附加内存对齐 void *swift::swift_slowAlloc(size_t size, size_t alignMask) { void *p; // This check also forces \"default\" alignment to use AlignedAlloc. if (alignMask 生成一个HeapObject 1.2 HeapObject 关于HeapObject，需要一个metadata(指针类型，8字节)，一个refCounts（指针类型，8字节） struct HeapObject { /// This is always a valid pointer to a metadata object. HeapMetadata const *metadata; SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS; #ifndef __swift__ HeapObject() = default; // Initialize a HeapObject header as appropriate for a newly-allocated object. constexpr HeapObject(HeapMetadata const *newMetadata) : metadata(newMetadata) , refCounts(InlineRefCounts::Initialized) { } // Initialize a HeapObject header for an immortal object constexpr HeapObject(HeapMetadata const *newMetadata, InlineRefCounts::Immortal_t immortal) : metadata(newMetadata) , refCounts(InlineRefCounts::Immortal) { } #ifndef NDEBUG void dump() const LLVM_ATTRIBUTE_USED; #endif #endif // __swift__ }; 实例对象，本质为一个HeapObject，默认占用16字节（metadata，refCounts） 1.3 HeapMetadata // 类型为 HeapMetadata HeapMetadata const *metadata; // TargetHeapMetadata template struct TargetHeapMetadata; using HeapMetadata = TargetHeapMetadata; // TargetMetadata struct TargetHeapMetadata : TargetMetadata { using HeaderType = TargetHeapMetadataHeader; TargetHeapMetadata() = default; constexpr TargetHeapMetadata(MetadataKind kind) : TargetMetadata(kind) {} #if SWIFT_OBJC_INTEROP constexpr TargetHeapMetadata(TargetAnyClassMetadata *isa) : TargetMetadata(isa) {} #endif }; // kind 表示当前metaData的类型，class、enum、struct... struct TargetMetadata { ... private: /// The kind. Only valid for non-class metadata; getKind() must be used to get /// the kind value. StoredPointer Kind; ... } // 根据kind，返回TargetClassMetadata // 继承自TargetAnyClassMetadata struct TargetClassMetadata : public TargetAnyClassMetadata { } // 继承自 struct TargetAnyClassMetadata : public TargetHeapMetadata { } swift中的方法也存储在metaData中 1.4 属性 1.4.1 存储属性 占用内存空间 1.4.2 计算属性 不占用内存空间 不存储数据 本质为set/get方法 1.4.3 属性观察者 初始化方法中设置属性，不会触发属性观察值：为了内存安全，避免对象未初始化完成时，属性观察者访问了其他实例变量 定义的存储属性，可以添加属性观察者 继承的存储属性，也可以添加属性观察者 继承的计算属性，也可以添加属性观察者，但是自己实现的计算属性，不能添加属性观察者 当父类和子类的属性观察者同时存在 先子类willset，在父类willset 先父类didset、在子类didset 当在子类init方法中，设置父类的存在属性观察者的属性时，可以触发属性观察者，触发结果同上述。因为属性时继承来的，需要在子类init中调用super.init()，可以认为父类已经完成了属性观察者相关操作的内存初始化，可以认为内存安全，所以可以触发 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-15 15:29:42 "},"articles/iOS/swift/logicEdu/02_值类型、引用类型.html":{"url":"articles/iOS/swift/logicEdu/02_值类型、引用类型.html","title":"02_值类型、引用类型","keywords":"","body":"二、值类型、引用类型 1 延迟存储属性 lazy var age = 20 1.1 必须要有默认初始化值 1.2 首次访问的时候才有值 class LGTearch { lazy var age = 20 } var t = LGTearch() (lldb) x/8g 0x101840890 0x101840890: 0x0000000100008168 0x0000000200000003 // 这里没值 0x1018408a0: 0x0000000000000000 0x0002000000000001 0x1018408b0: 0x0000000080080000 0x00007fff806e4fa0 0x1018408c0: 0x0000000000000000 0x00007fff8849b4f8 20 print(t.age) (lldb) x/8g 0x101840890 0x101840890: 0x0000000100008168 0x0000000200000003 // 这里有值 0x1018408a0: 0x0000000000000014 0x0002000000000000 0x1018408b0: 0x0000000080080000 0x00007fff806e4fa0 0x1018408c0: 0x0000000000000000 0x00007fff8849b4f8 print(\"end\") 1.3 延迟属性对实例对象的大小影响 class LGTearch { lazy var age = 20 } print(class_getInstanceSize(LGTearch.self)) // print 32 class LGTearch { var age = 20 } print(class_getInstanceSize(LGTearch.self)) // print 24 查看SIL中间文件，发现lazy属性底层为一个Optional类型 Optional为枚举enum类型 为什么可选Int类型为9字节：8+1，1认为是标识Int是否有值，这里有疑惑，后续跟新 查看可选行的内存大小和步长（字节对齐） var age : Int? print(MemoryLayout>.size) print(MemoryLayout.size) print(MemoryLayout.size(ofValue: age)) // print 9 9 9 print(MemoryLayout>.stride) print(MemoryLayout.stride(ofValue: age)) // print 16 16 1.4 延迟存储属性线程不安全，多线程首次访问存在重复赋值 2 类型属性 class LGTearch { static var age : Int = 20 } 必须有默认值 在全局区 在生成的sil文件中可以看到使用builtin once初始化，这个相当于swift_once，底层是调用了GCD的dispatch_once，意味着只初始化一次，线程安全 拓展：swift中的单例写法 class LGTeacher{ static let sharedInstance: LGTeacher = LGTeacher() private init(){} } 3 结构体的初始化 struct LGTeacher { var age : Int = 20 func teach() { print(\"teach\") } } var t = LGTeacher() t = LGTeacher(age: 39); t.teach() 如果class的属性没有默认值，需要自定义初始化方法进行属性初始化 编译器会为结构体提供默认的初始化方法 根据属性默认值的状态，提供不同的初始化方法 如果我们自定义了初始化方法，编译器不再生成初始化方法 4 结构体是值类型 4.1 关于mutating 使用sil查看方法实现，可以看到方法中的默认参数self，是使用let修饰的，对于值类型，修改其中的属性，相当于是修改self，所以是不能修改的 如果要修改，使用mutating修饰方法 使用mutating修饰的方法，相当于是给self参数添加了一个inout mutating修饰方法，inout修饰参数 4.2 结构体中的方法 结构体并不存储方法，静态调用 调用结构体的方法为直接地址调用，编译期确定，静态绑定。汇编代码中使用callq调用 mach-o中的symbol table，表示符号位于字符串表（string table）中的位置 string table存储了所有的变量名和函数名 符号化的时候，根据符号表中的地址和偏移量，去string table找到对应的符号名 命名重整：就是看符号表中的符号命名是否具有唯一性。Swift有复杂的命名规则，所以可以符号重载 4.3 ASLR 静态基地址：在mach-o文件中的LC中的Text中的vm address里 最终的程序起始地址为vm address + ASLR地址，所以通过image list调试命令获取的程序起始地址减去vm address地址，就算出了ASLR地址，使用ASLR地址加上调用地址，就得出了真正运行时候的地址 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-15 15:29:42 "},"articles/iOS/swift/language/01_基础部分.html":{"url":"articles/iOS/swift/language/01_基础部分.html","title":"01_基础部分","keywords":"","body":"一、基础部分 1.1 常量和变量 // 常量 let maximumNumberOfLoginAttempts = 10 // 变量 var currentLoginAttempt = 0 // 一行声明多个变量，使用逗号隔开 var x = 0.0, y = 0.0, z = 0.0 1.2 类型推断与类型注解 Swift会自动进行类型推断，但是也可以主动进行类型声明 var welcomeMessage: String welcomeMessage = \"Hello\" // 声明多个 var red, green, blue: Double 1.3 字符串插值 Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：\\(xxx) let friendlyWelcome = Bonjour print(\"The current value of friendlyWelcome is \\(friendlyWelcome)\") // 输出“The current value of friendlyWelcome is Bonjour!” 1.4 整数 可以访问不同整数类型的 min 和 max 属性来获取对应类型的最小值和最大值： let minValue = UInt8.min // minValue 为 0，是 UInt8 类型 let maxValue = UInt8.max // maxValue 为 255，是 UInt8 类型 1.5 字面量的类型自动推断 当推断浮点数的类型时，Swift 总是会选择 Double 而不是 Float 整形一般推断为Int 1.6 字面量表示 一个十进制数，没有前缀 一个二进制数，前缀是 0b 一个八进制数，前缀是 0o 一个十六进制数，前缀是 0x 十进制浮点数也可以有一个可选的指数（exponent)，通过大写或者小写的 e 来指定；十六进制浮点数必须有一个指数，通过大写或者小写的 p 来指定。 1.25e2 表示 1.25 × 10^2，等于 125.0。 1.25e-2 表示 1.25 × 10^-2，等于 0.0125。 0xFp2 表示 15 × 2^2，等于 60.0。 0xFp-2 表示 15 × 2^-2，等于 3.75。 1.7 字面量额外的格式来增强可读性 类似 typedef typealias AudioSample = UInt16 var maxAmplitudeFound = AudioSample.min // maxAmplitudeFound 现在是 0 1.8 元组 1.8.1 元组定义 元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型 let http404Error = (404, \"Not Found\") // http404Error 的类型是 (Int, String)，值是 (404, \"Not Found\") 1.8.2 元组分解 可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了 let (statusCode, statusMessage) = http404Error print(\"The status code is \\(statusCode)\") // 输出“The status code is 404” print(\"The status message is \\(statusMessage)\") // 输出“The status message is Not Found” 如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记 let (justTheStatusCode, _) = http404Error print(\"The status code is \\(justTheStatusCode)\") // 输出“The status code is 404” 1.8.3 元组元素访问 还可以通过下标来访问元组中的单个元素，下标从零开始 print(\"The status code is \\(http404Error.0)\") // 输出“The status code is 404” print(\"The status message is \\(http404Error.1)\") // 输出“The status message is Not Found” 可以在定义元组的时候给单个元素命名 let http200Status = (statusCode: 200, description: \"OK\") print(\"The status code is \\(http200Status.statusCode)\") // 输出“The status code is 200” print(\"The status message is \\(http200Status.description)\") // 输出“The status message is OK” 1.8.4 可选值 可选类型表示两种可能： 或者有值， 你可以解析可选类型访问这个值， 或者根本没有值nil 1.8.4.1 语法 var serverResponseCode: Int? = 404 var surveyAnswer: String? // surveyAnswer 被自动设置为 nil 注意 Swift 的 nil 和 Objective-C 中的 nil 并不一样。在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 nil，不只是对象类型。 1.8.4.2 可选绑定 可选绑定可以用在 if guard和 while 语句中 if let constantName = someOptional { statements } 可以包含多个可选绑定或多个布尔条件在一个 if 语句中，只要使用逗号分开就行。只要有任意一个可选绑定的值为 nil，或者任意一个布尔条件为 false，则整个 if 条件判断为 false // 下面的两个 if 语句是等价的 if let firstNumber = Int(\"4\"), let secondNumber = Int(\"42\"), firstNumber 1.8.4.2 隐式解析可选类型 一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。 let possibleString: String? = \"An optional string.\" let forcedString: String = possibleString! // 需要感叹号来获取值 let assumedString: String! = \"An implicitly unwrapped optional string.\" let implicitString: String = assumedString // 不需要感叹号 1.9 错误处理 // 抛出错误 func canThrowAnError() throws { // 这个函数有可能抛出错误 } // 接收错误 do { try canThrowAnError() // 没有错误消息抛出 } catch { // 有一个错误消息抛出 } // catch多种错误 func makeASandwich() throws { // ... } do { try makeASandwich() eatASandwich() } catch SandwichError.outOfCleanDishes { washDishes() } catch SandwichError.missingIngredients(let ingredients) { buyGroceries(ingredients) } 1.10 断言和先决条件 let age = -3 assert(age >= 0, \"A person's age cannot be less than zero\") // 因为 age = 0) 如果代码已经检查了条件，你可以使用 assertionFailure(_:file:line:) 函数来表明断言失败了 if age > 10 { print(\"You can ride the roller-coaster or the ferris wheel.\") } else if age > 0 { print(\"You can ride the ferris wheel.\") } else { assertionFailure(\"A person's age can't be less than zero.\") } 先决条件类似断言 // 在一个下标的实现里... precondition(index > 0, \"Index must be greater than zero.\") 如果你使用 unchecked 模式（-Ounchecked）编译代码，先决条件将不会进行检查。编译器假设所有的先决条件总是为 true（真），他将优化你的代码。 fatalError(_:file:line:) 函数总是中断执行，无论你怎么进行优化设定。 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-15 15:29:42 "},"articles/iOS/swift/language/02_运算符.html":{"url":"articles/iOS/swift/language/02_运算符.html","title":"02_运算符","keywords":"","body":"二、运算符 1 算术运算符 Swift 默认情况下不允许在数值运算中出现溢出情况 可以使用 Swift 的溢出运算符来实现溢出运算 加法运算符也可用于 String 的拼接： \"hello, \" + \"world\" // 等于 \"hello, world\" 2 比较运算符 Swift 也提供恒等（===）和不恒等（!==）这两个比较符来判断两个对象是否引用同一个对象实例。 如果两个元组的元素相同，且长度相同的话，元组就可以被比较。比较元组大小会按照从左到右、逐值比较的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这一对元组我们就称它们是相等的。 (1, \"zebra\") Swift 标准库只能比较七个以内元素的元组比较函数。如果你的元组元素超过七个时，你需要自己实现比较运算符。 3 空合运算符（Nil Coalescing Operator） 空合运算符（a ?? b）将对可选类型 a 进行空判断，如果 a 包含一个值就进行解包，否则就返回一个默认值 b。表达式 a 必须是 Optional 类型。默认值 b 的类型必须要和 a 存储值的类型保持一致 // 空合运算符是对以下代码的简短表达方法 a != nil ? a! : b 4 区间运算符（Range Operators） 4.1 闭区间运算符 闭区间运算符（a...b）定义一个包含从 a 到 b（包括 a 和 b）的所有值的区间。a 的值不能超过 b for index in 1...5 { print(\"\\(index) * 5 = \\(index * 5)\") } // 1 * 5 = 5 // 2 * 5 = 10 // 3 * 5 = 15 // 4 * 5 = 20 // 5 * 5 = 25 4.2 半开区间运算符 半开区间运算符（a..）定义一个从 a 到 b 但不包括 b 的区间。 4.3 单侧区间 闭区间操作符有另一个表达形式，可以表达往一侧无限延伸的区间 —— 例如，一个包含了数组从索引 2 到结尾的所有值的区间。在这些情况下，你可以省略掉区间操作符一侧的值。这种区间叫做单侧区间，因为操作符只有一侧有值。 a... ...b // 从index 2 到结束 for name in names[2...] { print(name) } // Brian // Jack // 从开始到index 2 for name in names[...2] { print(name) } // Anna // Alex // Brian 半开区间操作符也有单侧表达形式，附带上它的最终值。就像你使用区间去包含一个值，最终值并不会落在区间内 .. for name in names[.. 特殊用法 let range = ...5 range.contains(7) // false range.contains(4) // true range.contains(-1) // true 5 高级运算符 5.1 溢出运算符 Swift 中的算术运算符默认是不会溢出的。所有溢出行为都会被捕获并报告为错误。 如果想让系统允许溢出行为，可以选择使用 Swift 中另一套默认支持溢出的运算符。 溢出加法 &+ 溢出减法 &- 溢出乘法 &* 对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大数 5.2 位运算符 5.2.1 按位取反运算符（~） 5.2.2 按位与运算符（&） 5.2.3 按位或运算符（|） 5.2.4 按位异或运算符，或称“排外的或运算符”（^） 5.2.5 按位左移运算符（） 和 按位右移运算符（>>） 无符号整数的移位运算 已存在的位按指定的位数进行左移和右移。 任何因移动而超出整型存储范围的位都会被丢弃。 用 0 来填充移位后产生的空白位。 有符号整数的移位运算 二进制补码表示，按位取反+1 右移使用符号位填充 5.2.6 运算符重载 不能对默认的赋值运算符（=）进行重载。只有复合赋值运算符可以被重载。同样地，也无法对三元条件运算符 （a ? b : c） 进行重载。 二元运算符重载 struct Vector2D { var x = 0.0, y = 0.0 } extension Vector2D { static func + (left: Vector2D, right: Vector2D) -> Vector2D { return Vector2D(x: left.x + right.x, y: left.y + right.y) } } let vector = Vector2D(x: 3.0, y: 1.0) let anotherVector = Vector2D(x: 2.0, y: 4.0) let combinedVector = vector + anotherVector // combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0) 前缀和后缀运算符 要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 func 关键字之前指定 prefix 或者 postfix 修饰符 extension Vector2D { static prefix func - (vector: Vector2D) -> Vector2D { return Vector2D(x: -vector.x, y: -vector.y) } } let positive = Vector2D(x: 3.0, y: 4.0) let negative = -positive // negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例 let alsoPositive = -negative // alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例 复合赋值运算符 需要inout 复合赋值运算符将赋值运算符（=）与其它运算符进行结合。例如，将加法与赋值结合成加法赋值运算符（+=）。在实现的时候，需要把运算符的左参数设置成 inout 类型，因为这个参数的值会在运算符函数内直接被修改。 extension Vector2D { static func += (left: inout Vector2D, right: Vector2D) { left = left + right } } var original = Vector2D(x: 1.0, y: 2.0) let vectorToAdd = Vector2D(x: 3.0, y: 4.0) original += vectorToAdd // original 的值现在为 (4.0, 6.0) Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-15 15:29:42 "},"articles/iOS/swift/language/03_字符串.html":{"url":"articles/iOS/swift/language/03_字符串.html","title":"03_字符串","keywords":"","body":"二、字符串 Swift 的 String 类型与 Foundation NSString 类进行了无缝桥接。Foundation 还对 String 进行扩展使其可以访问 NSString 类型中定义的方法。这意味着调用那些 NSString 的方法，你无需进行任何类型转换。 更多关于在 Foundation 和 Cocoa 中使用 String 的信息请查看 Bridging Between String and NSString。 1 多行字符串字面量 let quotation = \"\"\" The White Rabbit put on his spectacles. \"Where shall I begin, please your Majesty?\" he asked. \"Begin at the beginning,\" the King said gravely, \"and go on till you come to the end; then stop.\" \"\"\" 如果你想换行，以便加强代码的可读性，但是你又不想在你的多行字符串字面量中出现换行符的话，你可以用在行尾写一个反斜杠（\\）作为续行符 let softWrappedQuotation = \"\"\" The White Rabbit put on his spectacles. \"Where shall I begin, \\ please your Majesty?\" he asked. \"Begin at the beginning,\" the King said gravely, \"and go on \\ till you come to the end; then stop.\" \"\"\" 一个多行字符串字面量能够缩进来匹配周围的代码。关闭引号（\"\"\"）之前的空白字符串告诉 Swift 编译器其他各行多少空白字符串需要忽略。然而，如果你在某行的前面写的空白字符串超出了关闭引号（\"\"\"）之前的空白字符串，则超出部分将被包含在多行字符串字面量中。 2 扩展字符串分隔符 可以将字符串文字放在扩展分隔符中，这样字符串中的特殊字符将会被直接包含而非转义后的效果。 将字符串放在引号（\"）中并用数字符号（#）括起来。例如，打印字符串文字 #\"Line 1 \\nLine 2\"# 会打印换行符转义序列（\\n）而不是给文字换行。 如果需要字符串文字中字符的特殊效果，请匹配转义字符（\\）后面添加与起始位置个数相匹配的 # 符。 例如，如果您的字符串是 #\"Line 1 \\nLine 2\"# 并且您想要换行，则可以使用 #\"Line 1 \\#nLine 2\"# 来代替。 同样，###\"Line1 \\###nLine2\"### 也可以实现换行效果。 扩展分隔符创建的字符串文字也可以是多行字符串文字。 您可以使用扩展分隔符在多行字符串中包含文本 \"\"\"，覆盖原有的结束文字的默认行为。例如： let threeMoreDoubleQuotationMarks = #\"\"\" Here are three more double quotes: \"\"\" \"\"\"# 3 字符串是值类型 在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着你将字符串作为值类型的同时可以获得极高的性能。 4 Character 单个字符 let exclamationMark: Character = \"!\" 字符串可以通过传递一个值类型为 Character 的数组作为自变量来初始化： let catCharacters: [Character] = [\"C\", \"a\", \"t\", \"!\", \"&#x1F431;\"] let catString = String(catCharacters) print(catString) // 打印输出：“Cat!&#x1F431;” 5 计算字符数量 如果想要获得一个字符串中 Character 值的数量，可以使用 count 属性： let unusualMenagerie = \"Koala &#x1F428;, Snail &#x1F40C;, Penguin &#x1F427;, Dromedary &#x1F42A;\" print(\"unusualMenagerie has \\(unusualMenagerie.count) characters\") // 打印输出“unusualMenagerie has 40 characters” 注意在 Swift 中，使用可拓展的字符群集作为 Character 值来连接或改变字符串时，并不一定会更改字符串的字符数量。 注意 可扩展的字形群可以由多个 Unicode 标量组成。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果你正在处理一个长字符串，需要注意 count 属性必须遍历全部的 Unicode 标量，来确定字符串的字符数量。 另外需要注意的是通过 count 属性返回的字符数量并不总是与包含相同字符的 NSString 的 length 属性相同。NSString 的 length 属性是利用 UTF-16 表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集。 6 字符串下标语法 每一个 String 值都有一个关联的索引（index）类型，String.Index，它对应着字符串中的每一个 Character 的位置。 不同的字符可能会占用不同数量的内存空间，所以要知道 Character 的确定位置，就必须从 String 开头遍历每一个 Unicode 标量直到结尾。因此，Swift 的字符串不能用整数（integer）做索引。 使用 startIndex 属性可以获取一个 String 的第一个 Character 的索引。使用 endIndex 属性可以获取最后一个 Character 的后一个位置的索引。因此，endIndex 属性不能作为一个字符串的有效下标。如果 String 是空串，startIndex 和 endIndex 是相等的。 let greeting = \"Guten Tag!\" greeting[greeting.startIndex] // G greeting[greeting.index(before: greeting.endIndex)] // ! greeting[greeting.index(after: greeting.startIndex)] // u let index = greeting.index(greeting.startIndex, offsetBy: 7) greeting[index] // a 使用 indices 属性会创建一个包含全部索引的范围（Range），用来在一个字符串中访问单个字符。 for index in greeting.indices { print(\"\\(greeting[index]) \", terminator: \"\") } // 打印输出“G u t e n T a g ! ” 7 插入和删除 调用 insert(_:at:) 方法可以在一个字符串的指定索引插入一个字符，调用 insert(contentsOf:at:) 方法可以在一个字符串的指定索引插入一个段字符串。 var welcome = \"hello\" welcome.insert(\"!\", at: welcome.endIndex) // welcome 变量现在等于 \"hello!\" welcome.insert(contentsOf:\" there\", at: welcome.index(before: welcome.endIndex)) // welcome 变量现在等于 \"hello there!\" 调用 remove(at:) 方法可以在一个字符串的指定索引删除一个字符，调用 removeSubrange(_:) 方法可以在一个字符串的指定索引删除一个子字符串。 welcome.remove(at: welcome.index(before: welcome.endIndex)) // welcome 现在等于 \"hello there\" let range = welcome.index(welcome.endIndex, offsetBy: -6).. 8 子字符串 是一种独立的类型：Substring Swift 里的 Substring 绝大部分函数都跟 String 一样，意味着你可以使用同样的方式去操作 Substring 和 String。然而，跟 String 不同的是，你只有在短时间内需要操作字符串时，才会使用 Substring。当你需要长时间保存结果时，就把 Substring 转化为 String 的实例： let greeting = \"Hello, world!\" let index = greeting.firstIndex(of: \",\") ?? greeting.endIndex let beginning = greeting[.. 关于内存： String 和 Substring 的区别在于性能优化上，Substring 可以重用原 String 的内存空间，或者另一个 Substring 的内存空间（String 也有同样的优化，但如果两个 String 共享内存的话，它们就会相等）。这一优化意味着你在修改 String 和 Substring 之前都不需要消耗性能去复制内存。就像前面说的那样，Substring 不适合长期存储 —— 因为它重用了原 String 的内存空间，原 String 的内存空间必须保留直到它的 Substring 不再被使用为止。 9 字符串比较 字符串/字符相等 let quotation = \"We're a lot alike, you and I.\" let sameQuotation = \"We're a lot alike, you and I.\" if quotation == sameQuotation { print(\"These two strings are considered equal\") } // 打印输出“These two strings are considered equal” 如果两个字符串（或者两个字符）的可扩展的字形群集是标准相等，那就认为它们是相等的。只要可扩展的字形群集有同样的语言意义和外观则认为它们标准相等，即使它们是由不同的 Unicode 标量构成。 // \"Voulez-vous un café?\" 使用 LATIN SMALL LETTER E WITH ACUTE let eAcuteQuestion = \"Voulez-vous un caf\\u{E9}?\" // \"Voulez-vous un café?\" 使用 LATIN SMALL LETTER E and COMBINING ACUTE ACCENT let combinedEAcuteQuestion = \"Voulez-vous un caf\\u{65}\\u{301}?\" if eAcuteQuestion == combinedEAcuteQuestion { print(\"These two strings are considered equal\") } // 打印输出“These two strings are considered equal” 前缀/后缀 通过调用字符串的 hasPrefix(_:)/hasSuffix(_:) 方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个 String 类型的参数，并返回一个布尔值。 10 字符串的 Unicode 表示形式 字符的ascii let s = \"Dog‼&#x1F436;\" // ascii for i in s { print(i.asciiValue ?? \"none\") // 可选值 } /** 68 111 103 none none */ UTF-8 let s = \"Dog‼&#x1F436;\" // utf8 可变长编码 一个字符可能由多个UInt8构成 for i in s.utf8 { print(i) } /** 68 111 103 226 128 188 240 159 144 182 */ UTF-16 let s = \"Dog‼&#x1F436;\" // UTF-16 一个字符可能由多个UInt16构成 for i in s.utf16 { print(i) } /** 68 111 103 8252 55357 56374 */ Unicode标量值 可以通过遍历 String 值的 unicodeScalars 属性来访问它的 Unicode 标量表示，每一个 UnicodeScalar 拥有一个 value 属性，可以返回对应的 21 位数值，用 UInt32 来表示 let s = \"Dog‼&#x1F436;\" // Unicode 标量表示 .value表示数值 for i in s.unicodeScalars { print(i.value) } /** 68 111 103 8252 128054 */ Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-01-29 14:33:11 "},"articles/iOS/swift/server/Vapor搭建服务端模拟接口请求.html":{"url":"articles/iOS/swift/server/Vapor搭建服务端模拟接口请求.html","title":"Vapor搭建服务端模拟接口请求","keywords":"","body":"基于Vapor 4 搭建服务端模拟接口请求 网上有很多基于node搭建的模拟接口请求，身为iOS程序员，这里使用Swift+Vapor搭建一波 Note: Vapor 4 requires Swift 5.2, both in Xcode and from the command line. Xcode 11.4 and 11.5 both provide Swift 5.2. 参考文献 Getting Started with Server-Side Swift with Vapor 4 Vapor中文文档 Vapor4 的安装与配置 安装Vapor macOS brew install vapor # To make sure Vapor is correctly installed run vapor # success > vapor Usage: vapor Vapor Toolbox (Server-side Swift web framework) Commands: build Builds an app in the console. clean Cleans temporary files. heroku Commands for working with Heroku new Generates a new app. run Runs an app from the console. supervisor Commands for working with Supervisord xcode Opens an app in Xcode. Use `vapor [--help,-h]` for more information on a command. Error: Error: Missing command > Linux 安装Swift 查看系统版本 $ lsb_release -a LSB Version: core-9.20170808ubuntu1-noarch:security-9.20170808ubuntu1-noarch Distributor ID: Ubuntu Description: Ubuntu 18.04.3 LTS Release: 18.04 Codename: bionic 安装对用版本Swift必要依赖（swift.org上可以查找） sudo apt-get install clang sudo apt-get install libcurl3 libpython2.7 ... 下载对应版本的Swift wget https://swift.org/builds/swift-5.3.3-release/ubuntu1804/swift-5.3.3-RELEASE/swift-5.3.3-RELEASE-ubuntu18.04.tar.gz 解压（可自行指定目录） tar xzf swift-5.3.3-RELEASE-ubuntu18.04.tar.gz -C ~/swift 设置环境变量 sudo vi ~/.bashrc export PATH=~/swift/swift-5.3.3-RELEASE-ubuntu18.04.tar.gz/usr/bin:$PATH 验证是否安装成功 swift -version 安装Vapor git clone https://github.com/vapor/toolbox.git cd toolbox git checkout make install 安装对应版本系统依赖库 参考https://swift.org/download/#using-downloads说明，我这里安装的是20.04对应的依赖 $ apt-get install \\ binutils \\ git \\ gnupg2 \\ libc6-dev \\ libcurl4 \\ libedit2 \\ libgcc-9-dev \\ libpython2.7 \\ libsqlite3-0 \\ libstdc++-9-dev \\ libxml2 \\ libz3-dev \\ pkg-config \\ tzdata \\ zlib1g-dev 搭建App 创建目录 mkdir ~/vapor cd ~/vapor 新建项目 $ vapor new HelloVapor Cloning template... name: HelloVapor Would you like to use Fluent? (--fluent) y/n> n fluent: No Would you like to use Leaf? (--leaf) y/n> n leaf: No Generating project files + Package.swift ... 运行项目 # 1 cd HelloVapor # 2 swift run 初次会下载安装所有依赖库，完成后项目开始运行 Resolving https://github.com/vapor/multipart-kit.git at 4.0.0 Cloning https://github.com/apple/swift-nio-extras.git Resolving https://github.com/apple/swift-nio-extras.git at 1.7.0 [1457/1457] Linking Run [ NOTICE ] Server starting on http://127.0.0.1:8080 浏览器输入http://localhost:8080/hello访问 在Xcode中运行 打开Package.swift文件 open Package.swift 首次打开Xcode会安装依赖，并在目录下生成隐藏文件夹.swiftpm（这个就是Xcode的工程文件，类似iOS项目中的project文件） 新建Url路径 编辑routes.swift文件 app.get(\"hello\", \"vapor\") { req -> String in return \"Hello Vapor!\" } 访问http://localhost:8080/hello/vapor 获取Url上的参数 // 1 app.get(\"hello\", \":name\") { req -> String in //2 guard let name = req.parameters.get(\"name\") else { throw Abort(.internalServerError) } // 3 return \"Hello, \\(name)!\" } 访问http://localhost:8080/hello/Tim 获取Post参数 发送请求（使用软件：RESTed） URL: http://localhost:8080/info Method: POST header: Content-Type=application/json params：name JSON-encoded 在routes.swift下面创建请求参数结构体 struct InfoData: Content { let name: String } 获取请求中的参数 // 1 app.post(\"info\") { req -> String in // 2 let data = try req.content.decode(InfoData.self) // 3 return \"Hello \\(data.name)!\" } 使用curl测试 $ curl http://localhost:8080/info \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"Tim\"}' Hello Tim!% 返回JSON 新建响应类型 struct InfoResponse: Content { let request: InfoData } 新建请求路由 // 1 app.post(\"info\") { req -> InfoResponse in let data = try req.content.decode(InfoData.self) // 2 return InfoResponse(request: data) } 更新依赖 在Xcode中 File ▸ Swift Packages ▸ Update to Latest Package Versions. 在Terminal中 swift package update Clean and Rebuild 在Xcode中 直接clean，build 手动删除 删除.build 删除.swiftpm 删除.Package.resolved 删除DerivedData 遇到的问题 Linux上Swift运行报错 $ swift error: ld-2.27.so 0x7fffffff0005c564: adding range [0x1464a-0x146ba) which has a base that is less than the function's low PC 0x14dc0. Please file a bug and attach the file at the start of this error message error: ld-2.27.so 0x7fffffff0005c564: adding range [0x146d0-0x146d6) which has a base that is less than the function's low PC 0x14dc0. Please file a bug and attach the file at the start of this error message error: ld-2.27.so 0x7fffffff0005c5c5: adding range [0x1464a-0x146ba) which has a base that is less than the function's low PC 0x14dc0. Please file a bug and attach the file at the start of this error message error: ld-2.27.so 0x7fffffff0005c5c5: adding range [0x146d0-0x146d6) which has a base that is less than the function's low PC 0x14dc0. Please file a bug and attach the file at the start of this error message Welcome to Swift version 5.3.3 (swift-5.3.3-RELEASE). Type :help for assistance. 解决：https://bugs.swift.org/browse/SR-8690 sudo apt remove libc6-dbg 离开Swift命令行 # 命令前加: :quit 端口占用 #查看端口占用情况 lsof -i tcp:8080 #杀掉进程 kill Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-05 17:05:21 "},"articles/iOS/swift/mjswift/01_swiftc.html":{"url":"articles/iOS/swift/mjswift/01_swiftc.html","title":"01_编译命令swiftc","keywords":"","body":"编译命令 编译命令swiftc # 生成语法树 swiftc -dump-ast main.swift # 生成最简洁的SIL代码 swiftc -emit-sil main.swift # 生成LLVM IR代码 swiftc -emit-ir main.swift -o main.ll # 生成汇编代码 swiftc -emit-assembly main.swift -o main.s Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2022-02-27 23:59:32 "},"articles/iOS/swift/mjswift/02_playground.html":{"url":"articles/iOS/swift/mjswift/02_playground.html","title":"02_Playground","keywords":"","body":"Playground view import UIKit import PlaygroundSupport let view = UIView() view.frame = CGRect(x: 0, y: 0, width: 100, height: 100) view.backgroundColor = UIColor.red PlaygroundPage.current.liveView = view let imageView = UIImageView(image: UIImage(named: \"banana\")) PlaygroundPage.current.liveView = imageView let vc = UITableViewController() vc.view.backgroundColor = UIColor.lightGray PlaygroundPage.current.liveView = vc 多page Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2022-02-28 00:24:33 "},"articles/iOS/ui/CoreAnimation.html":{"url":"articles/iOS/ui/CoreAnimation.html","title":"核心动画","keywords":"","body":"iOS核心动画 一、CALayer 1.1、图层的能力 这里有一些 UIView 没有暴露出来的CALayer的功能： 阴影，圆角，带颜色的边框 3D变换 非矩形范围 透明遮罩 多级非线性动画 1.2、寄宿图 这一模块将来探索 CALayer的寄宿图（即图层中包含的图） 1）contents属性 CALayer 有一个属性叫做 contents ，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，可以给 contents 属性赋任何值，app 仍然能够编译通过。但是，在实践中，如果给 contents 赋的不是CGImage， 那么得到的图层将是空白的。 UIView *centerView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 200, 100)]; centerView.backgroundColor = [UIColor lightGrayColor]; centerView.center = self.view.center; [self.view addSubview:centerView]; UIImage *image = [UIImage imageNamed:@\"1\"]; centerView.layer.contents = (__bridge id)(image.CGImage); 2）contentGravity属性 类似UIImageView的contentMode centerView.layer.contentsGravity = kCAGravityResizeAspect; 3）contentsScale属性 contentsScale属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置contentsGravity属性）。UIView有一个类似功能但是非常少用到的contentScaleFactor属性。 如果contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。 当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的contentsScale属性，否则，你的图片在Retina设备上就显示得不正确啦。代码如下： layer.contentsScale = [UIScreen mainScreen].scale; 4）contentsRect属性 CALayer的contentsRect属性允许我们在图层边框里显示寄宿图的一个子域。 5）contentsCenter属性 contentsCenter其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变contentsCenter的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。 6）Custom Drawing 给 contents 赋CGImage的值不是唯一的设置寄宿图的方法。也可以直接 用Core Graphics直接绘制寄宿图。 能够通过继承UIView并实现 -drawRect: 方法 来自定义绘制。 -drawRect: 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须 的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到 - drawRect: 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 contentsScale 的值。 如果不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。 当视图在屏幕上出现的时候 -drawRect: 方法就会被自动调用。 - drawRect: 方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了 -setNeedsDisplay 方 法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘， 如 bounds 属性）。 虽然 -drawRect: 方法是一个UIView方法，事实上都是底层 的CALayer安排了重绘工作和保存了因此产生的图片。所以也可以通过使用CALayer来进行自定义寄宿图绘制 CALayer有一个可选的 delegate 属性，实现了 CALayerDelegate 协议，当 CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一 个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。 当需要被重绘时，CALayer会请求它的代理给他一个寄宿图来显示。它通过调用 下面这个方法做到的: - (void)displayLayer:(CALayer *)layer; // 如果代理不实现 -displayLayer: 方法， CALayer就会转而尝试调用下面这个方法： - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx; // force layer to redraw ，类似UIView的setNeedsDisplay - (void)display; 在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸 由 bounds 和 contentsScale 决定）和一个Core Graphics的绘制上下文环境， 为绘制寄宿图做准备，他作为ctx参数传入。代码如下： // 记得需要调用 [layer display] 进行force draw - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx { CGContextSetLineWidth(ctx, 10); CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor); CGContextStrokeEllipseInRect(ctx, layer.bounds); } 当使用寄宿了视图的图层的时候，你也不必实现 -displayLayer: 和 - drawLayer:inContext: 方法来绘制你的寄宿图。通常做法是实现UIView的 - drawRect: 方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调 用 -display 方法。 二、图层几何学 2.1、布局 UIView 有三个比较重要的布局属 性： frame ， bounds 和 center ， CALayer 对应地叫 做 frame ， bounds 和 position 。为了能清楚区分，图层用了“position”，视图用了“center”，但是都代表同样的值。 frame 代表了图层的外部坐标（也就是在父图层上占据的空间）， bounds 是 内部坐标（{0, 0}通常是图层的左上角）， center 和 position 都代表了相对于 父图层 anchorPoint 所在的位置。 anchorPoint 的属性后续介绍到，现在把它想成图层的中心点就好了。 对于视图或者图层来说， frame 并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据 bounds ， position 和 transform 计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到当中的值。 记住当对图层做变换的时候，比如旋转或者缩放， frame 实际上代表了覆盖在 图层旋转之后的整个轴对齐的矩形区域，也就是说 frame 的宽高可能 和 bounds 的宽高不再一致了 2.2、锚点 anchorPoint 默认来说， anchorPoint 位于图层的中点，所以图层的将会以这个点为中心放置。 anchorPoint 属性并没有被 UIView 接口暴露出来，这也是视图的position 属性被叫做“center”的原因。但是图层的 anchorPoint 可以被移动，比如可以把 它置于图层 frame 的左上角，于是图层的内容将会向右下角的 position 方向移动，而不是居中了。 当改变了 anchorPoint ， position 属性保持固定的值并没 有发生改变，但是 frame 却移动了。 position是layer中的anchorPoint点在superLayer中的位置坐标，因此可以说, position点是相对suerLayer的，anchorPoint点是相对layer的，两者是相对不同的坐标空间的一个重合点。 如果单方面修改layer的position位置，会对anchorPoint有什么影响呢？修改anchorPoint又如何影响position呢？ 根据代码测试，两者互不影响，受影响的只会是frame.origin，也就是layer坐标原点相对superLayer会有所改变。换句话说，frame.origin由position和anchorPoint共同决定。 position.x = frame.origin.x + anchorPoint.x * bounds.size.width； position.y = frame.origin.y + anchorPoint.y * bounds.size.height； frame.origin.x = position.x - anchorPoint.x * bounds.size.width； frame.origin.y = position.y - anchorPoint.y * bounds.size.height； 2.3、坐标系 CALayer 给不同坐标系之间的图层转换提供了一些工具类方法，这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下 的点或者矩形。 - (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer; - (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer; - (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer; - (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer; zPosition 3D变换 改变图层的显示顺序了 // zPosition UIView *greenView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)]; greenView.backgroundColor = [UIColor greenColor]; UITapGestureRecognizer *gTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(gClick)]; [greenView addGestureRecognizer:gTap]; [self.view addSubview:greenView]; UIView *redView = [[UIView alloc] initWithFrame:CGRectMake(150, 150, 100, 100)]; redView.backgroundColor = [UIColor redColor]; UITapGestureRecognizer *rTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(rClick)]; [redView addGestureRecognizer:rTap]; [self.view addSubview:redView]; // 切换zPosition greenView.layer.zPosition = 1; // 改变了图层顺序，但是不改变视图顺序，相交位置点击事件仍然由redView响应 2.4、Hit Testing CALayer 并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法处理事件： -containsPoint: 和 -hitTest: 1）-containsPoint 接受一个在本图层坐标系下的 CGPoint ，如果这个点在图层 frame 范围内就返回 YES 。 这需要把触摸坐标转换成每个图层坐标系下的坐标。 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { CGPoint point = [[touches anyObject] locationInView:self.view]; BOOL isGreenContain = [self.greenView.layer containsPoint:[self.greenView.layer convertPoint:point fromLayer:self.view.layer]]; BOOL isRedContain = [self.redView.layer containsPoint:[self.redView.layer convertPoint:point fromLayer:self.view.layer]]; NSLog(@\"isGreenContain:%d,isRedContain:%d\",isGreenContain,isRedContain); } 对于重合区域，两个containsPoint都会判断为true 2）-hitTest 在父图层进行hitTest，返回合适的叶子节点图层 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { CGPoint point = [[touches anyObject] locationInView:self.view]; CALayer *layer = [self.view.layer hitTest:point]; if (layer == self.greenView.layer) { NSLog(@\"isGreenLayer\"); } else if (layer == self.redView.layer) { NSLog(@\"isRedLayer\"); } else { NSLog(@\"isViewLayer\"); } } hitTest会返回图层的最上层的最合适的Layer，会考虑zPosition，但是不影响视图View的响应链判断（响应链不考虑zPosition）。例如会返回greenLayer，但是响应的view是redView 2.5、自动布局 当使用视图的时候，可以充分利用UIView类接口暴露出来的UIViewAutoresizingMask和NSLayoutConstraintAPI，但如果想随意控制CALayer的布局，就需要手工操作。最简单的方法就是使用CALayerDelegate如下函数： - (void)layoutSublayersOfLayer:(CALayer *)layer; 当图层的bounds发生改变，或者图层的-setNeedsLayout方法被调用的时候，这个函数将会被执行。这使得你可以手动地重新摆放或者重新调整子图层的大小，但是不能像UIView的autoresizingMask和constraints属性做到自适应屏幕旋转。 这也是为什么最好使用视图而不是单独的图层来构建应用程序的另一个重要原因之一。 三、视觉效果 3.1、拉伸过滤 CALayer为此提供了三种拉伸过滤方法，他们是： kCAFilterLinear kCAFilterNearest kCAFilterTrilinear minification（缩小图片）和magnification（放大图片）默认的过滤器都是kCAFilterLinear，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。 kCAFilterTrilinear和kCAFilterLinear非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而\b得到最后的结果。 对于大图来说，双线性滤波和三线性滤波表现得更出色 kCAFilterNearest是一种比较武断的方法。从名字不难看出，这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重。 对于没有斜线的小图来说，最近过滤算法要好很多 3.2、组透明 当关闭了组透明后，透明度会混合叠加，当显示一个50%透明度的图层时，图层的每个像素都会一半显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，所看到的视图， 50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。 iOS7开始，系统默认开启了组透明，默认不会在有上面的情况；如需全局关闭组透明，在plist中设置UIViewGroupOpacity为NO。 关闭局部组透明： v1.layer.allowsGroupOpacity = NO; 可以设置CALayer的一个叫做 shouldRasterize 属性来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及 其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了 3.3、shouldRasterize 光栅化 光栅化就是把layer转化为位图的过程。 合成，是一个将不同位图放到一起来创建你最终在屏幕上看到图像的过程。 合成完成后，最终把多张位图合成得到一张位图。 1）开启shouldRasterize意味着什么。 设置一个CALayer的shouldRasterize=YES，相当于提前把一个CALayer光栅化。这个CALayer图层结构就被拍扁了，变成一张位图。 启用shouldRasterize属性会将图层绘制到一个屏幕之外的图像，然后这个图像将会被缓存起来。缓存起来是一个重要的特性，它几乎决定了shouldRasterize的所有应用场景。 如果有很多的子图层或者有复杂的效果应用，开启shouldRasterize就会比重绘所有事务的所有帧划得来得多。但是光栅化原始图像需要时间，而且还会消耗额外的内存。所以需要根据实际情况取舍。 2）应用场景 启用shouldRasterize提升复杂层级视图的性能 由于启用shouldRasterize得到的图像会被缓存起来。这大大减少了GPU的负担。试想在一个table view的cell中，有非常复杂的层级结构。滑动tableview的时候，GPU需要进行大量的合成，这有可能会导致性能问题。我们可以尝试将cell的layer的shouldRasterize打开提升性能。 启用shouldRasterize提升动画性能 对一个层级复杂的视图做动画时，也可以启用shouldRasterize避免GPU每帧都重新合成。 启用shouldRasterize改善离屏渲染的性能 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { //dequeue cell UITableViewCell *cell = [self.tableView dequeueReusableCellWithIdentifier:@\"Cell\" forIndexPath:indexPath]; ... //set text shadow cell.textLabel.backgroundColor = [UIColor clearColor]; cell.textLabel.layer.shadowOffset = CGSizeMake(0, 2); cell.textLabel.layer.shadowOpacity = 0.5; //rasterize cell.layer.shouldRasterize = YES; cell.layer.rasterizationScale = [UIScreen mainScreen].scale; return cell; } 3）注意事项 在一个经常会变化的layer中开启shouldRasterize是没有多大意义的，因为缓存的总是会被重新创建，而光栅化还要消耗性能，没准适得其反。 四、变换 将要研究可以用来对图层旋转，摆放或者扭曲的CGAffineTransform ，以及可以将扁平物体转换成三维空间对象 的 CATransform3D。 4.1、仿射变换 Core Graphics提供了一系 列函数，对完全没有数学基础的开发者也能够简单地做一些变换。如下几个函数都创建了一个 CGAffineTransform 实例： CGAffineTransformMakeRotation(CGFloat angle) CGAffineTransformMakeScale(CGFloat sx, CGFloat sy) CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty) UIView 可以通过设置 transform 属性做变换，但实际上它只是封装了内部图层 的变换。 CALayer 同样也有一个 transform 属性，但它的类型是 CATransform3D ，而不是 CGAffineTransform ， CALayer 对应 于 UIView 的 transform 属性叫做 affineTransform CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4); self.layerView.layer.affineTransform = transform; /* 注意我们使用的旋转常量是 M_PI_4 ，而不是你想象的45，因为iOS的变换函数使 用弧度而不是角度作为单位。弧度用数学常量pi的倍数表示，一个pi代表180度，所 以四分之一的pi就是45度。 C的数学函数库（iOS会自动引入）提供了pi的一些简便的换算， M_PI_4 于是就 是pi的四分之一，如果对换算不太清楚的话，可以用如下的宏做换算： */ #define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0) 4.2、混合变换 Core Graphics提供了一系列的函数可以在一个变换的基础上做更深层次的变换， 如果做一个既要缩放又要旋转的变换，这就会非常有用了。 CGAffineTransformRotate(CGAffineTransform t, CGFloat angle) CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy) CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty) 当操纵一个变换的时候，初始生成一个什么都不做的变换很重要--也就是创建一 个 CGAffineTransform 类型的空值，矩阵论中称作单位矩阵，Core Graphics同样也提供了一个方便的常量：CGAffineTransformIdentity 最后，如果需要混合两个已经存在的变换矩阵，就可以使用如下方法，在两个变换的基础上创建一个新的变换： CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2); CGAffineTransform transform = CGAffineTransformIdentity; transform = CGAffineTransformScale(transform, 0.5, 0.5); transform = CGAffineTransformRotate(transform, M_PI / 180.0 * 30.0); transform = CGAffineTransformTranslate(transform, 200, 0); self.greenView.transform = transform; 4.3、3D变换 和 CGAffineTransform 类似， CATransform3D 也是一个矩阵，但是和2x3的矩 阵不同， CATransform3D 是一个可以在3维空间内做变换的4x4的矩阵。 和 CGAffineTransform 矩阵类似，Core Animation提供了一系列的方法用来创建和组合 CATransform3D 类型的矩阵，和Core Graphics的函数类似，但是3D的平移和旋转多处了一个 z 参数，并且旋转函数除了 angle 之外多出 了 x , y , z 三个参数，分别决定了每个坐标轴方向上的旋转： CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z) CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz) CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz) Z轴和这两个轴分别垂直，指向视角外为正方向。 4.4、透视投影 CATransform3D 的透视效果通过一个矩阵中一个很简单的元素来控 制： m34 。 m34用于按比例缩放X和Y的值来计算到底要离视角多远。 m34 的默认值是0，可以通过设置 m34 为-1.0 / d 来应用透视效果， d 代表了想象中视角相机和屏幕之间的距离，以像素为单位，那应该如何计算这个距离呢？实际上并不需要，大概估算一个就好了【通常500-1000就已经很好了】 CATransform3D transform = CATransform3DIdentity; transform.m34 = -1.0/500; transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0); self.greenView.layer.transform = transform; 4.5、案例：固体对象 用六个独立的视图来构建一个立方体的各个面。 - (void)viewDidLoad { [super viewDidLoad]; self.faces = @[_view0,_view1,_view2,_view3,_view4,_view5]; //父View的layer图层 CATransform3D perspective = CATransform3DIdentity; perspective.m34 = -1.0 / 500.0; perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0); perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0); self.containerView.layer.sublayerTransform = perspective; CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100); [self addFace:0 withTransform:transform]; //add cube face 2 transform = CATransform3DMakeTranslation(100, 0, 0); transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0); [self addFace:1 withTransform:transform]; //add cube face 3 transform = CATransform3DMakeTranslation(0, -100, 0); transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0); [self addFace:2 withTransform:transform]; //add cube face 4 transform = CATransform3DMakeTranslation(0, 100, 0); transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0); [self addFace:3 withTransform:transform]; //add cube face 5 transform = CATransform3DMakeTranslation(-100, 0, 0); transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0); [self addFace:4 withTransform:transform]; //add cube face 6 transform = CATransform3DMakeTranslation(0, 0, -100); transform = CATransform3DRotate(transform, M_PI, 0, 1, 0); [self addFace:5 withTransform:transform]; } - (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform{ //获取face视图并将其添加到容器中 UIView *face = self.faces[index]; [self.containerView addSubview:face]; //将face视图放在容器的中心 CGSize containerSize = self.containerView.bounds.size; face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0); //添加transform face.layer.transform = transform; } 五、专用图层 5.1、CAShapeLayer CAShapeLayer 是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用 CGPath 来定义想要绘制的图形，最 后CAShapeLayer 就自动渲染出来了。当然也可以用Core Graphics直接向原 始的 CALyer 的内容中绘制一个路径，相比直下，使用 CAShapeLayer 有以下一些优点： 渲染快速。 CAShapeLayer 使用了硬件加速，绘制同一图形会比用Core Graphics快很多。 高效使用内存。一个 CAShapeLayer 不需要像普通 CALayer 一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。 不会被图层边界剪裁掉。一个 CAShapeLayer 可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通 CALayer 一样被剪裁掉。 不会出现像素化。当你给 CAShapeLayer 做3D变换时，它不像一个有寄宿图 的普通图层一样变得像素化。 创建一个CGPath CAShapeLayer 可以用来绘制所有能够通过 CGPath 来表示的形状。这个形状不一定要闭合，图层路径也不一定要不可破，事实上你可以在一个图层上绘制好几个 不同的形状。你可以控制一些属性比如 lineWith（线宽，用点表示单 位），lineCap （线条结尾的样子），和 lineJoin （线条之间的结合点的样 子）；但是在图层层面你只有一次机会设置这些属性。如果你想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。 用例1：用CAShapeLayer绘制一个火柴人 // CAShapeLayer - (void)drawMatchstickMan { self.containerView.backgroundColor = [UIColor whiteColor]; [self.view addSubview:self.containerView]; UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:CGPointMake(175, 100)]; [path addArcWithCenter:CGPointMake(150, 100) radius:25 startAngle:0 endAngle:2*M_PI clockwise:YES]; [path moveToPoint:CGPointMake(150, 125)]; [path addLineToPoint:CGPointMake(150, 175)]; [path addLineToPoint:CGPointMake(125, 225)]; [path moveToPoint:CGPointMake(150, 175)]; [path addLineToPoint:CGPointMake(175, 225)]; [path moveToPoint:CGPointMake(100, 150)]; [path addLineToPoint:CGPointMake(200, 150)]; CAShapeLayer *layer = [CAShapeLayer layer]; layer.strokeColor = [UIColor redColor].CGColor; layer.fillColor = [UIColor clearColor].CGColor; layer.lineWidth = 5; layer.lineJoin = kCALineJoinRound; layer.lineCap = kCALineCapRound; layer.path = path.CGPath; [self.containerView.layer addSublayer:layer]; } 用例2： 用UIBezierPath绘制圆角+边框 // 绘制圆角+边框 - (void)drawCornerRect { [self.view addSubview:self.containerView]; self.containerView.backgroundColor = [UIColor lightGrayColor]; // 圆角 UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:self.containerView.bounds byRoundingCorners:UIRectCornerTopLeft | UIRectCornerBottomRight cornerRadii:CGSizeMake(20, 10)]; CAShapeLayer *cornerLayer = [CAShapeLayer layer]; cornerLayer.path = path.CGPath; self.containerView.layer.mask = cornerLayer; // 边框 CAShapeLayer *borderLayer = [CAShapeLayer layer]; borderLayer.path = path.CGPath; borderLayer.lineWidth = 10; borderLayer.strokeColor = [UIColor blueColor].CGColor; borderLayer.fillColor = [UIColor clearColor].CGColor; borderLayer.lineDashPattern = @[@10,@2]; [self.containerView.layer addSublayer:borderLayer]; } 5.2、 CATextLayer Core Animation提供了一个 CALayer 的子类 CATextLayer ，它以图层的形式包含了 UILabel 几乎所有的绘制特性，并且额外提供了一些新的特性。 CATextLayer 也要比 UILabel 渲染得快得多。很少有人知道在iOS 6及之前的版本， UILabel 其实是通过WebKit来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。而 CATextLayer 使用了Core text，并且渲染得 非常快。 用例1：用CATextLayer来实现一个UILabel // CATextLayer // 注意CATextLayer是通过fontSize设置字体大小的，CFTypeRef会忽略UIFont中的size大小 - (void)textLayerTesting { [self.view addSubview:self.containerView]; self.containerView.frame = CGRectMake(20, 150, 300, 500); CATextLayer *textLayer = [CATextLayer layer]; textLayer.frame = self.containerView.bounds; [self.containerView.layer addSublayer:textLayer]; textLayer.foregroundColor = [UIColor redColor].CGColor; textLayer.alignmentMode = kCAAlignmentJustified; [textLayer setWrapped:YES]; textLayer.font = (__bridge CFTypeRef)([UIFont systemFontOfSize:0]); textLayer.fontSize = 10; textLayer.string = @\"快速的业务发展也对技术支撑提出了更高的要求，为了保障敏捷的业务开发，提升跨团队的协同合作效率，提高本地研发和 CI/CD 效率，抖音 iOS App 工程架构在不同的阶段进行了不同的技术方案的改进，满足合理的架构演化，同时又不影响正常的业务迭代速度。\"; } 5.3、CATransformLayer 当在构造复杂的3D事物的时候，如果能够组织独立元素就太方便了。CATransformLayer 解决了这个问题， CATransformLayer不同于普通 的 CALayer ，因为它不能显示它自己的内容。只有当存在了一个能作用域子图层 的变换它才真正存在。 CATransformLayer 并不平面化它的子图层，所以它能够用于构造一个层级的3D结构。 用例1：用CATransformLayer装配一个3D图层体系 // CATransformLayer - (void)transformLayerTesting { self.view.backgroundColor = [UIColor blackColor]; [self.view addSubview:self.containerView]; self.containerView.frame = CGRectMake(0, 200, self.view.frame.size.width, 500); CATransform3D pt = CATransform3DIdentity; pt.m34 = -1.0/500; self.containerView.layer.sublayerTransform = pt; CATransform3D t1 = CATransform3DIdentity; t1 = CATransform3DTranslate(t1, -100, 0, 0); CALayer *cube1 = [self cubeWithTransform:t1]; [self.containerView.layer addSublayer:cube1]; CATransform3D t2 = CATransform3DIdentity; t2 = CATransform3DTranslate(t2, 100, 0, 0); t2 = CATransform3DRotate(t2, -M_PI_4, 1, 0, 0); t2 = CATransform3DRotate(t2, -M_PI_4, 0, 1, 0); CALayer *cube2 = [self cubeWithTransform:t2]; [self.containerView.layer addSublayer:cube2]; } - (CALayer *)cubeWithTransform:(CATransform3D)transform { //create cube layer CATransformLayer *cube = [CATransformLayer layer]; //add cube face 1 CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50); [cube addSublayer:[self faceWithTransform:ct]]; //add cube face 2 ct = CATransform3DMakeTranslation(50, 0, 0); ct = CATransform3DRotate(ct, M_PI_2, 0, 1, 0); [cube addSublayer:[self faceWithTransform:ct]]; //add cube face 3 ct = CATransform3DMakeTranslation(0, -50, 0); ct = CATransform3DRotate(ct, M_PI_2, 1, 0, 0); [cube addSublayer:[self faceWithTransform:ct]]; //add cube face 4 ct = CATransform3DMakeTranslation(0, 50, 0); ct = CATransform3DRotate(ct, -M_PI_2, 1, 0, 0); [cube addSublayer:[self faceWithTransform:ct]]; //add cube face 5 ct = CATransform3DMakeTranslation(-50, 0, 0); ct = CATransform3DRotate(ct, -M_PI_2, 0, 1, 0); [cube addSublayer:[self faceWithTransform:ct]]; //add cube face 6 ct = CATransform3DMakeTranslation(0, 0, -50); ct = CATransform3DRotate(ct, M_PI, 0, 1, 0); [cube addSublayer:[self faceWithTransform:ct]]; //center the cube layer within the container(将立方体层至于容器中心) CGSize containerSize = self.containerView.bounds.size; cube.position = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0); //apply the transform and return cube.transform = transform; return cube; } - (CALayer *)faceWithTransform:(CATransform3D)transform { //create cube face layer CALayer *face = [CALayer layer]; face.frame = CGRectMake(-50, -50, 100, 100); //apply a random color CGFloat red = (rand() / (double)INT_MAX); CGFloat green = (rand() / (double)INT_MAX); CGFloat blue = (rand() / (double)INT_MAX); face.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor; face.transform = transform; return face; } 5.4、CAGradientLayer CAGradientLayer 是用来生成两种或更多颜色平滑渐变的。用Core Graphics复制一个 CAGradientLayer 并将内容绘制到一个普通图层的寄宿图也是有可能的， 但是 CAGradientLayer 的真正好处在于绘制使用了硬件加速 1）基础渐变 CAGradientLayer 也有 startPoint 和 endPoint 属性，他们决定了渐变的方向。这两个参数是以单位坐标系进行的定义，所以左上角坐标是{0, 0}，右下角坐标 是{1, 1} 用例1：简单的两种颜色的对角线渐变 // gradient - (void)gradientLayerTesting { [self.view addSubview:self.containerView]; self.containerView.frame = CGRectMake(0, 200, self.view.frame.size.width, 200); CAGradientLayer *layer = [CAGradientLayer layer]; layer.frame = self.containerView.bounds; [self.containerView.layer addSublayer:layer]; layer.startPoint = CGPointMake(0, 0); layer.endPoint = CGPointMake(1, 1); layer.colors = @[(__bridge id)[UIColor redColor].CGColor,(__bridge id)[UIColor blueColor].CGColor]; } 2）多重渐变 如果愿意， colors 属性可以包含很多颜色，所以创建一个彩虹一样的多重渐变也是很简单的。默认情况下，这些颜色在空间上均匀地被渲染，但是我们可以用 locations 属性来调整空间。 locations 属性是一个浮点数值的数组 （以 NSNumber 包装）。这些浮点数定义了 colors 属性中每个不同颜色的位 置，同样的，也是以单位坐标系进行标定。0.0代表着渐变的开始，1.0代表着结 束。 locations 数组并不是强制要求的，但是如果你给它赋值了就一定要确保 locations 的数组大小和 colors 数组大小一定要相同，否则你将会得到一个空白的渐变。 用例2：现在变成了从红到黄最 后到绿色的渐变。 locations 数组指定了0.0，0.25和0.5三个数值，这样这三个渐变就有点像挤在了左上角。 // gradient2 - (void)gradientLayerTesting2 { [self.view addSubview:self.containerView]; self.containerView.frame = CGRectMake(0, 200, self.view.frame.size.width, 200); CAGradientLayer *layer = [CAGradientLayer layer]; layer.frame = self.containerView.bounds; [self.containerView.layer addSublayer:layer]; layer.startPoint = CGPointMake(0, 0); layer.endPoint = CGPointMake(1, 1); layer.locations = @[@0,@0.25,@0.5,@0.75]; layer.colors = @[(__bridge id)[UIColor redColor].CGColor,(__bridge id)[UIColor yellowColor].CGColor,(__bridge id)[UIColor blueColor].CGColor,(__bridge id)[UIColor greenColor].CGColor]; } 5.5、CAReplicatorLayer CAReplicatorLayer 的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。 1）重复图层【Repeating layers】 在屏幕的中间创建了一个小白色方块图层，然后用 CAReplicatorLayer 生成十个图层组成一个圆圈。 instanceCount 属性指定 了图层需要重复多少次。 instanceTransform 指定了一个 CATransform3D 3D 变换（这种情况下，下一图层的位移和旋转将会移动到圆圈的下一个点）。 用例1：用CAReplicatorLayer重复图层 // repeat - (void)replicatorLayerTesting { [self.view addSubview:self.containerView]; self.containerView.frame = CGRectMake(0, 200, self.view.frame.size.width, 200); CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer]; replicatorLayer.frame = self.containerView.bounds; [self.containerView.layer addSublayer:replicatorLayer]; replicatorLayer.instanceCount = 10; CATransform3D t = CATransform3DIdentity; t = CATransform3DTranslate(t, 0, 10, 0); t = CATransform3DRotate(t, M_PI/5, 0, 0, 1); // t = CATransform3DTranslate(t, 0, -1, 0); replicatorLayer.instanceTransform = t; replicatorLayer.instanceBlueOffset = -0.1; replicatorLayer.instanceGreenOffset = -0.1; CALayer *layer = [CALayer layer]; layer.frame = CGRectMake(0, 0, 50, 50); layer.backgroundColor = [UIColor whiteColor].CGColor; [replicatorLayer addSublayer:layer]; } 2）反射 使用 CAReplicatorLayer 并应用一个负比例变换于一个复制图层，就可以创建指定视图（或整个视图层次）内容的镜像图片 变换是以CAReplicatorLayer 为基准 // reflict - (void)reflictTesting { [self.view addSubview:self.containerView]; self.containerView.frame = CGRectMake(0, 200, self.view.frame.size.width, 200); CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer]; replicatorLayer.frame = self.containerView.bounds; [self.containerView.layer addSublayer:replicatorLayer]; replicatorLayer.instanceCount = 2; CATransform3D t = CATransform3DIdentity; t = CATransform3DRotate(t, M_PI, 0, 1, 0); replicatorLayer.instanceTransform = t; replicatorLayer.instanceAlphaOffset = -0.7; CALayer *layer = [CALayer layer]; layer.frame = CGRectMake(0, 0, self.view.frame.size.width/2.0, 200); layer.contents = (__bridge id)[UIImage imageNamed:@\"wal\"].CGImage; [replicatorLayer addSublayer:layer]; } 5.6、CAScrollLayer 类似UIScrollView，并不处理事件，所以需要视图响应事件在设置CAScrollLayer，核心方法属性： - (void)scrollPoint:(CGPoint)p; - (void)scrollRectToVisible:(CGRect)r; @property(readonly) CGRect visibleRect; 案例：用CAScrollLayer实现滑动视图 #import \"ScrollView.h\" #import @implementation ScrollView + (Class)layerClass { return [CAScrollLayer class]; } - (void)setUp { //enable clipping self.layer.masksToBounds = YES; //attach pan gesture recognizer UIPanGestureRecognizer *recognizer = nil; recognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)]; [self addGestureRecognizer:recognizer]; } - (id)initWithFrame:(CGRect)frame { //this is called when view is created in code if ((self = [super initWithFrame:frame])) { [self setUp]; } return self; } - (void)awakeFromNib { //this is called when view is created from a nib [self setUp]; } - (void)pan:(UIPanGestureRecognizer *)recognizer { //get the offset by subtracting the pan gesture //translation from the current bounds origin CGPoint offset = self.bounds.origin; offset.x -= [recognizer translationInView:self].x; offset.y -= [recognizer translationInView:self].y; //scroll the layer [(CAScrollLayer *)self.layer scrollToPoint:offset]; //reset the pan gesture translation [recognizer setTranslation:CGPointZero inView:self]; } @end 5.7、CATiledLayer CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。 CATiledLayer很好地和UIScrollView集成在一起。除了设置图层和滑动视图边界以适配整个图片大小，我们真正要做的就是实现-drawLayer:inContext:方法，当需要载入新的小图时，CATiledLayer就会调用到这个方法。 案例：加载分解后的多个小图，一个简单的滚动CATiledLayer实现 #import \"ViewController.h\" #import @interface ViewController () @property (nonatomic, weak) IBOutlet UIScrollView *scrollView; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; //add the tiled layer CATiledLayer *tileLayer = [CATiledLayer layer];￼ tileLayer.frame = CGRectMake(0, 0, 2048, 2048); tileLayer.delegate = self; [self.scrollView.layer addSublayer:tileLayer]; //configure the scroll view self.scrollView.contentSize = tileLayer.frame.size; //draw layer [tileLayer setNeedsDisplay]; } - (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx { //determine tile coordinate CGRect bounds = CGContextGetClipBoundingBox(ctx); NSInteger x = floor(bounds.origin.x / layer.tileSize.width); NSInteger y = floor(bounds.origin.y / layer.tileSize.height); //load tile image NSString *imageName = [NSString stringWithFormat: @\"Snowman_%02i_%02i\", x, y]; NSString *imagePath = [[NSBundle mainBundle] pathForResource:imageName ofType:@\"jpg\"]; UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath]; //draw tile UIGraphicsPushContext(ctx); [tileImage drawInRect:bounds]; UIGraphicsPopContext(); } @end 当你滑动这个图片，你会发现当CATiledLayer载入小图的时候，他们会淡入到界面中。这是CATiledLayer的默认行为。（你可能已经在iOS 6之前的苹果地图程序中见过这个效果）你可以用fadeDuration属性改变淡入时长或直接禁用掉。CATiledLayer（不同于大部分的UIKit和Core Animation方法）支持多线程绘制，-drawLayer:inContext:方法可以在多个线程中同时地并发调用，所以请小心谨慎地确保你在这个方法中实现的绘制代码是线程安全的。 注意：tileLayer.contentsScale = [UIScreen mainScreen].scale; tileSize是以像素为单位，而不是点 5.8、CAEmitterLayer 在iOS 5中，苹果引入了一个新的 CALayer子类叫 做 CAEmitterLayer 。 CAEmitterLayer 是一个高性能的粒子引擎，被用来创建 实时例子动画如：烟雾，火，雨等等这些效果。 清单6.13 用CAEmitterLayer创建爆炸效果 #import \"ViewController.h\" #import @interface ViewController () @property (nonatomic, weak) IBOutlet UIView *containerView; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; ￼ //create particle emitter layer CAEmitterLayer *emitter = [CAEmitterLayer layer]; emitter.frame = self.containerView.bounds; [self.containerView.layer addSublayer:emitter]; //configure emitter emitter.renderMode = kCAEmitterLayerAdditive; emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0); //create a particle template CAEmitterCell *cell = [[CAEmitterCell alloc] init]; cell.contents = (__bridge id)[UIImage imageNamed:@\"Spark.png\"].CGImage; cell.birthRate = 150; cell.lifetime = 5.0; cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor; cell.alphaSpeed = -0.4; cell.velocity = 50; cell.velocityRange = 50; cell.emissionRange = M_PI * 2.0; //add particle template to emitter emitter.emitterCells = @[cell]; } @end CAEMitterCell的属性基本上可以分为三种： 这种粒子的某一属性的初始值。比如，color属性指定了一个可以混合图片内容颜色的混合色。在示例中，我们将它设置为桔色。 例子某一属性的变化范围。比如emissionRange属性的值是2π，这意味着例子可以从360度任意位置反射出来。如果指定一个小一些的值，就可以创造出一个圆锥形 指定值在时间线上的变化。比如，在示例中，我们将alphaSpeed设置为-0.4，就是说例子的透明度每过一秒就是减少0.4，这样就有发射出去之后逐渐小时的效果。 CAEmitterLayer的属性它自己控制着整个例子系统的位置和形状。一些属性比如birthRate，lifetime和celocity，这些属性在CAEmitterCell中也有。这些属性会以相乘的方式作用在一起，这样你就可以用一个值来加速或者扩大整个例子系统。其他值得提到的属性有以下这些： preservesDepth，是否将3D例子系统平面化到一个图层（默认值）或者可以在3D空间中混合其他的图层 renderMode，控制着在视觉上粒子图片是如何混合的。 5.9、CAEAGLLayer 5.10、AVPlayerLayer AVPlayerLayer是有别的框架（AVFoundation）提供的，它和Core Animation紧密地结合在一起，提供了一个CALayer子类来显示自定义的内容类型。 AVPlayerLayer是用来在iOS上播放视频的。他是高级接口例如MPMoivePlayer的底层实现，提供了显示视频的底层控制。AVPlayerLayer的使用相当简单：你可以用+playerLayerWithPlayer:方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用player属性绑定一个AVPlayer实例。 AVPlayerLayer是CALayer的子类，它继承了父类的所有特性。我们并不会受限于要在一个矩形中播放视频；清单6.16演示了在3D，圆角，有色边框，蒙板，阴影等效果 // avplayerLayer - (void)avplayerLayerTesting { [self.view addSubview:self.containerView]; self.containerView.frame = CGRectMake(0, 200, self.view.frame.size.width, 200); NSURL *url = [[NSBundle mainBundle] URLForResource:@\"test\" withExtension:@\"mp4\"]; AVPlayer *player = [AVPlayer playerWithURL:url]; AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player]; playerLayer.frame = self.containerView.bounds; CATransform3D t = CATransform3DIdentity; t = CATransform3DMakeRotation(M_PI_4, 1, 1, 1); t.m34 = -1.0/500; playerLayer.transform = t; [self.containerView.layer addSublayer:playerLayer]; [player play]; } 六、隐式动画 6.1、事务 在做动画时，会发现动画会被平滑的完成，而不是跳变，其实这就是隐式动画。是因为并没有指定任何动画的类型。我们仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画。 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { [CATransaction begin]; [CATransaction setAnimationDuration:1]; CGFloat red = arc4random() / (CGFloat)INT_MAX; CGFloat green = arc4random() / (CGFloat)INT_MAX; CGFloat blue = arc4random() / (CGFloat)INT_MAX; self.testLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor; [CATransaction commit]; } - (void)transactionTesting { [self.view addSubview:self.containerView]; self.containerView.frame = CGRectMake(0, 200, self.view.frame.size.width, 200); self.testLayer = [CALayer layer]; self.testLayer.frame = self.containerView.bounds; [self.containerView.layer addSublayer:self.testLayer]; self.testLayer.backgroundColor = [UIColor redColor].CGColor; } UIView有两个方法，+beginAnimations:context:和+commitAnimations，和CATransaction的+begin和+commit方法类似。实际上在+beginAnimations:context:和+commitAnimations之间所有视图或者图层属性的改变而做的动画都是由于设置了CATransaction的原因。 [CATransaction setCompletionBlock:^{ NSLog(@\"事务完成\"); }]; 本地事务未完成下次事务又来的时候，本地事务会立即结束。 图层默认会有隐式动画，0.25s 6.2、图层行为 对于直接添加到UIView上的layer，会发现隐式动画立即完成。 Core Animation通常对CALayer的所有属性（可动画的属性）做动画，但是UIView把它关联的图层的这个特性关闭了。 我们把改变属性时CALayer自动应用的动画称作行为，当CALayer的属性被修改时候，它会调用-actionForKey:方法，传递属性的名称。剩下的操作都在CALayer的头文件中有详细的说明，实质上是如下几步： 图层首先检测它是否有委托，并且是否实现CALayerDelegate协议指定的-actionForLayer:forKey方法。如果有，直接调用并返回结果。 如果没有委托，或者委托没有实现-actionForLayer:forKey方法，图层接着检查包含属性名称对应行为映射的actions字典。 如果actions字典没有包含对应的属性，那么图层接着在它的style字典接着搜索属性名。 最后，如果在style里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的-defaultActionForKey:方法。 所以一轮完整的搜索结束之后，-actionForKey:要么返回空（这种情况下将不会有动画发生），要么是CAAction协议对应的对象，最后CALayer拿这个结果去对先前和当前的值做动画。 于是这就解释了UIKit是如何禁用隐式动画的：每个UIView对它关联的图层都扮演了一个委托，并且提供了-actionForLayer:forKey的实现方法。当不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动画block范围之内，它就返回了一个非空值。 当然返回nil并不是禁用隐式动画唯一的办法，CATransacition有个方法叫做+setDisableActions:，可以用来对所有属性打开或者关闭隐式动画。如果在清单7.2的[CATransaction begin]之后添加下面的代码，同样也会阻止动画的发生： [CATransaction setDisableActions:YES]; 总结一下，我们知道了如下几点 UIView关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用UIView的动画函数（而不是依赖CATransaction），或者继承UIView，并覆盖-actionForLayer:forKey:方法，或者直接创建一个显式动画。 对于单独存在的图层，我们可以通过实现图层的-actionForLayer:forKey:委托方法，或者提供一个actions字典来控制隐式动画。 案例：使用推进过渡的色值动画 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { CGFloat red = arc4random() / (CGFloat)INT_MAX; CGFloat green = arc4random() / (CGFloat)INT_MAX; CGFloat blue = arc4random() / (CGFloat)INT_MAX; self.testLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor; } - (void)transactionTesting { self.testLayer = [CALayer layer]; self.testLayer.frame = CGRectMake(200, 200, 200, 200); [self.view.layer addSublayer:self.testLayer]; self.testLayer.backgroundColor = [UIColor redColor].CGColor; CATransition *transition = [CATransition animation]; transition.type = kCATransitionPush; transition.subtype = kCATransitionFromLeft; self.testLayer.actions = @{@\"backgroundColor\":transition}; } 6.3、呈现与模型 CALayer 的属性行为其实很不正常，因为改变一个图层的属性并没有立刻生效，而是通过一段时间渐变更新。这是怎么做到的呢？ 当你改变一个图层的属性，属性值的确是立刻更新的（如果你读取它的数据，你会发现它的值在你设置它的那一刻就已经生效了），但是屏幕上并没有马上发生改 变。这是因为你设置的属性并没有直接调整图层的外观，相反，他只是定义了图层动画结束之后将要变化的外观。 当设置 CALayer 的属性，实际上是在定义当前事务结束之后图层如何显示的模 型。Core Animation扮演了一个控制器的角色，并且负责根据图层行为和事务设置去不断更新视图的这些属性在屏幕上的状态。 每个图层属性的显示值都被存储在一个叫做呈现图层的独立图层当中，他可以通 过 -presentationLayer 方法来访问。这个呈现图层实际上是模型图层的复制， **但是它的属性值代表了在任何指定时刻当前外观效果。在呈现图层上调用 – modelLayer 将会返回它正在呈现所依赖的 CALayer 。 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { CGPoint point = [[touches anyObject] locationInView:self.view]; if ([self.testLayer.presentationLayer hitTest:point]) { CGFloat red = arc4random() / (CGFloat)INT_MAX; CGFloat green = arc4random() / (CGFloat)INT_MAX; CGFloat blue = arc4random() / (CGFloat)INT_MAX; self.testLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor; } else { [CATransaction begin]; [CATransaction setAnimationDuration:4.0]; self.testLayer.position = point; [CATransaction commit]; } } - (void)presentationTesting { self.testLayer = [CALayer layer]; self.testLayer.frame = CGRectMake(0, 0, 100, 100); self.testLayer.position = self.view.center; self.testLayer.backgroundColor = [UIColor redColor].CGColor; [self.view.layer addSublayer:self.testLayer]; } 七、显示动画 隐式动画是在iOS平台创建动态用户界面的一种直 接方式，也是UIKit动画机制的基础，不过它并不能涵盖所有的动画类型。接下来将要研究一下显式动画，它能够对一些属性做指定的自定义动画，或者创建非线性动画，比如沿着任意一条曲线移动。 7.1、属性动画 7.1.1、CABaseAnimation 使用CABaseAnimation可以实现视图的移动、旋转动画、缩小动画等 - (void)animationTesting { self.testLayer = [CALayer layer]; self.testLayer.frame = CGRectMake(0, 0, 100, 100); self.testLayer.position = self.view.center; self.testLayer.backgroundColor = [UIColor redColor].CGColor; [self.view.layer addSublayer:self.testLayer]; CABasicAnimation *animtion = [CABasicAnimation animationWithKeyPath:@\"transform.rotation.z\"]; animtion.toValue = @(M_PI_2); animtion.duration = 4; animtion.cumulative = YES; animtion.repeatCount = INFINITY; animtion.autoreverses = YES; [self.testLayer addAnimation:animtion forKey:@\"rotation\"]; } 7.1.2、关键帧动画CAKeyframeAnimation CAKeyframeAnimation 是另一种UIKit没有暴露出来但功能强大的类。 和 CABasicAnimation 类似， CAKeyframeAnimation 同样 是 CAPropertyAnimation 的一个子类，它依然作用于单一的一个属性，但是 和 CABasicAnimation不一样的是，它不限制于设置一个起始和结束的值，而是可以根据一连串随意的值来做动画。 CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@\"backgroundColor\"]; animation.duration = 2.0; animation.values = @[ (__bridge id)[UIColor blueColor].CGColor, (__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor greenColor].CGColor, (__bridge id)[UIColor blueColor].CGColor ]; animation.repeatCount = INFINITY; [self.testLayer addAnimation:animation forKey:nil]; 案例： 沿着一个贝塞尔曲线对图层做动画 // 关键帧动画2 [self.view addSubview:self.containerView]; self.containerView.frame = CGRectMake(0, 200, self.view.frame.size.width, 500); self.containerView.backgroundColor = [UIColor lightGrayColor]; UIBezierPath *bezierPath = [[UIBezierPath alloc] init]; [bezierPath moveToPoint:CGPointMake(0, 150)]; [bezierPath addCurveToPoint:CGPointMake(self.view.frame.size.width, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)]; CAShapeLayer *pathLayer = [CAShapeLayer layer]; pathLayer.path = bezierPath.CGPath; pathLayer.fillColor = [UIColor clearColor].CGColor; pathLayer.strokeColor = [UIColor redColor].CGColor; pathLayer.lineWidth = 3.0f; [self.containerView.layer addSublayer:pathLayer]; CALayer *airLayer = [CALayer layer]; airLayer.frame = CGRectMake(0, 0, 64, 64); airLayer.position = CGPointMake(0, 150); airLayer.contents = (__bridge id)[UIImage imageNamed:@\"Airplane\"].CGImage; [self.containerView.layer addSublayer:airLayer]; CAKeyframeAnimation *animation = [CAKeyframeAnimation animation]; animation.keyPath = @\"position\"; animation.duration = 4.0f; animation.path = bezierPath.CGPath; // 根据path切线自动旋转 animation.rotationMode = kCAAnimationRotateAuto; animation.repeatCount = INFINITY; [airLayer addAnimation:animation forKey:nil]; 7.2、动画组CAAnimationGroup CABasicAnimation 和 CAKeyframeAnimation 仅仅作用于单独的属性， 而 CAAnimationGroup 可以把这些动画组合在一起。 CAAnimationGroup 是另一个继承于CAAnimation 的子类，它添加了一个 animations 数组的属性，用来组合别的动画。 // 动画组 CABasicAnimation *baseAnimation = [CABasicAnimation animation]; baseAnimation.keyPath = @\"backgroundColor\"; baseAnimation.toValue = (__bridge id)[UIColor redColor].CGColor; CAAnimationGroup *group = [CAAnimationGroup animation]; group.animations = @[animation,baseAnimation]; group.duration = 4.0f; group.repeatCount = INFINITY; [airLayer addAnimation:group forKey:nil]; 7.3、过渡动画 为了创建一个过渡动画，我们将使用 CATransition ，同样是另一 个CAAnimation 的子类，和别的子类不同， CATransition有一 个type 和 subtype 来标识变换效果。 过渡并不像属性动画那样平滑地在两个值之间做动画，而是影响到整个图层的变化。过渡动画首先展示之前的图层外观，然后通过一个交换过渡到新的外观。 //set up crossfade transition CATransition *transition = [CATransition animation]; transition.type = kCATransitionFade; //apply transition to imageview backing layer [self.imageView.layer addAnimation:transition forKey:nil]; //cycle to next image UIImage *currentImage = self.imageView.image; NSUInteger index = [self.images indexOfObject:currentImage]; index = (index + 1) % [self.images count]; self.imageView.image = self.images[index]; 你可以从代码中看出，过渡动画和之前的属性动画或者动画组添加到图层上的方式一致，都是通过-addAnimation:forKey:方法。但是和属性动画不同的是，对指定的图层一次只能使用一次CATransition，因此，无论你对动画的键设置什么值，过渡动画都会对它的键设置成“transition”，也就是常量kCATransition。 7.3.1、隐式过渡 CATransision可以对图层任何变化平滑过渡的事实使得它成为那些不好做动画的属性图层行为的理想候选。苹果当然意识到了这点，并且当设置了CALayer的content属性的时候，CATransition的确是默认的行为。但是对于视图关联的图层，或者是其他隐式动画的行为，这个特性依然是被禁用的，但是对于你自己创建的图层，这意味着对图层contents图片做的改动都会自动附上淡入淡出的动画。 7.3.2、对图层树的动画 CATransition并不作用于指定的图层属性，这就是说你可以在即使不能准确得知改变了什么的情况下对图层做动画，例如，在不知道UITableView哪一行被添加或者删除的情况下，直接就可以平滑地刷新它，或者在不知道UIViewController内部的视图层级的情况下对两个不同的实例做过渡动画。 只需要将动画添加到被影响图层的superlayer。 案例 对UITabBarController做动画 #import \"AppDelegate.h\" #import \"FirstViewController.h\" #import \"SecondViewController.h\" #import @implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { self.window = [[UIWindow alloc] initWithFrame: [[UIScreen mainScreen] bounds]]; UIViewController *viewController1 = [[FirstViewController alloc] init]; UIViewController *viewController2 = [[SecondViewController alloc] init]; self.tabBarController = [[UITabBarController alloc] init]; self.tabBarController.viewControllers = @[viewController1, viewController2]; self.tabBarController.delegate = self; self.window.rootViewController = self.tabBarController; [self.window makeKeyAndVisible]; return YES; } - (void)tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController { ￼//set up crossfade transition CATransition *transition = [CATransition animation]; transition.type = kCATransitionFade; //apply transition to tab bar controller's view [self.tabBarController.view.layer addAnimation:transition forKey:nil]; } @end 7.3.3 自定义动画 过渡动画做基础的原则就是对原始的图层外观截图，然后添加一段动画，平滑过渡到图层改变之后那个截图的效果。如果我们知道如何对图层截图，我们就可以使用属性动画来代替CATransition或者是UIKit的过渡方法来实现动画。 事实证明，对图层做截图还是很简单的。CALayer有一个-renderInContext:方法，可以通过把它绘制到Core Graphics的上下文中捕获当前内容的图片，然后在另外的视图中显示出来。如果我们把这个截屏视图置于原始视图之上，就可以遮住真实视图的所有变化，于是重新创建了一个简单的过渡效果。 案例 用renderInContext:创建自定义过渡效果 @implementation ViewController - (IBAction)performTransition { //preserve the current view snapshot UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, YES, 0.0); [self.view.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *coverImage = UIGraphicsGetImageFromCurrentImageContext(); //insert snapshot view in front of this one UIView *coverView = [[UIImageView alloc] initWithImage:coverImage]; coverView.frame = self.view.bounds; [self.view addSubview:coverView]; //update the view (we'll simply randomize the layer background color) CGFloat red = arc4random() / (CGFloat)INT_MAX; CGFloat green = arc4random() / (CGFloat)INT_MAX; CGFloat blue = arc4random() / (CGFloat)INT_MAX; self.view.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0]; //perform animation (anything you like) [UIView animateWithDuration:1.0 animations:^{ //scale, rotate and fade the view CGAffineTransform transform = CGAffineTransformMakeScale(0.01, 0.01); transform = CGAffineTransformRotate(transform, M_PI_2); coverView.transform = transform; coverView.alpha = 0.0; } completion:^(BOOL finished) { //remove the cover view now we're finished with it [coverView removeFromSuperview]; }]; } @end 7.4、取消动画 为了终止一个指定的动画，你可以用如下方法把它从图层移除掉： - (void)removeAnimationForKey:(NSString *)key; 或者移除所有动画： - (void)removeAllAnimations; 动画一旦被移除，图层的外观就立刻更新到当前的模型图层的值。一般说来，动画在结束之后被自动移除，除非设置removedOnCompletion为NO，如果你设置动画在结束之后不被自动移除，那么当它不需要的时候你要手动移除它；否则它会一直存在于内存中，直到图层被销毁。 参考文献 Core Animation动画 如何使用shouldRasterize属性进行性能调优 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-04-20 18:09:53 "},"articles/iOS/network/tcpip.html":{"url":"articles/iOS/network/tcpip.html","title":"图解TCP/IP","keywords":"","body":"图解TCP/IP 一、网络基础知识 本模块主要深入了解TCP/IP所必备的基础知识：OSI参考模型、网络概念的本质等。 1.1 OSI参考模型 应用层 为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录（虚拟 终端）等协议。 表示层 将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。 因此它主要负责数据格式的转换。 具体来说，就是将设备固有的数据格式转换为网络标准传输格式。不同设备对同一比特流解释的结果 可能会不同。因此，使它们保持一致是这一层的主要作用。 会话层 负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。 传输层 起着可靠传输的作用。只在通信双方节点上进行处理，而无需在路由器上处理。 网络层 将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主 要负责寻址和路由选择。 数据链路层 负责物理层面上互连的、节点之间的通信传输。 例如与1个以太网相连的2个节点之间的通信。 将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）。 物理层 负责0、1比特流（0、1序列）与电压的高低、光的闪灭之间的互换。 1.2 传输方式的分类 1.2.1 面向有连接型与面向无连接型 通过网络发送数据，大致可以分为面向有连接与面向无连接两种类型（面向无连接型包括以太网、 IP、UDP等协议。面向有连接型包括ATM、帧中继、TCP等协议。） 面向有连接型 面向有连接型中，在发送数据之前，需要在收发主机之间连接一条通信线路 （在不同的分层协议中，连接的具体含义可能有所不同。在数据链路层中的连接，就是指物理的、通信线 路的连接。而传输层则负责创建与管理逻辑上的连接。） 面向无连接型 因此，在面向无连接的通信中，不需要确认对端是否存在。即使接收端不存在或无法接收数据，发送 端也能将数据发送出去。 面向无连接型则不要求建立和断开连接。发送端可于任何时候自由发送数据，反之，接收端也永远不知道自己会在何时从哪里收到数据。因此，在面向无连接的情况下，接收端需要时常确认是否收到了数据。 1.2.2 电路交换和分组交换 目前，网络通信方式大致分为两种——电路交换和分组交换。 电路交换 在电路交换中，交换机主要负责数据的中转处理。计算机首先被连接到交换机上，而交换机与交换机之间则由众多通信线路再继续连接。因此计算机之间在发送数据时，需要通过交换机与目标主机建立通信电路。我们将连接电路称为建立连接。建立好连接以后，用户就可以一直使用这条电路，直到该连接被断开为止。 分组交换 让连接到通信电路的计算机将所要发送的数据分成多个数据包， 按照一定的顺序排列之后分别发送。这就是分组交换。有了分组交换，数据被细分后，所有的计算机就可以一齐收发数据，这样也就提高了通信线路的利用率。由于在分组的过程中，已经在每个分组的首部写入 了发送端和接收端的地址，所以即使同一条线路同时为多个用户提供服务，也可以明确区分每个分组数据 发往的目的地，以及它是与哪台计算机进行的通信。 在分组交换中，由分组交换机（路由器）连接通信线路。分组交换的大致处理过程是：发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，缓存到自己的缓冲区，然后再转发给目标计算机。 1.3.3 接收端数量分量 网络通信当中，也可以根据目标地址的个数及其后续的行为对通信进行分类。如广播、多播等就是这种分类的产物。 单播 组合起来就是指1对1通信。早先的固定电话就是单播通信的一个典型例子。 广播 它指是将消息从1台主机发送给与之相连的所有其他主机。将电视信号一起发送给非特定 的多个接收对象。 多播 多播与广播类似，也是将消息发给多个接收主机。不同之处在于多播要限定某一组主机作为接收端。多播通信最典型的例子就是电视会议，这是由多组人在不同的地方参加的一种远程会议。在这种形式下，会由一台主机发送消息给特定的多台主机。电视会议通常不能使用广播方式。否则将无从掌握是谁在哪儿参与电视会议。 任播 任播是指在特定的多台主机中选出一台作为接收端的一种通信方式。虽然，这种方式与多播有相似之处，都是面向特定的一群主机，但是它的行为却与多播不同。任播通信从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息。通常，所被选中的那台特定主机将返回一个单播信号，随后发送端主机会只跟这台主机进行通信。 ？是否类似需要负载均衡 二、TCP/IP基础知识 2.1 TCP/IP的具体含义 协议族，泛指整个网络通信协议，不单指某一个协议 2.2 TCP/IP与OSI参考模型 2.2.1 硬件【物理层】 TCP/IP的最底层是负责数据传输的硬件。这种硬件就相当于以太网或电话线路等物理层的设备。关于它的内容一直无法统一定义。因为只要人们在物理层面上所使用的传输媒介不同（如使用网线或无线）， 网络的带宽、可靠性、安全性、延迟等都会有所不同，而在这些方面又没有一个既定的指标。总之， TCP/IP是在网络互连的设备之间能够通信的前提下才被提出的协议。 2.2.2 网络接口层【数据链路层】 网络接口层（有时人们也将网络接口层与硬件层合并起来称作网络通信层。） 利用以太网中的数据链路层进行通信，因此属于接口层。也就是说，把它当做让NIC起作用的“驱动程序”也无妨。 驱动程序是在操作系统与硬件之间起桥梁作用的软件。计算机的外围附加设备或扩展卡，不是直接插到电脑上或电脑的扩展槽上就能马上使用的，还需要有相应驱动程序的支持。例如换了一个新的NIC网卡，不仅需要硬件，还需要软件才能真正投入使用。因此，人们常常还需要在操作系统的基础上安装一些驱动软件以便使用这些附加硬件 2.2.3 互联网层【网络层】 互联网层使用IP协议，它相当于OSI模型中的第3层网络层。IP协议基于IP地址转发分包数据。 TCP/IP分层中的互联网层与传输层的功能通常由操作系统提供。尤其是路由器，它必须得实现通过互 联网层转发分组数据包的功能。 IP IP是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到地球的另一 端，这期间它使用IP地址作为主机的标识【连接IP网络的所有设备必须有自己唯一的识别号以便识别具体 的设备。分组数据在IP地址的基础上被发送到对端。】 IP还隐含着数据链路层的功能。通过IP，相互通信的主机之间不论经过怎样的底层数据链路都能够实现通信。 虽然IP也是分组交换的一种协议，但是它不具有重发机制。即使分组数据包未能到达对端主机也不会重发。因此，属于非可靠性传输协议。 ICMP IP数据包在发送途中一旦发生异常导致无法到达对端目标地址时，需要给发送端发送一个发生异常的通知。ICMP就是为这一功能而制定的。它有时也被用来诊断网络的健康状况。 ARP 从分组数据包的IP地址中解析出物理地址（MAC地址）的一种协议。 2.2.4 传输层 TCP/IP的传输层有两个具有代表性的协议。该层的功能本身与OSI参考模型中的传输层类似。 传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同一时间运行着多个程序。为此，必须分清是哪些程序与哪些程序在进行通信。识别这些应用程序的是端口号。 TCP TCP是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP还能够有效利用带宽，缓解网络拥堵。然而，为了建立与断开连接，有时它需要至少7次的发包收包，导致网络流量的浪费。此外，为了提高网络的利用率，TCP协议中定义了各种各样复杂的规范，因此不利于视频会议（音频、视频的数据量既定）等场合使用。 UDP UDP有别于TCP，它是一种面向无连接的传输层协议。UDP不会关注对端是否真的收到了传送过去的 数据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。 UDP常用于分组数据较少或多播、广播通信以及视频通信等多媒体领域。 2..2.5 应用层【会话层以上的分层】 TCP/IP的分层中，将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。这 些功能有时由一个单一的程序实现，有时也可能会由多个程序实现。因此，细看TCP/IP的应用程序功能会 发现，它不仅实现OSI模型中应用层的内容，还要实现会话层与表示层的功能。 TCP/IP应用的架构绝大多数属于客户端/服务端模型。提供服务的程序叫服务端，接受服务的程序叫客 户端。在这种通信模式中，提供服务的程序会预先被部署到主机上，等待接收任何时刻客户可能发送的请求。 参考文献 网络另一篇干货《图解TCP/IP》-封顶大吉【值得收藏】 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-04-21 13:45:41 "},"articles/iOS/ci/jenkins.html":{"url":"articles/iOS/ci/jenkins.html","title":"Jenkins","keywords":"","body":"Jenkins 参考资料 手把手教你利用 Jenkins 持续集成 iOS 项目 fastlane官网 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-28 14:22:13 "},"articles/iOS/underlying/":{"url":"articles/iOS/underlying/","title":"iOS底层原理","keywords":"","body":"iOS底层原理 常用命令 # 打印二进制的值 p/t 0x100010 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-06-12 19:18:55 "},"articles/iOS/underlying/pre_runtime.html":{"url":"articles/iOS/underlying/pre_runtime.html","title":"前奏_Runtime","keywords":"","body":"Runtime OC运行时，C、C++、汇编编写 objc_msgSendSuper 给父类发消息，其中objc_super结构体中，receiver还是self /// Specifies the superclass of an instance. struct objc_super { /// Specifies an instance of a class. __unsafe_unretained _Nonnull id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) && !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained _Nonnull Class class; #else __unsafe_unretained _Nonnull Class super_class; #endif /* super_class is the first class to search */ }; #endif Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-06-12 20:09:25 "},"articles/iOS/underlying/01_object.html":{"url":"articles/iOS/underlying/01_object.html","title":"01_OC对象","keywords":"","body":"OC对象原理 对象的alloc流程 alloc开辟了内存 虽然在NSObject的alloc方法中打了断点，但是并未进入，进入的是： id objc_alloc(Class cls) { return callAlloc(cls, true/*checkNil*/, false/*allocWithZone*/); } 原因：由于llvm对OC对象的处理，OC类在调用alloc方法时，会先调用objc_alloc函数，后续在callAlloc中调用alloc方法 ... case OMF_alloc: if (isClassMessage && Runtime.shouldUseRuntimeFunctionsForAlloc() && ResultType->isObjCObjectPointerType()) { // [Foo alloc] -> objc_alloc(Foo) or // [self alloc] -> objc_alloc(self) if (Sel.isUnarySelector() && Sel.getNameForSlot(0) == \"alloc\") return CGF.EmitObjCAlloc(Receiver, CGF.ConvertType(ResultType)); ... /// Allocate the given objc object. /// call i8* \\@objc_alloc(i8* %value) llvm::Value *CodeGenFunction::EmitObjCAlloc(llvm::Value *value, llvm::Type *resultType) { return emitObjCValueOperation(*this, value, resultType, CGM.getObjCEntrypoints().objc_alloc, \"objc_alloc\"); } static ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false) { #if __OBJC2__ if (slowpath(checkNil && !cls)) return nil; if (fastpath(!cls->ISA()->hasCustomAWZ())) { return _objc_rootAllocWithZone(cls, nil); } #endif // No shortcuts available. if (allocWithZone) { return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil); } return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc)); } alloc核心方法 instanceSize 计算需要开辟的内存空间 源码可以看出，至少16字节 inline size_t instanceSize(size_t extraBytes) const { if (fastpath(cache.hasFastInstanceSize(extraBytes))) { return cache.fastInstanceSize(extraBytes); } size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16 bytes. if (size ro()->instanceSize; return size; } // 8字节对齐 8的倍数 // 64位系统中，是7，算法表示按8对齐，为8的倍数 // # define WORD_MASK 7UL static inline uint32_t word_align(uint32_t x) { return (x + WORD_MASK) & ~WORD_MASK; } calloc 开辟内存，返回指针 obj = (id)calloc(1, size); initInstanceIsa 地址空间关联到相应的类 obj->initInstanceIsa(cls, hasCxxDtor); 最终调用了 initIsa(cls, true, hasCxxDtor); 结构体内存对齐 对象声明的实例变量是按照结构体的内存对齐方式进行 对象的属性，底层会进行重排优化，进行合并成一个字节进行存储 结构体内存对齐原则： 结构体或联合体的数据成员，第一个数据成员放在offset为0的位置，后续每个成员存储的起始位置要从该成员大小的整数倍开始。如果该成员有子成员，按最大子成员的大小整数倍开始 包含子成员的数据占用大小是最大子成员大小的整数倍 结构体总大小是内部最大成员整数倍 对象的大小 sizeof 类型大小 class_getInstanceSize 对象最终占用空间大小，包含结构体对齐。 看源码是8字节对齐。 通过malloc_size开了一一个大小，但是其中最终使用的大小 比如[NSObject alloc]是8 malloc_size 实际分配的大小 看源码是因为16字节对齐，比如[NSObject alloc]是16 libmalloc calloc是一个函数声明，在实际运行中，会进行赋值 void *(* MALLOC_ZONE_FN_PTR(calloc))(struct _malloc_zone_t *zone, size_t num_items, size_t size); /* same as malloc, but block returned is set to zero */ // 实际调用的时候 ptr = zone->calloc(zone, num_items, size); 在Xcode进行打印，找到赋值的最终调用位置 (lldb) p zone->calloc (void *(*)(_malloc_zone_t *, size_t, size_t)) $0 = 0x00000001002f4ca5 (.dylib`default_zone_calloc at malloc.c:385) (lldb) p zone->calloc (void *(*)(_malloc_zone_t *, size_t, size_t)) $1 = 0x00000001002fa3d1 (.dylib`nano_calloc at nano_malloc.c:878) 最终调用 static void * nano_calloc(nanozone_t *nanozone, size_t num_items, size_t size) { size_t total_bytes; if (calloc_get_size(num_items, size, 0, &total_bytes)) { return NULL; } if (total_bytes helper_zone); return zone->calloc(zone, 1, total_bytes); } _nano_malloc_check_clear函数中的核心代码： // 分配大小来自 size_t slot_bytes = segregated_size_to_fit(nanozone, size, &slot_key); // Note slot_key is set here #define NANO_REGIME_QUANTA_SIZE (1 > SHIFT_NANO_QUANTUM; // round up and shift for number of quanta // 右移4位 slot_bytes = k clang clang -rewrite-objc main.m -o main.cpp # 使用xcrun更方便 xcrun在clang的基础上进行了一些封装 # 模拟器 $ xcrun -sdk iphonesimulator clang -arch x86_64 -rewrite-objc main.m -o main-x64.cpp # 手机 $ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp 结构体位域 struct Direction { BOOL front : 1; BOOL back : 1; BOOL left : 1; BOOL right : 1; }; 联合体配合位域 #import \"LGCar.h\" #define LGDirectionFrontMask (1 nonPointerIsa 使用指针存储更多东西 isa联合体 union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } uintptr_t bits; private: // Accessing the class requires custom ptrauth operations, so // force clients to go through setClass/getClass by making this // private. Class cls; public: #if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // defined in isa.h }; bool isDeallocating() { return extra_rc == 0 && has_sidetable_rc == 0; } void setDeallocating() { extra_rc = 0; has_sidetable_rc = 0; } #endif void setClass(Class cls, objc_object *obj); Class getClass(bool authenticated); Class getDecodedClass(bool authenticated); }; x86_64中关于ISA_BITFIELD的一些宏定义 # if __x86_64__ # define ISA_MASK 0x00007ffffffffff8ULL # define ISA_MAGIC_MASK 0x001f800000000001ULL # define ISA_MAGIC_VALUE 0x001d800000000001ULL # define ISA_HAS_CXX_DTOR_BIT 1 # define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t unused : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 8 x86_64中，ISA是中间44，arm64是中间33 手动计算ISA x86_64中，先>>3，在>17 arm64中，先>>3,，再>28 遗留问题 地址空间如何关联到相应的类 _read_imags，dyld的加载流程，类的加载流程 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-06 00:01:15 "},"articles/iOS/underlying/02_class.html":{"url":"articles/iOS/underlying/02_class.html","title":"02_类","keywords":"","body":"类 isa流程 对象-isa->类-isa->元类-isa->根NSObject元类 类对象的地址在编译时就确定了，使用MachOView分析，可以直接在Section64(_DATA,_Objc_classrefs)和Section64(_DATA,_objc_classlist)中可以看到地址 在符号表中也可以看到元类的符号，都是这编译期有编译器生成 isa流程图 objc_getClass superclass流程 objc_getSuperclass iskindof、ismemberof isMemberOf 是否是相同的类，如果是类对象调用，取isa在去比较。如果是对象调用，调用[self class]，去比较 isKindOf 是否是相同或者子类，如果是类对象调用，取isa再去比较，然后再去取了isa之后的superclass一直比较到顶。如果是对象调用，调用[self class]，去比较 类对象的class返回它自己，就还是类对象自己，要获取元类需要objc_getClass(类) NSObject是所有类的父类，包含元类，所以所有对象，包含类对象的isKindOfClass：[NSObject Class]都是YES 查看汇编，并非走得是iskindof源码，而是走得objc_opt_iskindofclass。编译器搞鬼 // Calls [obj isKindOfClass] BOOL objc_opt_isKindOfClass(id obj, Class otherClass) { #if __OBJC2__ if (slowpath(!obj)) return NO; Class cls = obj->getIsa(); if (fastpath(!cls->hasCustomCore())) { for (Class tcls = cls; tcls; tcls = tcls->getSuperclass()) { if (tcls == otherClass) return YES; } return NO; } #endif return ((BOOL(*)(id, SEL, Class))objc_msgSend)(obj, @selector(isKindOfClass:), otherClass); } 类的结构 对象的结构：isa，实例变量 类似的结构：isa （8）、superclass（8）、cache（16）、bits cache类型：cache_t，类型大小16字节 bits 通过类地址平移0x20获得bits 对bits进行类型强转（class_data_bits_t *）0x0000000 调用data（）方法，0x00000->data() # 打印对象内存信息 (lldb) x/8g p 0x10122abc0: 0x011d80010000838d 0x0000000000000000 0x10122abd0: 0x0000000000000000 0x0000000000000000 0x10122abe0: 0x0000000000000009 0x00007fff30010ad8 0x10122abf0: 0x00007fff3e2db6e0 0x00007fff3ccd8c98 # 获取对象isa指针 (lldb) p/x 0x011d80010000838d & 0x00007ffffffffff8ULL (long) $2 = 0x0000000100008388 # bits相对类对象首地址偏移0x20 isa地址加20后进行bits类型强转 (lldb) p (class_data_bits_t *)0x00000001000083a8 (class_data_bits_t *) $5 = 0x00000001000083a8 # 调用bits的data()方法，获取class_rw_t * (lldb) p $5->data() (class_rw_t *) $7 = 0x0000000101234810 # 从class_rw_t中获取methods (lldb) p $7->methods() (const method_array_t) $8 = { list_array_tt = { = { list = { ptr = 0x00000001000080b8 } arrayAndFlag = 4295000248 } } } # 从methods中获取method_list_t (lldb) p $8.list.ptr (method_list_t *const) $9 = 0x00000001000080b8 (lldb) p *$9 (method_list_t) $10 = { entsize_list_tt = (entsizeAndFlags = 27, count = 13) } # 从method_list_t中获取method_t (lldb) p $10.get(0).big() #底层没有description方法，需要big方法进行打印显示 (method_t::big) $11 = { name = \"bycycle\" types = 0x0000000100003f75 \"s16@0:8\" imp = 0x0000000100003cf0 (KCObjcBuild`-[Person bycycle] at main.m:25) } # 从class_rw_t中获取properties (lldb) p $7->properties() (const property_array_t) $14 = { list_array_tt = { = { list = { ptr = 0x00000001000082c0 } arrayAndFlag = 4295000768 } } } # 从properties获取 property_list_t (lldb) p $14.list.ptr (property_list_t *const) $15 = 0x00000001000082c0 (lldb) p *$15 (property_list_t) $16 = { entsize_list_tt = (entsizeAndFlags = 16, count = 6) } # 从property_list_t中获取property_t (lldb) p $16.get(0) (property_t) $17 = (name = \"name\", attributes = \"Tc,N,V_name\") ro & rw & ext dirty_memory、clean_memory：分类加载，修改了类的内容 set原理 objc_setProperty 通过ivars，sel->imp,imp是未实现的，指向setProperty。编译时期，llvm生成 ？什么时候使用setProperty，什么时候是内存平移找到ivar后之后赋值 llvm if (IsCopy) { ​ Kind = GetSetProperty; ​ return; } setProperty底层进行copy操作 类方法存储在元类 class_getClassMethod方法，底层调用的是，获取元类的对象方法 class_getInstanceMethod(cls->getMeta(),sel); getMeta()函数，当是类的时候，返回元类，当是元类的时候返回与元类自己 底层没有所谓的类方法、对象方法，只是看在哪里获取 objc_msgSend Xcode有个build setting中，有objc_msgSend的配置，和参数一个两个有关 objc_msgSendSuper objc_super { ​ id receiver ​ Class super_class } 汇编分析： ENTRY _objc_msgSend cmp p0, #0 // 比较消息接收者是否是0，是否存在 GetClassFromIsa_p16 // p16最终就等于class，通过recieve获取isa，获取class ExtractISA // 这里就是获取最终的isa指针 上面走完后，继续往下走： CacheLookUp LLookupStart ----循环--找缓存 缓存命中 CacheHit NORMAL -> TailCallCachedImp -> call imp objc_msgSend(sel,imp) 总结： reciever是否存在 receiver->isa->class(p16) class-内存平移-cache（bucket mask） bucket掩码->bucket mask掩码->mask insert哈希函数 第一次查找的index bucket+index查找具体的bucket{imp sel} 判断sel==_cmd，相等的话CacheHit ->imp^isa = imp，调用objc_msgSend；不相等的话，--平移继续查找 如果一直没找到，即没有缓存，调用MissLabelDynamic。这个是CacheLookUp的一个参数。即__objc_msgSend_uncached->lookUpImpOrForward(C)->慢速查找-methodlist 也可以通过汇编查看msgSend流程 慢速查找流程：lookupimporforward ​ 方法查找需要用到rw和ro，所以需要保证类已经加载和初始化 ​ 二分查找、如果同名方法，找分类的。二分查找相同元素的边界问题。--。找最前面的。分类在类的前面 ​ 找到后，缓存 调用 ​ 找不到，找父类缓存，再找父类慢速查找，一直找到没有 ​ 最终没找到，imp = forward_imp ​ 顺便调用 callInitialize class initialize cache_getImp，这里有坑，查找父类的方法，缓存没找到的话，不是直接找父类的父类，先返回0，然后在方法里面判断0，继续找父类的父类 寻找imp的过程 根据sel查找imp的过程 cache 偏移16字节 bucket_t，保存sel->imp 当lldb p或者po打印不出来的时候，寻找是否有方法可以输出相关信息 发现调用了方法，但是cache中，buckets中没有缓存。因为buckets使用hash来进行存储，直接打印，相当于直接获取第一个，不一定有值 有插入、才有读取 insert(sel,imp,reciever)，插入过程有hash，冲突的话，再hash occupy 存入了多少 mask = capacity-1 bucket两倍扩容：旧的回收，新的继续放，相当于老的没有了 cache初始4、扩容为8，mask为7 当使用lldb调用方法触发缓存时，会发现cache初始就为7，因为lldb除了调用方法，还调用了一些其他对象方法，导致其它的方法也被调用，被缓存，刚好导致扩容了一次。（mask从3->7） 调用了这两个方法 // respondsToSelector // class 还少一个？ 往bucket里面插值，必须要调用b[i].set方法去插值。insert是插cache buckets最后一个存边界，所以mask = capacity-1。因为最后一个是边界，存0x1，然后cache的首地址（这里存疑） 验证不通过lldb，通过代码直接调用，会不会有边界。 哈希：开放定址 & 拉链 0.75扩容，负载因子 // 系统函数，打印imp信息 // 参见以下函数，全局搜索 inline IMP rawImp() _sel.load() _imp.load() insert流程 cache中关于imp的算法，双重异或。存编码异或一次，取解码异或一次 imp()方法，imp(bucket_t *，cls())，这里的cls(),就是用于异或的参数，如果不传，就不异或，就是原始值 cache中关于arm的内容 在arm中，cache往buckets中存值，如果存在哈希冲突，就往前存值。如果存不进去，就过掉while循环，调用bad cache arm64中，先存imp，在存sel。其他架构先存sel，在存imp 十、动态方法决议 找不到方法，赋值imp = forward_imp = __objc_msgForward_impcache 在上面返回之前，会调用： resolve为啥走两次 为啥resolveClass后还要调用resolveInstance aop 消息转发 extern void instrumentObjcMessageSends(BOOL flag) mac开发模式 调用传yes，打印输出一些消息转发的流程log hopper反汇编cf Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-02 21:36:45 "},"articles/iOS/iosre/command_iosre.html":{"url":"articles/iOS/iosre/command_iosre.html","title":"iOS逆向常用命令","keywords":"","body":"iOS逆向常用命令 security # 列出电脑上可用证书 $ security find-identity -v -p codesigning 1) 123xxxxxxxxxx456 \"Apple Development: xxx (2342xxxx)\" 2) 123xxxxxxxxxx456 \"Apple Development: xxx (2342xxxx)\" 3) 123xxxxxxxxxx456 \"Apple Development: xxx (2342xxxx)\" 4) 123xxxxxxxxxx456 \"Apple Development: xxx (2342xxxx)\" 4 valid identities found # 系统已安装描述文件路径 $ ~/Library/MobileDevice/Provisioning Profiles # 查看描述文件 $ security cms -Di xxx.mobileprovision # 从embedded.mobileprovision文件中提取出entitlements.plist权限文件。 $ security cms -D -i embedded.mobileprovision > temp.plist $ /usr/libexec/PlistBuddy -x -c 'Print :Entitlements' temp.plist > entitlements.plist codesign # 用证书签名 codesign --force --verify --verbose --sign \"找到的可用证书名称\" dumpdecrypted.dylib # 查看app签名信息 $ codesign -vv -d Payload/WeChat.app Executable=/Users/360jr/Desktop/iOSRe/tool/demo/WeChat/Payload/WeChat.app/WeChat Identifier=com.tencent.xin # 重签名 # codesign -fs \"（证书名称或者id）\" （FrameWork名称） $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" mars.framework # 强制重签名 $ codesign --force --deep --sign - ldid # 导出原有权限文件 $ ldid -e debugserver > debugserver.entitlements # 使用权限文件重签名 $ ldid -Sdebugserver.entitlements debugserver Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-14 15:25:48 "},"articles/iOS/iosre/iosre.html":{"url":"articles/iOS/iosre/iosre.html","title":"iOS逆向简介","keywords":"","body":"iOS逆向全流程 一、越狱 是获取iOS设备的Root权限的技术手段。 不完美越狱（Tethered Jailbreak），指的是，当处于此状态的iOS设备开机重启后，之前进行的越狱程序就会失效，用户将失去Root权限，需要将设备连接电脑来使用（如特定版本下的红雪（redsn0w））等越狱软件进行引导开机以后，才可再次使用越狱程序。否则设备将无法正常引导。 完美越狱（Untethered Jailbreak），指设备在进行重启后，越狱状态仍被完整保留。 半不完美越狱（Semi-tethered Jailbreak），指设备在重启后，将丢失越狱状态，并恢复成未越狱状态。如果想要恢复越狱环境，必须连接计算机并在越狱工具的引导下引导来恢复越狱状态。 半完美越狱（Semi-untethered Jailbreak），指设备在重启后，将丢失越狱状态；而若想要再恢复越狱环境，只需在设备上进行某些操作即可恢复越狱。 1.1、uncOver 使用工具unc0ver （半完美越狱）（网上也存在一些其他越狱手段，可自行查找） unc0ver官网 unc0ver源码 目前已支持iOS 11.0 - 14.3 官网有详细的操作步骤，直接参照操作即可。 uncOver越狱过程中需要观看广告，可提前翻墙观看或者多试几次。 uncOver是半完美越狱，重启手机之后需要重新越狱。 一些其他的越狱工具：checkra1n 1.2、添加Cydia源 添加Cydia源，下载常用软件 Cydia常用源 Cydia安装常用软件 OpenSSH 用于Mac远程ssh访问手机 Cycript Cycript是由Cydia创始人Saurik推出的一款脚本语言，Cycript混合了OC、JavaScript语法的解释器，这意味着我们能够在一个命令中使用OC或者JavaScript，甚至两者并用。它能够hook正在运行的进程，在运行时获取、修改很多东西。 Filza 查看手机文件系统 RevealLoader 配合Mac端的Reveal，可查看App的UI架构 Vi IMproved 文本编辑器 Apple File Conduit 可通过Mac软件（类似iFunBox）查看手机文件系统 二、ssh远程访问越狱设备 2.1、ssh通过网络连接 越狱手机安装完 OpenSSH后，即可通过ssh远程访问。 ssh默认端口为22。 默认ssh账号密码：account: root password:alpine $ ssh root@10.1.1.193 2.2、基于usbmuxd服务，通过usb实现MAC与iPhone的通信 $ brew install usbmuxd # 安装usbmuxd库之后，就顺带安装了一个小工具iproxy # iproxy 本地端口 映射端口 $ iproxy 10010 22 即可通过本地10010端口映射到远端22端口 ssh指定端口 $ ssh root@localhost -p 10010 Last login: Mon Mar 8 15:16:23 2021 from 127.0.0.1 Cchukou:~ root# scp也可通过usb进行拷贝 # -P 进行端口指定（大写P） scp -P dumpdecrypted.dylib root@localhost:/usr/lib 三、Cycript 代码调试 Cycript是由 Cydia 创始人 Saurik 推出的一款脚本语言，Cycript 混合了 OC、 JavaScript 语法的解释器，这意味着我们能够在一个命令中使用 OC 或者 JavaScript，甚至两者并用。 它能够hook正在运行的进程，在运行时执行代码，获取修改很多东西。 Cycript官网 3.1、常用语法 # + 对象地址 可以直接调用对象的方法 cy# [#0x10ec66aa0 subviews] @[#\"; layer = >\"] 查看视图层级recursiveDescription() UIWindow.keyWindow().recursiveDescription().toString() UIApp等价于[UIApplication sharedApplication] cy# UIApp #\"\" 定义变量 cy# var a = 3 3 cy# var b = 4 4 cy# a + b 7 显示已加载的所有OC类 ObjectiveC.classes 显示对象的所有成员变量 cy# *#0x111970800 {isa:NSKVONotifying_WCAccountLoginFirstViewController,_hasOverrideClient:0,_hasOverrideHost:0,_hasInputAssistantItem:0,_overrideTransitioningDelegate:null,_view:#\">\",_tabBarItem:null,_navigationItem:#\" titleView=0x1114d6500\", ... 筛选出某种类型的对象 cy# choose(UIViewController) [#\" ChildViewControllers:(\\n \\\"\\\"\\n)\",#\" ChildViewControllers:(\\n \\\"\\\"\\n)\"] 退出cy 调试模式 control+d 实际开发中，可将常用的方法封装到一个.cy文件中，然后放到/usr/lib/cycript0.9中，可以在此路径下自定义路径，并且在cycript环境中导入，即可使用 ## com.mj.mjcript 意思是cycript根路径下的com/mj/mjcript.cy文件 cy# @import com.mj.mjcript {} 四、Reveal 界面调试 Reveal 是 Mac OS X 平台上的一款方便开发者调试 iOS 应用的开发软件，Reveal 能够在运行时调试和修改 iOS 应用程序。 Reveal 能连接到应用程序，并允许开发者编辑各种用户界面参数，而且会立即反应在程序的 UI 上。 参考：Reveal 详细安装（以及安装问题解决） 五、脱壳 上传至Apple Store的应用，会被加密，无法正常查看Mach-O信息，需要脱壳 如何检查Mach-O是否已经脱壳 查看LC中的LC_ENCRyPTION_INFO中的Crypt ID，如果等于0则未加密 5.1、frida-ios-dump一键脱壳 frida-ios-dump 1）Mac安装frida $ sudo pip install frida 2） 下载frida-ios-dump 3）进入frida-ios-dump，安装依赖，可能会出现错误，可先不用管，部分库未下载下来可在后面根据提示在进行安装 sudo pip install -r requirements.txt --upgrade 4）使用iproxy映射端口 $ iproxy 10010 22 5）修改frida-ios-dump中的dump.py文件的端口配置 Port = 10010 6）手机Cydia中安装frida # 打开Cydia->软件源->编辑->添加，输入build.frida.re，添加软件源后，搜索安装Frida即可，注意Frida对应的Cpu型号 7）frida-ios-dump工程中执行dump $ ./dump.py com.tencent.xin Start the target app com.tencent.xin ..... Generating \"微信.ipa\" # 如果报错 ImportError: No module named 'xxx' # sudo pip install 'xxx' 5.2、class-dump 可以将Objective-C编写的二进制文件反编出头文件，需要是已砸壳的二进制文件。 官网 源码 MonkeyDev/class-dump：支持swift和oc混编 1）使用class-dump导出头文件 # class-dump -H Mach-O文件 -o 输出路径 $ class-dump -H brush_free.decrypted -o brush_header 六、Theos 编写tweak项目，动态Hook第三方程序 6.1、环境配置 # 安装签名工具 $ brew install ldid # 配置Theos环境变量 export THEOS=~/.theos export PATH=$THEOS/bin:$PARH # 下载Theos,及其依赖 $ git clone --recursive https://github.com/theos/theos.git $THEOS 6.2、编写tweak 新建tweak项目 $ nic.pl NIC 2.0 - New Instance Creator ------------------------------ [1.] iphone/activator_event [2.] iphone/activator_listener ... [15.] iphone/tweak ... Choose a Template (required): 15 # 新建tweak项目 Project Name (required): TweakWeChat # 项目名称 Package Name [com.yourcompany.tweakwechat]: com.liang.tweakwechat # bundle id Author/Maintainer Name [360JR]: Liang # author [iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]: com.tencent.xin # 需要动态修改的app的bundle id 【重要】 [iphone/tweak] List of applications to terminate upon installation (space-separated, '-' for none) [SpringBoard]: # 安装插件完成后需要关闭的app的bundle id，默认重启SpringBoard，直接回车即可 Instantiating iphone/tweak in tweakwechat/... Done. tweak项目配置 Makefile # 添加设备ip和port，如果使用usb转发的话，这里ip为127.0.0.1，端口为转发端口 export THEOS_DEVICE_IP = 10.94.51.82 export THEOS_DEVICE_PORT = 22 # 打包架构 一般为安装设备的架构 ARCHS = arm64 # 导入的FRAMEWORK _FRAMEWORKS = UIKIT Tweak.x #import // 需要导入的框架 #import // 需要hook的类和方法、属性等，需要提前声明 @interface ViewController - (UIView *)view; @end // hook的类 %hook ViewController // hook的方法 - (void)changeBlue { [[self view] setBackgroundColor:[UIColor yellowColor]]; } %end 安装项目 $ make clean && make && make package && make install # 这样安装的版本为debug版本，在Cydia中可以看到，如果想安装release版本，在make package的时候加参数 # make package debug=0 # make 打包成动态库.dylib # make package 生成.deb # make install 根据配置的手机地址和端口信息，远程连接手机，安装deb，调用cydia安装动态库 # 安装的动态库统一由 Cydia Substrate进行管理 # 启动微信后，Cydia Substrate会去/Library/MobileSubstrate/DynamicLibraries中检查是否安装了和微信bundle id相同的动态库（通过plist检测，也在这个路径中），有的话，就加载 在Cydia中的最近安装里可以看到自己开发的插件的详细信息和安装位置 七、动态调试 通过lldb attach 已有进程，调试应用 7.1、debugserver重签名 默认情况下，/Developer/usr/bin/debugserver缺少一定的权限，只能调试通过Xcode安装的APP，无法调试其他的APP（比如通过App Store下载的APP） 如果希望调试其他APP，需要对debugserver重新签名 1）将手机上的/Developer/usr/bin/debugserver复制到mac 2）通过file命令查看文件信息 $ file debugserver debugserver: Mach-O universal binary with 2 architectures: [arm64:Mach-O 64-bit executable arm64] [arm64e] debugserver (for architecture arm64): Mach-O 64-bit executable arm64 debugserver (for architecture arm64e): Mach-O 64-bit executable arm64e2.1） 如果Fat Mach-O的话，使用lipo命令剥离出和自己手机匹配的架构 lipo -thin arm64 debugserver -output debugserver 3）导出原来权限 $ ldid -e debugserver > debugserver.entitlements 4）修改权限文件，添加删除响应的权限，这里删除了com.apple.security.network.server，com.apple.security.network.client，seatbelt-profiles，添加了get-task-allow，task_for_pid-allow，platform-application，run-unsigned-code com.apple.backboardd.debugapplications com.apple.backboardd.launchapplications com.apple.frontboard.debugapplications com.apple.frontboard.launchapplications com.apple.springboard.debugapplications com.apple.system-task-ports get-task-allow platform-application run-unsigned-code task_for_pid-allow 5）重签名 $ ldid -Sdebugserver.entitlements debugserver 将已经签好权限的debugserver放到手机的/usr/bin目录 6）ssh登录手机，为debugserver添加权限 $:~ root# chmod +x /usr/bin/debugserver 7.2、开启调试 1）mac上开始usb端口映射 $ iproxy 10086 10086 2）debugserver附加到进程，需要提前打开app。或者可以通过debugserver直接启动app并附加到进程 Cchukou:~ root# debugserver 127.0.0.1:10086 -a WeChat debugserver-@(#)PROGRAM:LLDB PROJECT:lldb-900.3.87 for arm64. Attaching to process WeChat... Listening to port 10086 for a connection from localhost... 3）lldb连接到debugserver $ lldb (lldb) process connect connect://127.0.0.1:10086 Process 14359 stopped * thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP frame #0: 0x00000001a6dff0f4 libsystem_kernel.dylib`mach_msg_trap + 8 libsystem_kernel.dylib`mach_msg_trap: -> 0x1a6dff0f4 : ret # 链接成功 # 尝试打印image信息 (lldb) image list -o -f [ 0] 0x0000000001164000 /var/containers/Bundle/Application/C4BD67F6-5D1E-4FB8-AAAC-CD9EE05248E9/ChangeColor.app/ChangeColor(0x0000000101164000) [ 1] 0x0000000101490000 /Users/360jr/Library/Developer/Xcode/iOS DeviceSupport/12.4.8 (16G201)/Symbols/usr/lib/dyld [ 2] 0x000000010117c000 /usr/lib/substitute-inserter.dylib(0x000000010117c000) [ 3] 0x00000000263a8000 /Users/360jr/Library/Developer/Xcode/iOS DeviceSupport/12.4.8 (16G201)/Symbols/System/Library/Frameworks/Foundation.framework/Foundation [ 4] 0x00000000263a8000 /Users/360jr/Library/Developer/Xcode/iOS DeviceSupport/12.4.8 (16G201)/Symbols/usr/lib/libobjc.A.dylib 八、应用重签名 如果需要将破坏了签名的安装包，安装到非越狱的手机上，需要对安装包进行重签名的操作。 进行重签名的包，必须是未加壳的。 8.1、 重签名前期准备 1）查看app的签名信息 $ codesign -vv -d Payload/WeChat.app Executable=/Users/360jr/Desktop/iOSRe/tool/demo/WeChat/Payload/WeChat.app/WeChat Identifier=com.tencent.xin Format=app bundle with Mach-O thin (arm64) CodeDirectory v=20500 size=3385627 flags=0x0(none) hashes=52895+7 location=embedded Signature size=4390 Authority=Apple iPhone OS Application Signing Authority=Apple iPhone Certification Authority Authority=Apple Root CA Info.plist entries=77 TeamIdentifier=88L2Q4487U Sealed Resources version=2 rules=25 files=2652 Internal requirements count=1 size=96 2）列出电脑上的可用证书 $ security find-identity -v -p codesigning 1) 123xxxxxxxxxx456 \"Apple Development: xxx (2342xxxx)\" 2) 123xxxxxxxxxx456 \"Apple Development: xxx (2342xxxx)\" 3) 123xxxxxxxxxx456 \"Apple Development: xxx (2342xxxx)\" 4) 123xxxxxxxxxx456 \"Apple Development: xxx (2342xxxx)\" 4 valid identities found 8.2、 重签名步骤 1）删除插件和带有插件的.app包（比如Watch，PlugIns） 因为普通账号不能对插件进行签名，所以需要删除 在包内容路径中找到Watch和PlugIns文件夹直接删除 2）重签framework # 进入FrameWork目录 $ cd Frameworks # 列举当前FrameWork $ ls # 覆盖签名 # codesign -fs \"（证书名称或者id）\" （FrameWork名称） $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" mars.framework $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" marsbridgenetwork.framework $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" matrixreport.framework $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" OpenSSL.framework $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" ProtobufLite.framework $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" andromeda.framework 3）给MachO上可执行权限 在包内容路径下执行$ Chmod +x WeChat 4）添加描述文件 新建工程，真机运行即可得到描述文件 将ipa包中的描述文件放到微信的包内容中去 5）修改应用包的bundid 修改微信包内容中的info.plist->BundleId，改为与描述文件的BundleId一致 6）授权文件重签app包 从embedded.mobileprovision文件中提取出entitlements.plist权限文件。 $ security cms -D -i embedded.mobileprovision > temp.plist $ /usr/libexec/PlistBuddy -x -c 'Print :Entitlements' temp.plist > entitlements.plist 用生成的权限文件签名app包 # $ codesign -fs 证书ID或名称 --entitlements entitlements.plist xxx.app $ codesign -fs BC4FF0F29******A5271F71D64894B60 --entitlements entitlements.plist CodesignApp.app $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" --no-strict --entitlements=ent.plist WeChat.app 7）安装.app包 Xcode界面下shift+cmd+2调出手机设备 选择+->Replace 如果出现安装失败，删除之前app在重新安装 app运行后利用Xcode附加进程：Debug->Attach to Process 8.3、 Xcode重签名 必须是与MachO文件同名工程（工程名相同，BundId无所谓），否则进程不是微信进程 1）运行app，装描述文件 新建WeChat工程，同上Command+Run，将描述文件生成一下 2）替换掉app包 复制一个新的越狱包，覆盖掉到原来的ipa包 3） 删除插件、Watch 4） 重签framework 5） run 由于是Xcode直接运行，可以通过Debug View查看界面 以上流程可以通过Xcode添加脚本直接完成 九、动态库注入 9.1、FrameWork注入 1）Xcode新建一个FrameWork 动态库项目，测试代码新建一个类，重写+(void)load方法，打印一些东西。运行编译生成.framework库文件。 2）将.framework库文件放到IPA包的FrameWorks目录下 3） yololib注入动态库 yololib # yololib binary dylib file yololib \"$TARGET_APP_PATH/$APP_BINARY\" \"Frameworks/XXXX.framework/XXXX\" 即可注入动态库到Mach-O中，查看Mach-O LC中链接的动态库，可以发现已经链接了自己生成的动态库 4）运行程序 可以发现控制台打印了+(void)load中测试的输入信息。 9.2、dylib注入 1）新建Library Target macOS->Library 2）修改dylib的BaseSDK为iOS 3）修改dylib的签名为iPhone Developer或者通用的Apple Developer，编译生成.dylib 4）主Target 添加依赖.dylib 5）运行编译主Target，查看是否已经添加到App的Frameworks中 6）yololib注入动态库 yololib \"$TARGET_APP_PATH/$APP_BINARY\" \"Frameworks/libFXHook.dylib\" 如果遇到image not found，clean一下再run Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-31 14:19:07 "},"articles/iOS/iosre/01_jailbreak.html":{"url":"articles/iOS/iosre/01_jailbreak.html","title":"01_iPhone越狱","keywords":"","body":"iPhone越狱 以下为维基百科中的描述 越狱 (iOS)) iOS越狱（英语：iOS Jailbreaking）是获取iOS设备的Root权限的技术手段。iOS系统的Root用户对除Apple特定私有进程之外的其他进程不开放，使用Root用户运行的进程在进程树中的PID为0。程序员在iOS中挖掘出一些可以将进程提权至PID0的漏洞（例如Task For PID0）。利用Root用户运行的进程意味着可以任意读取设备其中的APFS分区表和内核缓存地址，拥有一个用户可以随意控制的PID0进程还不能称之为一个完整的越狱。之后还需要利用Bypass（旁路）手段绕过Apple在iOS系统中设置的其他安全防护措施，将APFS或HFS+文件系统中的ROOTFS分区重新挂载（Remount）为可读写（R/W），从而达到添加二进制文件和守护进程的目的。通常大众用户认为能够正常使用Cydia才能被称为越狱，但其实这种说法是不正确的。但通过此软件可以完成越狱前不可能进行的动作，例如安装App Store以外未经过签名的应用、修改SpringBoard、运行Shell程序、使有运营商锁的设备利用卡贴解锁后通过替换配置文件形式实现本地化（例如“去除+86”，解锁FaceTime功能）。 越狱软件分发商店Cydia的创始人Jay Freeman在2010年10月估计，全球大概有10%的iPhone曾进行过越狱[2]#cite_note-2)。当iOS设备越狱后，用户可对系统进行编辑或是运行不被苹果公司所验证的软件 目前对越狱的完美程度，业界开发人员给出了四个类别： 不完美越狱（Tethered Jailbreak），指的是，当处于此状态的iOS设备开机重启后，之前进行的越狱程序就会失效，用户将失去Root权限，需要将设备连接电脑来使用（如特定版本下的红雪（redsn0w））等越狱软件进行引导开机以后，才可再次使用越狱程序。否则设备将无法正常引导。 完美越狱（Untethered Jailbreak），指设备在进行重启后，越狱状态仍被完整保留。 半不完美越狱（Semi-tethered Jailbreak），指设备在重启后，将丢失越狱状态，并恢复成未越狱状态。如果想要恢复越狱环境，必须连接计算机并在越狱工具的引导下引导来恢复越狱状态。 半完美越狱（Semi-untethered Jailbreak），指设备在重启后，将丢失越狱状态；而若想要再恢复越狱环境，只需在设备上进行某些操作即可恢复越狱。 一、越狱 使用工具unc0ver （半完美越狱）（网上也存在一些其他越狱手段，可自行查找） unc0ver官网 unc0ver源码 目前已支持iOS 11.0 - 14.3 官网有详细的操作步骤，直接参照操作即可。 uncOver越狱过程中需要观看广告，可提前翻墙观看或者多试几次。 uncOver是半完美越狱，重启手机之后需要重新越狱。 一些其他的越狱工具：checkra1n uncOver企业签的安装方式：iosninja 二、Cydia源 添加Cydia源，下载常用软件 Cydia常用源 三、Cydia安装常用软件 OpenSSH 用于Mac远程ssh访问手机 Cycript Cycript是由Cydia创始人Saurik推出的一款脚本语言，Cycript混合了OC、JavaScript语法的解释器，这意味着我们能够在一个命令中使用OC或者JavaScript，甚至两者并用。它能够hook正在运行的进程，在运行时获取、修改很多东西。 Filza 查看手机文件系统 RevealLoader 配合Mac端的Reveal，可查看App的UI架构 Vi IMproved 文本编辑器 Apple File Conduit 可通过Mac软件（类似iFunBox）查看手机文件系统 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-09 10:33:27 "},"articles/iOS/iosre/02_ssh.html":{"url":"articles/iOS/iosre/02_ssh.html","title":"02_SSH远程访问越狱设备","keywords":"","body":"SSH远程访问越狱设备 前置条件： 已越狱 已安装OpenSSH 一、SSH简介 SSH 是 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前广泛采用的安全登录协议，专为远程登录会话和其他网络服务提供安全性的协议，替代以前不安全的Telnet协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 SSH包括二个部分，服务端的SSHD（Secure Shell Daemon）和SSH客户端。我们通常所说的用SSH登录到某某主机，指的是用SSH客户端远程登录到某台主机（该主机运行了SSHD服务端程序）。 SCP和SFTP都是SSH软件包的组成部分。 SCP是Secure Copy的简称，是用来与远程主机之间进行数据传输的协议，相当于经过加密的Copy命令。SCP数据传输使用 ssh协议，并且和ssh 使用相同的认证方式，提供相同的安全保证 。 SFTP=SSH File Transfer Protocol ，有时也被称作 Secure File Transfer Protocol 。SFTP是用SSH封装过的FTP协议，相当于经过加密的FTP协议，功能与FTP一样，只是传输数据经过加密。 SFTP支持断点续传，SCP则不支持。 总结：SSH其实是专门为shell设计的一种通信协议，它垮了两个网络层（传输层和应用层）。通俗点讲就是只有SSH客户端，和SSH服务器端之间的通信才能使用这个协议，其他软件服务无法使用它。 OpenSSH是SSL的开源实现 通信端口：22 1.1 SSL SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。 Https = Http + SSL/TLS 可支持更多协议，支持安全传输 OpenSSL是SSL的开源实现 二、SSH配置文件 2.1 配置文件 客户端配置文件：/etc/ssh/ssh_config 服务端配置文件：/etc/ssh/sshd_config 客户端公钥文件：~/.ssh/id_rsa.pub 客户端私钥文件：~/.ssh/id_rsa 服务端公钥文件：/etc/ssh/ssh_host_ras_key.pub 服务端私钥文件：/etc/ssh/ssh_host_rsa_key 2.2 known_hosts 客户端文件~/.ssh/known_hosts中保存了登录过的，远程服务器中的公钥 10.94.51.82 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCy4yU9Yt2bKmJ4vjuYlorL8j56EXEi6p17Zw+h0+Ymgt6IjFPCfoWr/RBnwGtb/gGCOVM3UUyTbzeXysr4rSxxxxxxxxVP27Oyo8BzXJI+pcZ2px8DWujTjab7Zi7Lq8w28inndBN7RszF+0bNf+/q/v1XfXE9cZk33bGn1oxybHQXSF3OqQQpP+GwtDJVLZTJfINc9jOAS1i35xEvMwvrfAei6NiMpLmka0= 2.3 authorized_keys 服务端文件~/.ssh/authorized_keys文件中，存储了客户端的公钥 $ cat authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADxxxxxxxxxxxxQKveQBbrR5TMqqKCK+huaekNhK14wGhZ7rt6Rr8FFWUYSQsS0jua/Ukm/Mmo9Mn test@test.net 2.4 SSH流程 1）建立安全连接，服务端提供公钥信息 2）收到服务端提供的信息，客户端首次会进行询问 3）客户端验证 账号密码验证 秘钥验证 客户端生成一对秘钥对，将公钥追加到服务端的authorized_keys中 SSH相关命令 生成秘钥对 $ ssh-keygen -t rsa -C \"your_email@example.com\" -f fileName # -t 指定密钥类型，默认是 rsa ，可以省略。 # -C 设置注释文字，比如邮箱。 # -f 指定密钥文件存储文件名，默认id_rsa，可以省略。 删除旧的公钥 ssh-keygen -R 10.xx.xx.10 将公钥追加到服务端的authorized_keys中 $ ssh-copy-id -i .ssh/id_rsa.pub serverName@192.168.x.xxx # -i 指定公钥名称，可省略，默认使用id_rsa.pub 如果配置了秘钥还需要输入密码，则需要在服务端设置文件权限 chmod 755 ~ chmod 755 ~/.ssh chmod 644 ~/.ssh/authorized_keys SCP相关命令 scp [参数] [原路径] [目标路径] 常用参数 -r : 复制文件夹 1）复制文件 # 拷贝本地文件到服务端 scp dumpdecrypted.dylib root@12.34.51.82:/usr/lib # 拷贝服务端文件到本地 scp root@12.34.56.122:/root/Downloads/compass.tar ./path 2）复制文件夹 # 拷贝本地文件夹到服务端 scp -r ./path root@12.34.56.122:/root/Downloads # 拷贝服务端文件夹到本地 scp -r root@12.34.56.122:/root/Downloads ./path 参考文献 SSH原理与运用 by 阮一峰 说说SSH、SCP和SFTP的那些事儿 SSL/TLS协议运行机制的概述 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-26 16:48:12 "},"articles/iOS/iosre/03_usbmuxd.html":{"url":"articles/iOS/iosre/03_usbmuxd.html","title":"03_usbmuxd蓝牙访问","keywords":"","body":"通过usbmuxd服务，实现MAC与iPhone的通信 一、usbmuxd usbmuxd 是苹果的一个服务，这个服务主要用于在USB协议上实现多路TCP连接，将USB通信抽象为TCP通信。苹果的iTunes、Xcode，都直接或间接地用到了这个服务。 这个服务在Mac端是由/System/Library/PrivateFrameworks/MobileDevice.framework/Resources/usbmuxd提供的, 开机自动启动。 它创建了一个Unix Domain Socket 在 /var/run/usbmuxd. usbmuxd服务程序监控iPhone在USB口上的连接, 当它监控到iPhone以用户模式连接到USB, (相对的是recovery模式), usbmuxd服务程序就会连接到这个/var/run/usbmuxd的TCP端口, 并开始成为一个USB - TCP 请求转发器 那么,如果想编写个第三方程序与iphone进行通信,实现类似iTunes的功能, 你的程序可以通过usbmuxd! 建立一个TCP连接到/var/run/usbmuxd端口, 根据协议发送对应的请求包, usbmuxd服务会将请求转发到USB的iPhone上。 二、SSH通过USB远程到iPhone 默认情况下，ssh通过TCP远程到iPhone 可通过usbmuxd进行端口转发，通过usb连接到iPhone 开源实现： python-client：下载v1.0.8版本 usbmuxd-1.0.8/python-client/tcprelay.py peertalk iproxy 三、iproxy转发 $ brew install usbmuxd # 安装usbmuxd库之后，就顺带安装了一个小工具iproxy # iproxy 本地端口 映射端口 $ iproxy 10010 22 四、python-client转发 1）开启python-client 加 -t 参数可支持多个ssh链接 $ python tcprelay.py -t 22:10010 Forwarding local port 10010 to remote port 22 2）ssh链接本地端口，python-client会进行转发 $ ssh root@localhost -p 10010 Last login: Mon Mar 8 15:16:23 2021 from 127.0.0.1 Cchukou:~ root# 3）scp也可通过usb进行拷贝 # -P 进行端口指定（大写P） scp -P dumpdecrypted.dylib root@localhost:/usr/lib Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-09 10:44:39 "},"articles/iOS/iosre/04_terminal_zh.html":{"url":"articles/iOS/iosre/04_terminal_zh.html","title":"04_iPhone终端中文问题","keywords":"","body":"iPhone终端中文显示问题 新建~/.inputrc 编辑文件内容： # 不将中文转化为转义序列 set convert-meta off # 允许向终端输出中文 set output-meta on # 允许向终端输入中文 set meta-flag on set input-meta on Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 15:36:28 "},"articles/iOS/iosre/05_cycript.html":{"url":"articles/iOS/iosre/05_cycript.html","title":"05_Cycript","keywords":"","body":"Cycript Cycript是由 Cydia ( 熟悉越狱的同学应该都很清楚 ) 创始人 Saurik 推出的一款脚本语言，Cycript 混合了 OC、 JavaScript 语法的解释器，这意味着我们能够在一个命令中使用 OC 或者 JavaScript，甚至两者并用。 它能够hook正在运行的进程，在运行时修改很多东西。 Cycript官网 常用语法 # + 对象地址 可以直接调用对象的方法 cy# [#0x10ec66aa0 subviews] @[#\"; layer = >\"] 查看视图层级recursiveDescription() UIWindow.keyWindow().recursiveDescription().toString() UIApp等价于[UIApplication sharedApplication] cy# UIApp #\"\" 定义变量 cy# var a = 3 3 cy# var b = 4 4 cy# a + b 7 显示已加载的所有OC类 ObjectiveC.classes 显示对象的所有成员变量 cy# *#0x111970800 {isa:NSKVONotifying_WCAccountLoginFirstViewController,_hasOverrideClient:0,_hasOverrideHost:0,_hasInputAssistantItem:0,_overrideTransitioningDelegate:null,_view:#\">\",_tabBarItem:null,_navigationItem:#\" titleView=0x1114d6500\", ... 筛选出某种类型的对象 cy# choose(UIViewController) [#\" ChildViewControllers:(\\n \\\"\\\"\\n)\",#\" ChildViewControllers:(\\n \\\"\\\"\\n)\"] 退出cy 调试模式 control+d 实际开发中，可将常用的方法封装到一个.cy文件中，然后放到/usr/lib/cycript0.9中，可以在此路径下自定义路径，并且在cycript环境中导入，即可使用 ## com.mj.mjcript 意思是cycript根路径下的com/mj/mjcript.cy文件 cy# @import com.mj.mjcript {} 参考资料 mjcript iOS 逆向 - lldb高级篇 Chisel 与 Cycript Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 16:38:26 "},"articles/iOS/iosre/06_reveal.html":{"url":"articles/iOS/iosre/06_reveal.html","title":"06_Reveal","keywords":"","body":"Reveal 参考文献 Reveal 详细安装（以及安装问题解决） Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 16:40:21 "},"articles/iOS/iosre/07_reverse.html":{"url":"articles/iOS/iosre/07_reverse.html","title":"07_逆向思路","keywords":"","body":"iOS逆向思路 一、App从代码到安装流程 源代码-->编译、链接、签名-->prj.app-->zip压缩-->prj.ipa(.app放入Payload中在进行zip压缩)-->上传App Store --> 加密（加壳） -->安装 二、逆向思路 界面分析 Cycript、Reveal 代码分析 Mach-O文件静态分析 MachOView、class-dump、Hopper Disassembler、ida 动态调试 对运行中的App进行代码调试 debugserver、LLDB 代码注入 注入代码到App中 重签名 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:14:41 "},"articles/iOS/iosre/08_macho.html":{"url":"articles/iOS/iosre/08_macho.html","title":"08_Mach-O","keywords":"","body":"Mach-O Mach-O Header格式 struct mach_header_64 { uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */ }; 常见Mach-O文件格式 #define MH_OBJECT 0x1 /* relocatable object file */ #define MH_EXECUTE 0x2 /* demand paged executable file */ #define MH_FVMLIB 0x3 /* fixed VM shared library file */ #define MH_CORE 0x4 /* core file */ #define MH_PRELOAD 0x5 /* preloaded executable file */ #define MH_DYLIB 0x6 /* dynamically bound shared library */ #define MH_DYLINKER 0x7 /* dynamic link editor */ #define MH_BUNDLE 0x8 /* dynamically bound bundle file */ #define MH_DYLIB_STUB 0x9 /* shared library stub for static linking only, no section contents */ #define MH_DSYM 0xa /* companion file with only debug sections */ #define MH_KEXT_BUNDLE 0xb /* x86_64 kexts */ #define MH_FILESET 0xc /* a file composed of other Mach-Os to be run in the same userspace sharing a single linkedit. */ .o 目标文件 .a 静态库（.o文件的合集） executable 可执行文件 .dylib 动态库 .framework/xxx 动态库 /usr/lib/dyld dyld动态连接器 .dSYM/Contents/Resources/DWARF/xx dsym 常用命令 file $ file /usr/bin/xcode-select /usr/bin/xcode-select: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit executable x86_64] [arm64e:Mach-O 64-bit executable arm64e] /usr/bin/xcode-select (for architecture x86_64): Mach-O 64-bit executable x86_64 /usr/bin/xcode-select (for architecture arm64e): Mach-O 64-bit executable arm64e otool $ otool -h /usr/bin/xcode-select /usr/bin/xcode-select: Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedfacf 16777223 3 0x00 2 20 1648 0x00200085 $ otool -l /usr/bin/xcode-select /usr/bin/xcode-select: Load command 0 cmd LC_SEGMENT_64 cmdsize 72 segname __PAGEZERO vmaddr 0x0000000000000000 vmsize 0x0000000100000000 fileoff 0 filesize 0 maxprot 0x00000000 initprot 0x00000000 nsects 0 flags 0x0 lipo $ lipo -info /usr/bin/xcode-select Architectures in the fat file: /usr/bin/xcode-select are: x86_64 arm64e # 架构分离 $ lipo 文件路径 -thin 架构类型 -output 输出文件路径 # 架构合并 $ lipo 文件路径1 文件路径2 -output 输出文件路径 nm $ nm /usr/bin/xcode-select U _CFRelease U _CFStringCreateWithCString U _MDItemCreate U __MDItemMarkAsUsed 参考资料 Mach-O 文件格式探索 Apple 操作系统可执行文件 Mach-O Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:52:37 "},"articles/iOS/iosre/09_dyld_shared_cache.html":{"url":"articles/iOS/iosre/09_dyld_shared_cache.html","title":"09_动态库共享缓存","keywords":"","body":"动态库共享缓存 iOS3.1开始，为了提高性能，绝大部分的系统动态库文件都打包到一个缓存文件中（dyld shared cache） 缓存文件路径：/System/Library/Caches/com.apple.dyld/dyld_shared_cache_armX 从动态共享缓存中抽取动态库 在dyld源码中寻找 dsc_extractor.cpp 编译出可执行文件a.out usage: ./a.out Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 18:25:02 "},"articles/iOS/iosre/10_dumpdecrypted.html":{"url":"articles/iOS/iosre/10_dumpdecrypted.html","title":"10_脱壳","keywords":"","body":"脱壳 一、加壳 上传至Apple Store的应用，会被加密，无法正常查看Mach-O信息，需要脱壳 二、脱壳工具 脱壳的两种方法：硬脱壳和动态脱壳 如何检查Mach-O是否已经脱壳 查看LC中的LC_ENCRyPTION_INFO中的Crypt ID，如果等于0则未加密 2.1 砸壳工具dumpdecrypted 下载源码，修改makefile ## 这里指定越狱设备的架构 GCC_UNIVERSAL=$(GCC_BASE) -arch armv7 -arch armv7s -arch arm64改成 GCC_UNIVERSAL=$(GCC_BASE) -arch arm64 ## 这里指定越狱设备的版本号 ## 网上也有其他操作，下载对应设备版本的Xcode CFLAGS = 改成CFLAGS = -target arm64-apple-ios12.4 make，生成dumpdecrypted.dylib 用codesign和个人调试证书给dumpdecrypted.dylib签名 # 查找可用的证书，然后用找到的证书签名 security find-identity -v -p codesigning codesign --force --verify --verbose --sign \"找到的可用证书名称\" dumpdecrypted.dylib 遇到的错误 Killed: 9 # 切换mobile用户：su mobile # 或者 # dumpdecrypted.dylib未签名，参考上面步骤进行重签名 dyld: warning: could not load inserted library 'dumpdecrypted.dylib' into hardened process because no suitable image found. Did find: dumpdecrypted.dylib: file system sandbox blocked mmap() of 'dumpdecrypted.dylib' 2021-02-23 10:54:50.669 brush_free[1563:120502] Checking for file at /var/mobile/Containers/Data/Application/D627C61F-4A0C-4DA3-978D-BD710C904571/Library/Caches/flex-extract.signal 2021-02-23 10:54:50.686 brush_free[1563:120502] FLXX Error: Couldn't get contents of file: /var/mobile/Library/Application Support/Flex3/patches.plist Abort trap: 6 # 未将dylib放到/usr/lib/目录下 # 新版iOS不支持将dylib放在.app或Documents目录下来注入 dyld: Symbol not found: ___chkstk_darwin # dumpdecrypted.dylib对应的SDK版本号不对，修改makefile重新编译或者下载对应版本的Xcode 2.2 class-dump 可以将Objective-C编写的二进制文件反编出头文件，需要是已砸壳的二进制文件。 官网 源码 MonkeyDev/class-dump：支持swift和oc混编 遇到的错误 Error: Cannot find offset for address 0x40000000010053e2 in stringAtAddress: # 项目中存在Swift，使用其他改版的class-dump 2.3 Hopper 目标文件代码分析 官网 三、脱壳-dumpdecrypted-硬脱壳 1）越狱手机上下载要破解的应用 2）在mac上ssh远程到越狱手机 # Mac # 密码默认alpine $ ssh root@10.94.51.82 root@10.94.51.82's password: Cchukou:~ root# 3）运行app，ps查看进程信息，查找破解App的bundle地址 # iPhone Cchukou:~ root# ps -e | grep brush 1492 ?? 1:18.02 /var/containers/Bundle/Application/EA717F2A-A0F7-4988-BA96-95B5830539B0/brush_free.app/brush_free 1532 ttys000 0:00.01 grep brush 一些其他操作： 导出app包 # Mac scp -r root@10.94.51.82:/var/containers/Bundle/Application/EA717F2A-A0F7-4988-BA96-95B5830539B0/brush_free.app . 代码查看手机上安装的所有应用的bundle id，使用了私有api，需要在越狱机上使用 #import // 获取安装app 的bundle id Class LSApplicationWorkspace_class = NSClassFromString(@\"LSApplicationWorkspace\"); NSObject *workspace = [LSApplicationWorkspace_class performSelector:@selector(defaultWorkspace)]; NSArray *arrAPP = [workspace performSelector:@selector(allApplications)]; NSLog(@\"arrAPP: %@\", arrAPP); 4）cycript寻找app的沙盒Documents具体路径 ，Ctrl+D退出cycript # iPhone Cchukou:~ root# cycript -p brush_free cy# NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0] @\"/var/mobile/Containers/Data/Application/D627C61F-4A0C-4DA3-978D-BD710C904571/Documents\" 5）使用scp指令把dumpdecrypted.dylib拷贝到/usr/lib/，老一点的系统版本可能需要放到Documents下 # Mac $ scp -r dumpdecrypted.dylib root@10.94.51.82:/usr/lib 6）切换mobile用户(旧版本可能不需要) # iPhone $ su mobile 7）执行dumpdecrypted砸壳，这里是在Documents路径下操作，砸壳后会将dump放到此文件夹下，可在任意文件夹下操作 # iPhone Cchukou:~/Containers/Data/Application/D627C61F-4A0C-4DA3-978D-BD710C904571/Documents mobile$ DYLD_INSERT_LIBRARIES=/usr/lib/dumpdecrypted.dylib /var/containers/Bundle/Application/EA717F2A-A0F7-4988-BA96-95B5830539B0/brush_free.app/brush_free mach-o decryption dumper DISCLAIMER: This tool is only meant for security research purposes, not for application crackers. [+] detected 64bit ARM binary in memory. [+] offset to cryptid found: @0x100a05028(from 0x100a04000) = 1028 [+] Found encrypted data at address 00004000 of length 6275072 bytes - type 1. [+] Opening /private/var/containers/Bundle/Application/EA717F2A-A0F7-4988-BA96-95B5830539B0/brush_free.app/brush_free for reading. [+] Reading header [+] Detecting header type [+] Executable is a plain MACH-O image [+] Opening brush_free.decrypted for writing. [+] Copying the not encrypted start of the file [+] Dumping the decrypted data into the file [+] Copying the not encrypted remainder of the file [+] Setting the LC_ENCRYPTION_INFO->cryptid to 0 at offset 1028 [+] Closing original file [+] Closing dump file Cchukou:~/Containers/Data/Application/D627C61F-4A0C-4DA3-978D-BD710C904571/Documents mobile$ ls brush_free.decrypted 8）将生成的.decrypted导出 # Mac $ scp root@10.94.51.82:/var/mobile/Containers/Data/Application/D627C61F-4A0C-4DA3-978D-BD710C904571/Documents/brush_free.decrypted . 四、class-dump 可使用class-dump导出可执行文件的头文件 1）使用class-dump导出头文件 class-dump -H brush_free.decrypted -o brush_header 五、frida-ios-dump一键脱壳 frida-ios-dump 1）Mac安装frida $ sudo pip install frida 2） 下载frida-ios-dump 3）进入frida-ios-dump，安装依赖，可能会出现错误，可先不用管，部分库未下载下来可在后面根据提示在进行安装 sudo pip install -r requirements.txt --upgrade 4）使用iproxy映射端口 $ iproxy 10010 22 5）修改frida-ios-dump中的dump.py文件的端口配置 Port = 10010 6）手机Cydia中安装frida # 打开Cydia->软件源->编辑->添加，输入build.frida.re，添加软件源后，搜索安装Frida即可，注意Frida对应的Cpu型号 7）frida-ios-dump工程中执行dump $ ./dump.py com.tencent.xin Start the target app com.tencent.xin ..... Generating \"微信.ipa\" # 如果报错 ImportError: No module named 'xxx' # sudo pip install 'xxx' Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-09 11:49:00 "},"articles/iOS/iosre/11_theos.html":{"url":"articles/iOS/iosre/11_theos.html","title":"11_Theos","keywords":"","body":"Theos Theos环境配置 安装签名工具 $ brew install ldid 添加Theos环境变量 export THEOS=~/.theos export PATH=$THEOS/bin:$PARH 下载Theos,thoes有其他依赖，使用参数--recursive进行clone $ git clone --recursive https://github.com/theos/theos.git $THEOS 新建项目 新建tweak项目 $ nic.pl NIC 2.0 - New Instance Creator ------------------------------ [1.] iphone/activator_event [2.] iphone/activator_listener [3.] iphone/application_modern [4.] iphone/application_swift [5.] iphone/cydget [6.] iphone/flipswitch_switch [7.] iphone/framework [8.] iphone/library [9.] iphone/notification_center_widget [10.] iphone/notification_center_widget-7up [11.] iphone/preference_bundle_modern [12.] iphone/theme [13.] iphone/tool [14.] iphone/tool_swift [15.] iphone/tweak [16.] iphone/tweak_with_simple_prefere$ pwd /Users/360jr/Desktop/iOSRe/tool/demo/ChangeColor/tweakwechatnces [17.] iphone/xpc_service Choose a Template (required): 15 # 新建tweak项目 Project Name (required): TweakWeChat # 项目名称 Package Name [com.yourcompany.tweakwechat]: com.liang.tweakwechat # bundle id Author/Maintainer Name [360JR]: Liang # author [iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]: com.tencent.xin # 需要动态修改的app的bundle id 【重要】 [iphone/tweak] List of applications to terminate upon installation (space-separated, '-' for none) [SpringBoard]: # 安装插件完成后需要关闭的app的bundle id，默认重启SpringBoard，直接回车即可 Instantiating iphone/tweak in tweakwechat/... Done. $ cd tweakwechat $ ls Makefile Tweak.x TweakWeChat.plist control 项目配置 Makefile # 添加设备ip和port，如果使用usb转发的话，这里ip为127.0.0.1，端口为转发端口 export THEOS_DEVICE_IP = 10.94.51.82 export THEOS_DEVICE_PORT = 22 # 打包架构 一般为安装设备的架构 ARCHS = arm64 # 导入的FRAMEWORK _FRAMEWORKS = UIKIT Tweak.x #import // 需要导入的框架 #import // 需要hook的类和方法、属性等，需要提前声明 @interface ViewController - (UIView *)view; @end // hook的类 %hook ViewController // hook的方法 - (void)changeBlue { [[self view] setBackgroundColor:[UIColor yellowColor]]; } %end 安装 $ make clean && make && make package && make install # 这样安装的版本为debug版本，在Cydia中可以看到，如果想安装release版本，在make package的时候加参数 # make package debug=0 # make 打包成动态库.dylib # make package 生成.deb # make install 根据配置的手机地址和端口信息，远程连接手机，安装deb，调用cydia安装动态库 # 安装的动态库统一由 Cydia Substrate进行管理 # 启动微信后，Cydia Substrate会去/Library/MobileSubstrate/DynamicLibraries中检查是否安装了和微信bundle id相同的动态库（通过plist检测，也在这个路径中），有的话，就加载 查看 在Cydia中的最近安装里可以看到自己开发的插件的详细信息和安装位置 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-15 15:31:39 "},"articles/iOS/iosre/12_debug.html":{"url":"articles/iOS/iosre/12_debug.html","title":"12_动态调试","keywords":"","body":"动态调试 一、Xcode调试APP的原理 Xcode中内置LLDB调试器，通过与iPhone连接，在iPhone安装debugserver的程序，debugserver与LLDB互相通信，发送调试指令和接收结果，debugserver与App之间互相通信，发送指令和接受结果。 debugserver 一开始存放在Mac的Xcode里面/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/对应版本/DeveloperDiskImage.dmg/usr/bin/debugserver 在手机首次连接Debug调试时，Xcode会把debugserver安装到手机的/Developer/usr/bin/debugserver 二、动态调试 默认情况下，/Developer/usr/bin/debugserver缺少一定的权限，只能调试通过Xcode安装的APP，无法调试其他的APP（比如通过App Store下载的APP） 如果希望调试其他APP，需要对debugserver重新签名 2.1 debugserver重签名 1）将手机上的/Developer/usr/bin/debugserver复制到mac 2）通过file命令查看文件信息 $ file debugserver debugserver: Mach-O universal binary with 2 architectures: [arm64:Mach-O 64-bit executable arm64] [arm64e] debugserver (for architecture arm64): Mach-O 64-bit executable arm64 debugserver (for architecture arm64e): Mach-O 64-bit executable arm64e2.1） 如果Fat Mach-O的话，使用lipo命令剥离出和自己手机匹配的架构 lipo -thin arm64 debugserver -output debugserver 3）导出原来权限 $ ldid -e debugserver > debugserver.entitlements 4）修改权限文件，添加删除响应的权限，这里删除了com.apple.security.network.server，com.apple.security.network.client，seatbelt-profiles，添加了get-task-allow，task_for_pid-allow，platform-application，run-unsigned-code com.apple.backboardd.debugapplications com.apple.backboardd.launchapplications com.apple.frontboard.debugapplications com.apple.frontboard.launchapplications com.apple.springboard.debugapplications com.apple.system-task-ports get-task-allow platform-application run-unsigned-code task_for_pid-allow 这里尝试了很多了，建议直接使用上面这个配置即可 5）重签名 $ ldid -Sdebugserver.entitlements debugserver 将已经签好权限的debugserver放到手机的/usr/bin目录 6）ssh登录手机，为debugserver添加权限 $:~ root# chmod +x /usr/bin/debugserver 2.2 开启调试 1）mac上开始usb端口映射 $ iproxy 10086 10086 2）debugserver附加到进程，需要提前打开app。或者可以通过debugserver直接启动app并附加到进程 Cchukou:~ root# debugserver 127.0.0.1:10086 -a WeChat debugserver-@(#)PROGRAM:LLDB PROJECT:lldb-900.3.87 for arm64. Attaching to process WeChat... Listening to port 10086 for a connection from localhost... 3）lldb连接到debugserver $ lldb (lldb) process connect connect://127.0.0.1:10086 Process 14359 stopped * thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP frame #0: 0x00000001a6dff0f4 libsystem_kernel.dylib`mach_msg_trap + 8 libsystem_kernel.dylib`mach_msg_trap: -> 0x1a6dff0f4 : ret # 链接成功 # 尝试打印image信息 (lldb) image list -o -f [ 0] 0x0000000001164000 /var/containers/Bundle/Application/C4BD67F6-5D1E-4FB8-AAAC-CD9EE05248E9/ChangeColor.app/ChangeColor(0x0000000101164000) [ 1] 0x0000000101490000 /Users/360jr/Library/Developer/Xcode/iOS DeviceSupport/12.4.8 (16G201)/Symbols/usr/lib/dyld [ 2] 0x000000010117c000 /usr/lib/substitute-inserter.dylib(0x000000010117c000) [ 3] 0x00000000263a8000 /Users/360jr/Library/Developer/Xcode/iOS DeviceSupport/12.4.8 (16G201)/Symbols/System/Library/Frameworks/Foundation.framework/Foundation [ 4] 0x00000000263a8000 /Users/360jr/Library/Developer/Xcode/iOS DeviceSupport/12.4.8 (16G201)/Symbols/usr/lib/libobjc.A.dylib 参考文献 iOS12 下配置debugserver + lldb调试环境的小技巧和问题处理 iOS 逆向（六）动态调试 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-10 17:46:26 "},"articles/iOS/iosre/13_rsa.html":{"url":"articles/iOS/iosre/13_rsa.html","title":"13_RSA","keywords":"","body":"RSA 参考文献 iOS逆向 RSA理论 iOS App 签名的原理 那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等) Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-12 14:46:33 "},"articles/iOS/iosre/14_hash.html":{"url":"articles/iOS/iosre/14_hash.html","title":"14_Hash","keywords":"","body":"Hash 参考文献 iOS逆向 hash理论 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-12 15:01:14 "},"articles/iOS/iosre/15_resign.html":{"url":"articles/iOS/iosre/15_resign.html","title":"15_重签名","keywords":"","body":"重签名 一、iOS App 签名 参考：iOS App 签名的原理 代码签名是对可执行文件或脚本进行数字签名，用来确认软件在签名后未被修改或损坏的措施。和数字签名原理一样，只不过签名的数据是代码而已 1.简单的代码签名 苹果官方生成一对非对称加密的公私钥，在iOS的系统中内置一个公钥，私钥由苹果后台保存； 开发者上传App到App Store时，苹果后台用私钥对App数据进行签名（即先进行Hash得到hash值，再用私钥加密hash值得到“RSAHash”）； iOS系统下载这个App后，用内置的公钥验证这个签名，若签名正确，那么这个App肯定是由苹果后台认证的，并且没有被修改过，也就达到了苹果的需求:保证安装的每一个APP都是经过苹果官方允许的。（公钥解密“RSAHash”得到hash1，再对应用包进行相同hash算法得到hash2,验证两次hash值是否相同） 2.双层签名 1) 安装包不需要上传到App Store，可以直接安装到手机上 开发App时直接真机调试安装 企业内部分发的渠道企业证书签名的APP也是需要顺利安装的 2) 苹果为了保证系统的安全性,又必须对安装的APP有绝对的控制权 经过苹果允许才可以安装 不能被滥用导致非开发APP也能被安装 1）苹果自己有固定的一对公私钥，跟之前App Store原理一样，私钥存储在苹果后台，公钥放在每个iOS系统中。这里称为公钥A、私钥A；在Mac系统中创建CSR文件时生成非对称加密算法的一对公钥/私钥，这里称为公钥M、私钥M；A=Apple M = Mac 2）开发者通过CSR文件向开发者中心申请证书 3）苹果服务器生成证书，也就是我们平时所说的开发者证书，其原理就是用私钥A对公钥M非对称加密。请求到证书之后，钥匙串访问就会将证书与本地私钥M（ 就是我们所熟知的p12） 进行相关联 4）当我们Command+B生成一个应用时，Xcode就会用本地的私钥M对这个应用进行签名，同时将证书放到app里面打包成ipa包 5）iPhone手机安装ipa包 6）iOS系统里的公钥A对证书进行验证 7）验证通过拿到证书中的公钥M 8）公钥M验证app的签名。这里就间接验证了这个APP的安装行为是否经过苹果官方允许（这里只验证安装行为，不验证APP是否被改动，因为开发阶段 APP 内容总是不断变化的，苹果不需要管） 简化流程： CSR文件和公钥M的关系： 当CSR文件创建的时候，会自动生成一对私钥和公钥，私钥存储在Mac上，私钥存储默认存储在登录钥匙串中，可以在钥匙串的分类钥匙下查看，请求到的证书会包含公钥部分 3. 描述文件 苹果为了解决应用滥用的问题，所以苹果又加了两个限制 在苹果后台注册过的设备才可以安装 签名只能针对某一个具体的App，并且苹果还想控制App里面的iCloud/PUSH/后台运行/调试器附加这些权限，所以苹果把这些权限开关统一称为Entitlements（授权文件） 因此才有了Provisioning Profile（描述文件） 描述文件一般包括证书、AppID、设备。当我们在真机运行或者打包一个项目的时候，证书用来证明我们程序的安全性和合法性 描述文件是在AppleDevelop网站创建的（在Xcode中填上AppleID它会进行创建），Xcode运行时会打包进入App内。所以我们使用CSR申请证书时,我们还要申请一个东西！！就是描述文件！ 在开发时，编译完一个App后，用本地的私钥M对这个App进行签名，同时把从苹果服务器得到的 Provisioning Profile文件打包进APP里，文件名为embedded.mobileprovision，把 APP 安装到手机上，最后系统进行验证 # 系统已安装描述文件路径 $ ~/Library/MobileDevice/Provisioning Profiles # 查看描述文件 $ security cms -Di xxx.mobileprovision AppIDName XC Wildcard ApplicationIdentifierPrefix A572RLB7UB CreationDate 2021-02-22T03:59:53Z Platform .... p12格式为本地私钥，可以导入到其他电脑，用于团队开发。 二、重签名 1. 重签名前期准备 如果需要将破坏了签名的安装包，安装到非越狱的手机上，需要对安装包进行重签名的操作。 进行重签名的包，必须是未加壳的。 1）查看app的签名信息 $ codesign -vv -d Payload/WeChat.app Executable=/Users/360jr/Desktop/iOSRe/tool/demo/WeChat/Payload/WeChat.app/WeChat Identifier=com.tencent.xin Format=app bundle with Mach-O thin (arm64) CodeDirectory v=20500 size=3385627 flags=0x0(none) hashes=52895+7 location=embedded Signature size=4390 Authority=Apple iPhone OS Application Signing Authority=Apple iPhone Certification Authority Authority=Apple Root CA Info.plist entries=77 TeamIdentifier=88L2Q4487U Sealed Resources version=2 rules=25 files=2652 Internal requirements count=1 size=96 2）列出电脑上的可用证书 $ security find-identity -v -p codesigning 1) 123xxxxxxxxxx456 \"Apple Development: xxx (2342xxxx)\" 2) 123xxxxxxxxxx456 \"Apple Development: xxx (2342xxxx)\" 3) 123xxxxxxxxxx456 \"Apple Development: xxx (2342xxxx)\" 4) 123xxxxxxxxxx456 \"Apple Development: xxx (2342xxxx)\" 4 valid identities found 2. 重签名步骤 1.删除插件和带有插件的.app包（比如Watch，PlugIns） 因为普通账号不能对插件进行签名，所以需要删除 在包内容路径中找到Watch和PlugIns文件夹直接删除 2.重签framework # 进入FrameWork目录 $ cd Frameworks # 列举当前FrameWork $ ls # 覆盖签名 # codesign -fs \"（证书名称或者id）\" （FrameWork名称） $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" mars.framework $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" marsbridgenetwork.framework $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" matrixreport.framework $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" OpenSSL.framework $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" ProtobufLite.framework $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" andromeda.framework 3.给MachO上可执行权限 在包内容路径下执行$ Chmod +x WeChat 4.添加描述文件 新建工程，真机运行即可得到描述文件 将ipa包中的描述文件放到微信的包内容中去 5.修改应用包的bundid 修改微信包内容中的info.plist->BundleId，改为与描述文件的BundleId一致 6.授权文件重签app包 从embedded.mobileprovision文件中提取出entitlements.plist权限文件。 $ security cms -D -i embedded.mobileprovision > temp.plist $ /usr/libexec/PlistBuddy -x -c 'Print :Entitlements' temp.plist > entitlements.plist 用生成的权限文件签名app包 # $ codesign -fs 证书ID或名称 --entitlements entitlements.plist xxx.app $ codesign -fs BC4FF0F29******A5271F71D64894B60 --entitlements entitlements.plist CodesignApp.app $ codesign -fs \"iPhone Developer: 840385400@qq.com (NZJQGFWAYE)\" --no-strict --entitlements=ent.plist WeChat.app 7.安装.app包 Xcode界面下shift+cmd+2调出手机设备 如果出现安装失败，删除之前app在重新安装 app运行后利用Xcode附加进程 3. GUI工具一步达成 只需要将embedded.mobileprovision拷贝到.app包内。然后，采用iOS App Signer来一步达成。 只要在Input File中输入.app文件路径，只针对.app包签名，.app内部动态库需要单独签名。 iReSign 与该功能类似，但是操作比上面多。 签名完成之后会导出ipa包 4. xcode重签名 必须是与MachO文件同名工程（工程名相同，BundId无所谓），否则进程不是微信进程 1. 运行app，装描述文件 新建WeChat工程，同上Command+Run，将描述文件生成一下 2. 替换掉app包 复制一个新的越狱包，覆盖掉到原来的ipa包 3. 删除插件、Watch 4. 重签framework 5. run 由于是Xcode直接运行，可以通过Debug View查看界面 三、脚本重签名 1. Xcode新建任意工程，找到添加脚本位置 2.准备资源文件夹 在项目目录下创建APP文件夹并放入越狱ipa包 3.1 新建脚本文件 app.sh # ${SRCROOT} 它是工程文件所在的目录 TEMP_PATH=\"${SRCROOT}/Temp\" #资源文件夹，我们提前在工程目录下新建一个APP文件夹，里面放ipa包 ASSETS_PATH=\"${SRCROOT}/APP\" #目标ipa包路径 TARGET_IPA_PATH=\"${ASSETS_PATH}/*.ipa\" #清空Temp文件夹 rm -rf \"${SRCROOT}/Temp\" mkdir -p \"${SRCROOT}/Temp\" #---------------------------------------- # 1. 解压IPA到Temp下 unzip -oqq \"$TARGET_IPA_PATH\" -d \"$TEMP_PATH\" # 拿到解压的临时的APP的路径 TEMP_APP_PATH=$(set -- \"$TEMP_PATH/Payload/\"*.app;echo \"$1\") # echo \"路径是:$TEMP_APP_PATH\" #---------------------------------------- # 2. 将解压出来的.app拷贝进入工程下 # BUILT_PRODUCTS_DIR 工程生成的APP包的路径 # TARGET_NAME target名称 TARGET_APP_PATH=\"$BUILT_PRODUCTS_DIR/$TARGET_NAME.app\" echo \"app路径:$TARGET_APP_PATH\" rm -rf \"$TARGET_APP_PATH\" mkdir -p \"$TARGET_APP_PATH\" cp -rf \"$TEMP_APP_PATH/\" \"$TARGET_APP_PATH\" #---------------------------------------- # 3. 删除extension和WatchAPP.个人证书没法签名Extention rm -rf \"$TARGET_APP_PATH/PlugIns\" rm -rf \"$TARGET_APP_PATH/Watch\" #---------------------------------------- # 4. 更新info.plist文件 CFBundleIdentifier # 设置:\"Set : KEY Value\" \"目标文件路径\" /usr/libexec/PlistBuddy -c \"Set :CFBundleIdentifier $PRODUCT_BUNDLE_IDENTIFIER\" \"$TARGET_APP_PATH/Info.plist\" #---------------------------------------- # 5. 给MachO文件上执行权限 # 拿到MachO文件的路径WeChat APP_BINARY=`plutil -convert xml1 -o - $TARGET_APP_PATH/Info.plist|grep -A1 Exec|tail -n1|cut -f2 -d\\>|cut -f1 -d\\ 放在项目根目录下，Xcode执行脚本处写入如下代码 chmod +x app.sh ./app.sh 4.运行 连接手机，Command+Run运行项目就能将越狱包装到手机上了 当然这种方式也能像应用重签名一样进行附加进程 参考文献 iOS 逆向（七）重签名 iOS逆向 应用重签名+微信重签名实战 iOS逆向 Shell脚本+脚本重签名 About Code Signing Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-12 16:59:14 "},"articles/iOS/iosre/16_injection.html":{"url":"articles/iOS/iosre/16_injection.html","title":"16_动态库注入","keywords":"","body":"代码注入 前置条件 使用脚本重签名 一、FrameWork注入 1.1 新建FrameWork 在Xcode中File->Target新增一个Framework 1.2 FrameWork中新建一个类 1.3 添加一个load方法 目前DYLD会动态加载项目中的Frameworks，但不会加载当前FrameWork 1.4 运行编译一下 保证FrameWork放到FrameWorks目录下 1.5 yololib注入动态库 建议将yololib复制粘贴到/usr/local/bin下，可以随时随地调用 将app.sh的最后一句代码启用（注意修改FrameWork名称） yololib \"$TARGET_APP_PATH/$APP_BINARY\" \"Frameworks/XXXX.framework/XXXX\" 1.6 运行 控制台打印 ❎❎❎❎❎❎❎❎❎❎ 二、dylib注入 2.1 新建Library Target 2.2 修改dylib的BaseSDK 2.3 修改dylib的签名 修改成iPhone Developer或者通用的Apple Developer 2.4 添加依赖 2.5 运行编译 查看是否已经添加到App的Frameworks中 2.6 修改脚本，使用yololib注入动态库 yololib \"$TARGET_APP_PATH/$APP_BINARY\" \"Frameworks/libFXHook.dylib\" 如果遇到image not found，clean一下再run Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-12 18:26:31 "},"articles/iOS/note/iOS强化/command_ioslowlevel.html":{"url":"articles/iOS/note/iOS强化/command_ioslowlevel.html","title":"iOS底层常用命令","keywords":"","body":"常用命令 Mach-O操作相关 otool # 查看header $ otool -h /usr/bin/xcode-select /usr/bin/xcode-select: Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedfacf 16777223 3 0x00 2 20 1648 0x00200085 # 查看LC $ otool -l /usr/bin/xcode-select /usr/bin/xcode-select: Load command 0 objdump # objdump 更容易阅读 # 查看header & lc objdump --macho --private-header Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC_64 X86_64 ALL 0x00 EXECUTE 20 1960 NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE # 查看__text objdump --macho -d (__TEXT,__text) section -[ViewController viewDidLoad]: 100005d40: ff c3 00 d1 sub sp, sp, #48 100005d44: fd 7b 02 a9 stp x29, x30, [sp, #32] ... # 查看符号 # objdump --macho -syms objdump --macho -syms /Users/360jr/Library/Developer/Xcode/DerivedData/LGQiangHuaDemo-cbqtsqzmnxlyglewsnjzasrkwdhh/Build/Products/Debug-iphoneos/LGQiangHuaDemo.app/LGQiangHuaDemo /Users/360jr/Library/Developer/Xcode/DerivedData/LGQiangHuaDemo-cbqtsqzmnxlyglewsnjzasrkwdhh/Build/Products/Debug-iphoneos/LGQiangHuaDemo.app/LGQiangHuaDemo: SYMBOL TABLE: 0000000100005d40 l F __TEXT,__text -[ViewController viewDidLoad] ... # 查看导出符号 objdump --macho --exports-trie ${MACH_PATH} # 查看间接符号 objdump --macho --indirect-symbols ${MACH_PATH} nm # 人类友好的方式输出符号表 nm -m # -n 排序 -p 不排序 lipo # 查看架构 $ lipo -info BioAuthEngine.framework # 架构分离 $ lipo 文件路径 -thin 架构类型 -output 输出文件路径 $ lipo BioAuthEngine.framework/BioAuthEngine -thin arm64 -o BioAuthEngine64 # 架构合并 $ lipo -create 文件路径1 文件路径2 -output 输出文件路径 libtool # 将目标文件.o合并为静态库 libtool -static -o xxxx.a *.o ar # 分离静态库 $ ar -x BioAuthEngine64 strings # 查看二进制文件中的strings $ strings qihooloan_ios | grep --color=auto -ir \"checkCachedLicense\" Xcode # 查看当前环境的SDK版本 $ xcodebuild -showsdks # 查看编译时间 $ defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES # Xcode环境变量 # 查看App启动时间 DYLD_PRINT_STATISTICS DYLD_PRINT_STATISTICS_DETAILS Xcrun # 查看Rebase和Bind信息 $ xcrun dyldinfo -bind InjectDemo bind information: segment section address type addend dylib symbol __DATA __objc_data 0x100008E18 pointer 0 libobjc _OBJC_METACLASS_$_NSObject __DATA __objc_data 0x100008E40 pointer 0 libobjc _OBJC_METACLASS_$_NSObject __DATA __objc_data 0x100008E00 pointer 0 libobjc __objc_empty_cache __DATA __objc_data 0x100008E28 pointer 0 libobjc __objc_empty_cache __DATA __objc_data 0x100008E50 pointer 0 libobjc __objc_empty_cache ... 编译链接相关 预处理 # 查看预处理 xcrun clang -E main.c 词法分析(lexical anaysis) 生成token # 词法分析 $ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.c 语法分析(semantic analysis) 词法分析的Token流会被解析成一颗抽象语法树(abstract syntax tree - AST)。 有了抽象语法树，clang就可以对这个树进行分析，找出代码中的错误。比如类型不匹配，亦或Objective C中向target发送了一个未实现的消息。 # 语法分析 $ xcrun clang -fsyntax-only -Xclang -ast-dump main.c | open -f CodeGen （生成IR） $ xcrun clang -S -emit-llvm main.c -o main.ll 生成汇编代码 $ xcrun clang -S main.c -o main.s 汇编器（机器码、目标文件） $ xcrun clang -fmodules -c main.c -o main.o 链接（生成mach-o） $ xcrun clang main.o -o main Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-02 10:27:00 "},"articles/iOS/note/iOS强化/01_多环境配置.html":{"url":"articles/iOS/note/iOS强化/01_多环境配置.html","title":"01_多环境配置","keywords":"","body":"01_多环境配置 Project:包含了项目所有的代码，资源文件，所有信息 Target:对指定代码和资源文件的具体构建方式。 Scheme:对指定Target的环境配置。 多Target Duplicate Target 修改plist，关联plist路径 修改bundle id、display name 修改icon，launch等等 多Target关联同一份代码，可以在build setting中预定义宏进行区分 Swift中有自己的定义宏的地方-Other Swift Flags，定义swift宏的话，加参数 -D Scheme 增加一个Scheme，就可以在build setting中根据不同的Scheme设置参数，build的时候选择不同Scheme即可运行不同参数 实操： 添加用户定义 自定义配置 经过测试，在User-Defined中添加的字符串，如果通过Macro方式读取，目前有问题，后续寻找解决方式 因为是宏引用，注意宏中定义的格式 使用${DEFINE}读取 在plist中读取或者在Macros中读取 xcconfig文件 同User-Define一样，可以通过宏读取或者info.plist读取 ${DEFINE}获取define的数据 注意Config文件中的特殊字符， # 例如 / ,可以先定义一个变量： SLASH=/ # 然后，通过下面方式间接访问： SLASH=/ HOST_URL = http:$(SLASH)/127.0.0.1 可配置build setting中的一些值的设置，关于build setting中的设置，参考https://xcodebuildsettings.com/ 在config中引用别的config，例如自定义的config，导入pod的config，否则pod install的时候会告警，运行也可能会出错 不同配置文件中对同一个key进行了设置，使用$(inherited)继承，可参考pod生成的config文件 main函数启动传参 mach-o与链接器 ABI：说明了mach-o的格式。ABI稳定，说明无需重新编译生成mach-o即可重新运行 可执行文件调用过程： 查看mach-o文件header格式 ## objdump $ objdump --macho --private-headers /Users/360jr/Library/Developer/Xcode/DerivedData/LGQiangHuaDemo-cbqtsqzmnxlyglewsnjzasrkwdhh/Build/Products/Debug-iphoneos/LGQiangHuaDemo.app/LGQiangHuaDemo /Users/360jr/Library/Developer/Xcode/DerivedData/LGQiangHuaDemo-cbqtsqzmnxlyglewsnjzasrkwdhh/Build/Products/Debug-iphoneos/LGQiangHuaDemo.app/LGQiangHuaDemo: Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC_64 ARM64 ALL 0x00 EXECUTE 26 3040 NOUNDEFS DYLDLINK TWOLEVEL PIE Load command 0 cmd LC_SEGMENT_64 cmdsize 72 segname __PAGEZERO ... # otool -h 查看header # otool -l 查看lc # 使用grep ‘xxx’ -A 5 -B 5 过滤，-A 5 向下显示五行， -B 5 向上显示5行 mach-o的读取 编译过程：将代码中的符号进行分类，放置到mach-o中，外部符号，内部符号 链接过程：多个目标文件合并成一个文件。符号表合并 将Xcode上脚本运行输出到终端上 终端输入 tty 命令获取终端重定向链 $ tty /dev/ttys002 Xcode执行脚本重定向到控制台 运行即可看到终端上的输出 将xcconfig文件中的配置输出到终端 利用以上，可以在Xcode编译时，将一些参数定义在config文件中，在编译完成后执行脚本命令，经结果输出到终端 查看符号： nm -pa path // config文件中定义生成的macho文件路径 MACHO_PATH=${BUILD_DIR}/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)/* strip在shell之后执行 // OTHER_LDFLAGS 传给链接器的参数 // -Xlinker 表示参数是传递给连接器的 （Xcode前端有clang执行，但是参数传递给连接器） // man ld 查看连接器使用手册 // -S 参数表示不输出调试符号到输出文件 OTHER_LDFLAGS = -Xlinker -S strip命令 剥离符号表 llvm编译 调试 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-13 17:11:15 "},"articles/iOS/note/iOS强化/02_Mach-O和符号.html":{"url":"articles/iOS/note/iOS强化/02_Mach-O和符号.html","title":"02_Mach-O和符号","keywords":"","body":"02_Mach-O和符号 Mach-O的格式 dyld按照约定的规则，通过Header，获取size，然后根据size获取LC，找到代码段，并执行 iOS小端模式 mach header：自描述，架构、文件类型。。。 Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedfacf 16777228 0 0x00 2 26 3040 0x00200085 查看header，两种命令：objdump 和 otool # objdump 更容易阅读 objdump --macho --private-header Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC_64 X86_64 ALL 0x00 EXECUTE 20 1960 NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE # otool -h 更原始的信息 Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedfacf 16777228 0 0x00 2 26 3040 0x00200085 查看_TEXT \\_text objdump --macho -d (__TEXT,__text) section -[ViewController viewDidLoad]: 100005d40: ff c3 00 d1 sub sp, sp, #48 100005d44: fd 7b 02 a9 stp x29, x30, [sp, #32] 100005d48: fd 83 00 91 add x29, sp, #32 100005d4c: a0 83 1f f8 stur x0, [x29, #-8] 100005d50: e1 0b 00 f9 str x1, [sp, #16] 100005d54: a8 83 5f f8 ldur x8, [x29, #-8] 100005d58: e9 03 00 91 mov x9, sp 100005d5c: e8 03 00 f9 str x8, [sp] ... mach-o可读可写 mach-o + 签名 编译生成目标文件，目标文件中有符号表，重定位符号表。重定位符号表中存储的是当前.o中使用的外部API。在最终链接过程中合并符号表 链接就是处理目标文件符号的过程 查看目标文件中的符号（全局符号，本地符号） # objdump --macho -syms objdump --macho -syms /Users/360jr/Library/Developer/Xcode/DerivedData/LGQiangHuaDemo-cbqtsqzmnxlyglewsnjzasrkwdhh/Build/Products/Debug-iphoneos/LGQiangHuaDemo.app/LGQiangHuaDemo /Users/360jr/Library/Developer/Xcode/DerivedData/LGQiangHuaDemo-cbqtsqzmnxlyglewsnjzasrkwdhh/Build/Products/Debug-iphoneos/LGQiangHuaDemo.app/LGQiangHuaDemo: SYMBOL TABLE: 0000000100005d40 l F __TEXT,__text -[ViewController viewDidLoad] 0000000100005d90 l F __TEXT,__text -[AppDelegate application:didFinishLaunchingWithOptions:] 0000000100005ee0 l F __TEXT,__text -[AppDelegate application:configurationForConnectingSceneSession:options:] 0000000100005ffc l F __TEXT,__text -[AppDelegate application:didDiscardSceneSessions:] 0000000100006120 l F __TEXT,__text -[SceneDelegate scene:willConnectToSession:options:] 00000001000061cc l F __TEXT,__text -[SceneDelegate sceneDidDisconnect:] 全局符号和本地符号：可见性 __attribute__ 编译器指令，传递编译器支持的参数给编译器 最好的隐藏全局符号的方式：变为本地符号 __DATA__ __common段：未初始化的全局变量段 __attribute__((deprecated)) 方法被废弃 全局符号对全局可见，整个项目可见，对使用项目的人可见 全局符号：命名空间 导入导出符号： // 查看mach-header // objdump --macho -private-header ${MACH_PATH} // otool -l ${MACH_PATH} // 查看__TEXT // objdump --macho -d ${MACH_PATH} // 查看符号表 // objdump --macho --syms ${MACH_PATH} // 查看导出符号 // objdump --macho --exports-trie ${MACH_PATH} // 查看间接符号表 // objdump --macho --indirect-symbols ${MACH_PATH} // nm -m ${MACH_PATH} CMD = objdump --macho --syms ${MACH_PATH} TTY=/dev/ttys002 // mach-o + 签名 // mach-o __TEXT.__text只读 // 2016 7、8 60m 500m __TEXT.__text 全局符号默认会被导出 动态库运行时加载，则链接阶段提供符号就行 间接符号表 ：使用的动态库的符号 全局符号可以变成导出符号，给外界使用 间接符号表优化时最不可能删除，找不到符号-》动态库提供的导出符号不可删除，及全局符号不可删除 strip动态库的时候，脱去不是全局符号的符号 OC默认就是导出符号 OC动态库->减小体积->脱去不想暴露的符号->借助一个连接器参数 #OC脱去指定符号 OTHER_LDFLAGS=$(inherited) -Xlinker -unexported_symbol -Xlinker _OBJC_CLASS_$_LGOneObject OTHER_LDFLAGS=$(inherited) -Xlinker -unexported_symbol -Xlinker _OBJC_METACLASS_$_LGOneObject #可以通过 -unexported_symbol-list指定一个文件， 拦截器参数：导出符号到一个文件 -map ：符号信息，链接信息 OTHER_LDFLAGS=$(inherited) -Xlinker -S -Xlinker -map -Xlinker /Users/ws/Desktop/VIP课程/第一节、符号与链接（下）/上课代码/Symbol.text 弱定义 正常全局符号定义两个会冲突，把符号声明成弱定义，则找到一个符号就不会往下找了。其他的被忽略 弱引用 // 弱引用 声明可以不实现 void weak_import_function(void) __attribute__((weak_import)); // 引用的时候判断 if (weak_import_function) { weak_import_function(); } # -U （undefined）链接阶段忽略某个符号，运行阶段会有 OTHER_LDFLAGS=$(inherited) -Xlinker -U -Xlinker _weak_import_function // 重新导出 只能给间接符号表中的符号起别名 OTHER_LDFLAGS=$(inherited) -Xlinker -alias -Xlinker _NSLog -Xlinker Cat_NSLog # 人类友好的方式输出符号表 nm -m 重新导出用法：将我链接的动态库重新导出，让引用我的程序可见 连接器参数，让整个文件重新导出 swift符号 默认本地符号 声明为public，变成全局符号 strip 脱符号表 App中，除了间接符号表，其他的符号理论上都可以脱去 deadcode_strip，这里挖坑？ 调试strip命令 从文件中读取断点 br read -f br list strip 断点放到组 br enable strp 断点启用组 br write -f 写入断点 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-01-28 22:13:07 "},"articles/iOS/note/iOS强化/03_pod.html":{"url":"articles/iOS/note/iOS强化/03_pod.html","title":"03_ruby&pod","keywords":"","body":"Ruby & Cocoapods $ ruby --version rvm & rbenv 用于安装管理使用多个ruby环境。两个工具本质都是在path上做手脚，一个在执行前，一个在执行中 rvm管理版本。新手建议不用 $ rvm list 查看本机ruby list $ rvm list known 查看当前rvm可管理的ruby版本，如果rvm版本过低，不一定能管理到当前的ruby版本 $ rvm install ruby-2.x.x 安装rvm可管理的指定版本的ruby $ rvm install ruby --head 能够安装的最新版本 $ rvm get stable rvm升级 ruby的第三方库，Gem形式发布 $ gem search -r/-f $ gem install --version $ gem list Bundler Gemfile -> bundle install -> Gemfile.lock Gemfile source 'https://rubygems.org' # 源 gem 'xxx' , path: '../..' gem 'xxx', '1.1.1 ruby调试 ruby-debug-ide 这是一个gem。这是一个中间件，用于ruby调试信息在调试器和ide中间传递 debase 这是ruby调试器，断点、调用栈等等 $ gem info cocoapods *** LOCAL GEMS *** cocoapods (1.10.1, 1.10.0, 1.9.1) Authors: Eloy Duran, Fabio Pelosin, Kyle Fuller, Samuel Giddins Homepage: https://github.com/CocoaPods/CocoaPods License: MIT Installed at (1.10.1): /Library/Ruby/Gems/2.6.0 (1.10.0): /Library/Ruby/Gems/2.6.0 (1.9.1): /Library/Ruby/Gems/2.6.0 The Cocoa library package manager. gem源 gem source gem source -l Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-04 23:00:48 "},"articles/iOS/renote/re_order.html":{"url":"articles/iOS/renote/re_order.html","title":"常用汇编指令&寄存器","keywords":"","body":"常用ARM汇编指令&寄存器 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-06-29 22:30:44 "},"articles/iOS/renote/01_asm.html":{"url":"articles/iOS/renote/01_asm.html","title":"01_汇编-寄存器-函数调用","keywords":"","body":"汇编 一、硬件相关 总线 地址总线 控制总线 数据总线 寄存器 对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。 对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制 不同的CPU，寄存器的个数、结构是不相同的 浮点和向量寄存器 因为浮点数的存储以及其运算的特殊性,CPU中专门提供浮点数寄存器来处理浮点数 浮点寄存器 64位: D0 - D31 32位: S0 - S31 现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器. 向量寄存器 128位:V0-V31 通用寄存器 通用寄存器也称数据地址寄存器通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。 ARM64拥有有32个64位的通用寄存器 x0 到 x30，以及XZR(零寄存器),这些通用寄存器有时也有特定用途。 那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位. 比如 w0 就是 x0的低32位! pc寄存器(program counter) 为指令指针寄存器，它指示了CPU当前要读取指令的地址 在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息 CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义 比如 1110 0000 0000 0011 0000 1000 1010 1010 可以当做数据 0xE003008AA 也可以当做指令 mov x0, x8 CPU根据什么将内存中的信息看做指令？ CPU将pc指向的内存单元的内容看做指令 如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过 SP(x31)和FP(x29)寄存器 sp寄存器在任意时刻会保存我们栈顶的地址. fp寄存器也称为x29寄存器属于通用寄存器,但是在某些时刻我们利用它保存栈底的地址! 注意:ARM64开始,取消32位的 LDM,STM,PUSH,POP指令! 取而代之的是ldr\\ldp str\\stp ARM64里面 对栈的操作是16字节对齐的!! x30寄存器 x30寄存器存放的是函数的返回地址.当ret指令执行时刻,会寻找x30寄存器保存的地址值! 注意:在函数嵌套调用的时候.需要讲x30入栈! 修改寄存器的值 register read pc register write pc 0x879899 高速缓存 CPU先在高速缓存中找指令或者数据 高度缓存到内存有映射，类似虚拟内存 指令 占用四个字节 编写汇编代码 .text .global _A, _B _A: mov x0,#0xa0 mov x1,#0xb0 add x1,x0,#0x0a mov x1,x0 bl _B mov x0,#0x00 ret _B: add x0,x1,#0x10 ret 二、函数调用栈 常见的函数调用开辟和恢复的栈空间 sub sp, sp, #0x40 ; 拉伸0x40（64字节）空间 stp x29, x30, [sp, #0x30] ;x29\\x30 寄存器入栈保护 add x29, sp, #0x30 ; x29指向栈帧的底部 ... ldp x29, x30, [sp, #0x30] ;恢复x29/x30 寄存器的值 add sp, sp, #0x40 ; 栈平衡 ret 关于内存读写指令 注意:读/写 数据是都是往高地址读/写 栈空间往低开辟，往高读写 str(store register)指令 将数据从寄存器中读出来,存到内存中. ldr(load register)指令 将数据从内存中读出来,存到寄存器中 此ldr 和 str 的变种ldp 和 stp 还可以操作2个寄存器. 堆栈操作练习 使用32个字节空间作为这段程序的栈空间,然后利用栈将x0和x1的值进行交换. sub sp, sp, #0x20 ;拉伸栈空间32个字节 stp x0, x1, [sp, #0x10] ;sp往上加16个字节,存放x0 和 x1 ldp x1, x0, [sp, #0x10] ;将sp偏移16个字节的值取出来,放入x1 和 x0 bl和ret指令 bl指令 CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令 ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如 mov x0,#10、mov x1,#20 但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能 ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令 bl 地址 将下一条指令的地址放入lr(x30)寄存器。lr保存的就是回家的路 转到地址处执行指令 bl跳转之前，需要保存当前lr寄存器的值。保护回去的路。保存到栈上，保存到寄存器容易被其他函数修改导致破坏 # 将x29，x30存储到 sp减去0x10的地方，往低地址开辟，存储的时候先存x29，再x30，往高地址存。[]后面的感叹号表示sp-0x10后的值赋值给sp # [] 操作符，代表取里面的地址进行运算 stp x29, x30, [sp, #-0x10]! # 注意[]中没有数字，意思是直接从sp中开始读取，往高地址读取，放入到x29和x30，然后将sp+0x10后的值赋值给sp ldp x29, x30, [sp], #0x10 如果对sp开辟8字节，stp/str数据的时候没事，ldp/ldr 的时候就会崩溃。因为ARM64里面 对栈的操作是16字节对齐的!!。所以sp拉伸一定是16个字节的整数倍 ret 默认使用lr(x30)寄存器的值,通过底层指令提示CPU此处作为下条指令地址! ARM64平台的特色指令,它面向硬件做了优化处理的 x30寄存器 x30寄存器存放的是函数的返回地址.当ret指令执行时刻,会寻找x30寄存器保存的地址值! 注意:在函数嵌套调用的时候.需要讲x30入栈! 三、函数参数 函数的参数和返回值 ARM64下,函数的参数是存放在X0到X7(W0到W7)这8个寄存器里面的.如果超过8个参数,就会入栈. 函数的返回值是放在X0 寄存器里面的。oc参数不超过6个（self,sel） 看代码：实际sp拉伸了0x40，从0x30开始存x29，x30。然后将x29指向0x30的地方。就是说虽然拉伸了0x40，但是fp是从0x30开始算的。从0x30开始存自己调用栈的东西，前两两个用来保护现场 adrp & add 到内存的某一页偏移一个地址取数据 看代码：超过8个低参数，存到了当前函数的栈里面，从sp位置开始往高处存。到下一个函数时，下一个函数会从上一个函数的栈空间取参数。返回值最终放入到x0 看代码：如果返回值大于一个寄存器的长度（8个字节），函数返回值是直接写入到上一个函数的栈中。步骤大概是上一个函数bl之前，会保存当前sp偏移的一个地址（还是当前栈中的一个地址，即大小是返回值的大小）到寄存器中，然后下一个函数返回值就写到这个寄存器指向的上一个栈中的位置 函数的局部变量 函数的局部变量放在栈里面! 栈平衡后，就会被回收 函数的嵌套调用 状态寄存器（也称标记寄存器）cpsr 控制程序执行流程 8位寄存器 修改cpsr寄存器的内容，可以改变程序的运行流程 add是加法运算，adds是可以改变标志位的add CPU内部的寄存器中,有一种特殊的寄存器(对于不同的处理器,个数和结构都可能不同).这种寄存器在ARM中,被称为状态寄存器就是CPSR(current program status register)寄存器 CPSR和其他寄存器不一样,其他寄存器是用来存放数据的,都是整个寄存器具有一个含义.而CPSR寄存器是按位起作用的,也就是说,它的每一位都有专门的含义,记录特定的信息. 注:CPSR寄存器是32位的 CPSR的低8位（包括I、F、T和M[4：0]）称为控制位，程序无法修改,除非CPU运行于特权模式下,程序才能修改控制位! N、Z、C、V均为条件码标志位。它们的内容可被算术或逻辑运算的结果所改变，并且可以决定某条指令是否被执行!意义重大! N（Negative）标志 CPSR的第31位是 N，符号标志位。它记录相关指令执行后,其结果是否为负.如果为负 N = 1,如果是非负数 N = 0.    注意,在ARM64的指令集中,有的指令的执行时影响状态寄存器的,比如add\\sub\\or等,他们大都是运算指令(进行逻辑或算数运算)； Z(Zero)标志 CPSR的第30位是Z，0标志位。它记录相关指令执行后,其结果是否为0.如果结果为0.那么Z = 1.如果结果不为0,那么Z = 0.    对于Z的值,我们可以这样来看,Z标记相关指令的计算结果是否为0,如果为0,则Z要记录下\"是0\"这样的肯定信息.在计算机中1表示逻辑真,表示肯定.所以当结果为0的时候Z = 1,表示\"结果是0\".如果结果不为0,则Z要记录下\"不是0\"这样的否定信息.在计算机中0表示逻辑假,表示否定,所以当结果不为0的时候Z = 0,表示\"结果不为0\"。 C(Carry)标志 CPSR的第29位是C，进位标志位。一般情况下,进行无符号数的运算。 加法运算：当运算结果产生了进位时（无符号数溢出），C=1，否则C=0。 减法运算（包括CMP）：当运算时产生了借位时（无符号数溢出），C=0，否则C=1。 加法溢出，C标志位为1，没溢出为0 减法溢出，C标志位为0（被借走了），没溢出为1    对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N - 1位，就是它的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位。如下图所示： 进位    我们知道，当两个数据相加的时候，有可能产生从最高有效位想更高位的进位。比如两个32位数据：0xaaaaaaaa + 0xaaaaaaaa,将产生进位。由于这个进位值在32位中无法保存，我们就只是简单的说这个进位值丢失了。其实CPU在运算的时候，并不丢弃这个进位制，而是记录在一个特殊的寄存器的某一位上。ARM下就用C位来记录这个进位值。比如，下面的指令 mov w0,#0xaaaaaaaa；0xa 的二进制是 1010 adds w0,w0,w0； 执行后 相当于 1010 借位    当两个数据做减法的时候，有可能向更高位借位。再比如，两个32位数据：0x00000000 - 0x000000ff,将产生借位，借位后，相当于计算0x100000000 - 0x000000ff。得到0xffffff01 这个值。由于借了一位，所以C位 用来标记借位。C = 0.比如下面指令： mov w0,#0x0 subs w0,w0,#0xff ; subs w0,w0,#0xff subs w0,w0,#0xff V(Overflow)溢出标志 CPSR的第28位是V，溢出标志位。在进行有符号数运算的时候，如果超过了机器所能标识的范围，称为溢出。 正数 + 正数 为负数 溢出 负数 + 负数 为正数 溢出 正数 + 负数 不可能溢出 C和V不管是不是有符号或者无符号数进行运算，C永远把计算当成无符号数，V永远当成有符号数。 四、全局变量 adrp：address page ; adrp： ; 1、将当前pc寄存器的后三位(十六进制)清零 0x10258e1a0->0x10258e000 ; 2、将运算符中的1左移三位(十六进制) 1->1000 ; 3、将运算的结果相加 0x10258e000+1000 -> 0x10258F000 ; 意义：内存的pagesize=4k=0xFFF 也就是左移三位，adrp就是定位到内存中的某一页的位置 （mac是4k，ios是16k） 0x10258e1a0 : adrp x0, 1 0x10258e1a4 : add x0, x0, #0xfa3 ; =0xfa3 ; 4、然后加#0xfa3 0x10258F000+#0xfa3 = 0x10258Ffa3 ; 意义：定位到某一页的偏移位置 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-14 23:31:55 "},"articles/iOS/renote/02_asm.html":{"url":"articles/iOS/renote/02_asm.html","title":"02_汇编-条件-循环-判断","keywords":"","body":"汇编之条件、循环、选择 if # 减法，不改变寄存器值，改变标记寄存器的值 cmp w8, w9 # 小于等于就跳转，否则继续往下执行 b.le loc_109323 ..... # 上面代码还原就表示 if (w8 cmp（Compare）比较指令    CMP 把一个寄存器的内容和另一个寄存器的内容或立即数进行比较。但不存储结果，只是正确的更改标志。    一般CMP做完判断后会进行跳转，后面通常会跟上B指令！ BL 标号：跳转到标号处执行 B.GT 标号：比较结果是大于（greater than），执行标号，否则不跳转 B.GE 标号：比较结果是大于等于（greater than or equal to），执行标号，否则不跳转 B.EQ 标号：比较结果是等于，执行标号，否则不跳转 B.HI 标号：比较结果是无符号大于，执行标号，否则不跳转 LOOP 本质还是if Switch 1、假设switch语句的分支比较少的时候（例如3，少于4的时候没有意义）没有必要使用此结构，相当于if。 2、各个分支常量的差值较大的时候，编译器会在效率还是内存进行取舍，这个时候编译器还是会编译成类似于if，else的结构。 3、在分支比较多的时候：在编译的时候会生成一个表（跳转表每个地址四个字节）。通过查表找到执行代码的地址值进行执行。 switch代码分支的代码是连续的 通过一些列的运算，找到case中或者default中代码块指向的地址 case中算偏移值，用switch的参数和选择最小的case进行减法 然后cmp用上面计算的偏移值和（最大的case和最小的case之间的差值）进行比较，无符号大于比较b.hi 可计算是否在区间内 如果在区间内，进行查表 switch参数减去最小case算出偏移值进行后续查表运算 表放在这个函数代码段的最后一个地址后面。代码中是通过adrp找到的 表里面放了一些负数，个数等于最小的case到最大的case的个数（最大case-最小case+1），就是区间内每一个值对应一个负数，通过这个后续的计算(ldrsw)，可以跳转到对应的case或者default中执行 用表空间换找到对应case代码块时间。case越多，效率越高 表中为什么不放地址：因为aslr，放偏移更好，而且地址占空间 ubfx x9, x9, #0, #32 //保留x9中，从第0位开始，保留32位，其他的用0补齐，然后赋值给x9。相当于把x9中的高32位清零 // 0x0123456789abcdef 运算后得-> 0x0000000089abcdef br x9 // 根据x9寄存器中的值，进行跳转 ldrsw x10, [x8, x11, lsl #2] // x11的值左移两位加上x8的值，指向的地址空间的值，赋值给x10 编译器优化 会优化掉对程序执行结果没有影响的代码 有可能会直接算出值 NSLog的第一个参数是format，x0中存的一个指针，例如字符串%d的指针 Release的优化默认就是fastest，smaller 指针 指针8字节 sizeof是一个运算符，汇编层面直接就可以看到运算结果 指针的自增自减或者加减法和指向的数据类型有关：int *a; a = (int *)100; a++;,这里a就等于104 自增自减和编译器有关 总结下就是指针的运算都是和指向的数据类型优化，运算结果类似于计算以数据类型为宽度的步长个数。指针的运算单位是指向的数据类型的宽度 指针的反汇编 指针变量->理论上保存的就是sp偏移一个位置的地址值 数组名就是一个指针。int *a == &arr[0] == arr == &arr,其中&arr编译器可能会报警告，类似的还有函数名也是一个指针 指针的基本用法 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-24 11:10:44 "},"articles/iOS/renote/03_oc_asm.html":{"url":"articles/iOS/renote/03_oc_asm.html","title":"03_OC&Block反汇编","keywords":"","body":"OC&Block反汇编 OC方法的本质 OC方法调用，就是调用objc_msgSend 第一个参数为self，放在x0里面 第二参数为SEL，放在x1里面 0x1047160a8 : adrp x8, 7 0x1047160ac : ldr x0, [x8, #0x560] 0x1047160b0 : adrp x8, 7 0x1047160b4 : ldr x1, [x8, #0x540] -> 0x1047160b8 : bl 0x1047164e4 ; symbol stub for: objc_msgSend (lldb) register read x0 x0 = 0x000000010471d648 (void *)0x000000010471d620: Person (lldb) register read x1 x1 = 0x00000001d70bb5df (lldb) p (SEL)0x00000001d70bb5df (SEL) $1 = \"person\" alloc & init [[self alloc] init]在新的系统里直接调用objc_alloc_init 在老的系统里iOS11及以前，是分别调用objc_alloc和通过objc_msgSend调用init，其中init的x0并没有发现设置，这是应为x0为alloc的返回值，也就是self objc_storeStrong：OC中庸strong修饰的变量，都会调用这个函数。编译器优化，函数中默认的变量都是strong类型。这个函数既能让对象强引用，又能让对象销毁，结束的时候会调用，就是释放(第二个) void // Person *p = [[Person allo] init]; objc_storeStrong(id *location, id obj) // 这里两个参数，第一个参数相当于临时变量&p , 第二个就是目标obj { id prev = *location; // 保存location指向的旧对象 if (obj == prev) { // 判断 旧对象是否是要保持的对象，如果是就返回 return; } objc_retain(obj); // 如果不是，保持新对象，引用计数+1 *location = obj; // 让location指向新对象 objc_release(prev);// 老对象引用计数-1 } // 当OC方法结束的时候也会调用这个函数，但是x1就传入的是0x0了，相当于objc_storeStrong(&p,nil)，最终就是类似调用objc_release(p) 工具静态分析Mach-O的方法 源代码： int main(int argc, char * argv[]) { Person * p = [Person person]; p.name = @\"hank\"; p.age = 18; return 0; } Hopper反汇编： 00000001000061a4 adrp x8, #0x10000d000 00000001000061a8 ldr x0, [x8, #0x558] ; objc_cls_ref_Person(类),_OBJC_CLASS_$_Person(结构体)，点击可进入 00000001000061ac adrp x8, #0x10000d000 00000001000061b0 ldr x1, [x8, #0x538] ; \"person\",@selector(person) 00000001000061b4 bl imp___stubs__objc_msgSend ; objc_msgSend // 这里可以看出，objc_msgSend的第一个参数是Person类，第二个是sel。 类地址 // 点击类名进入 000000010000d558 dq _OBJC_CLASS_$_Person ; 左边的地址就是Person类在Mach-O中的地址 // 点击结构体进入 对应的就是结构体的信息 _OBJC_CLASS_$_Person: 000000010000d640 struct __objc_class { ; DATA XREF=_main+28, 0x100008078, objc_cls_ref_Person _OBJC_METACLASS_$_Person, // metaclass _OBJC_CLASS_$_NSObject, // superclass __objc_empty_cache, // cache 0x0, // vtable __OBJC_CLASS_RO_$_Person // data } 方法名地址 // 点击person方法名进入，查看person的cstring位置 000000010000712a db \"person\", 0 ; DATA XREF=_main+36, 0x10000cc30, 0x10000d538 Block block数据结构 struct Block_layout { void * __ptrauth_objc_isa_pointer isa; // isa volatile int32_t flags; // contains ref count int32_t reserved; BlockInvokeFunction invoke; //函数指针 struct Block_descriptor_1 *descriptor; // imported variables }; global block 不引用外部变量，在全局区 源码： ``` Hopper: 0000000100006188 adrp x0, #dyld_stub_binder_100008000 ; 0x100008028@PAGE 000000010000618c add x0, x0, #0x28 ; 0x100008028@PAGEOFF, block_literal_global 0000000100006190 bl impstubs__objc_retainBlock ; objc_retainBlock 点击`___block_literal_global`进入： ___block_literal_global: 0000000100008028 dq 0x000000010001c040 ; DATA XREF=_main+28 这里是isa 0000000100008030 dd 0x50000000 0000000100008034 dd 0x00000000 0000000100008038 dq 0x00000001000061d4 ; 这里是invoke 点击进入 0000000100008040 dq 0x0000000100008008 block的实现 main_block_invoke: 00000001000061d4 sub sp, sp, #0x20 ; Objective C Block defined at 0x100008028, DATA XREF=0x100008038 00000001000061d8 stp x29, x30, [sp, #0x10] 00000001000061dc add x29, sp, #0x10 00000001000061e0 str x0, [sp, #0x10 + var_8] 00000001000061e4 str x0, [sp, #0x10 + var_10] 00000001000061e8 adrp x0, #dyld_stub_binder_100008000 ; 0x100008088@PAGE 00000001000061ec add x0, x0, #0x88 ; 0x100008088@PAGEOFF, @\"block\" 00000001000061f0 bl impstubs__NSLog ; NSLog 00000001000061f4 ldp x29, x30, [sp, #0x10] 00000001000061f8 add sp, sp, #0x20 00000001000061fc ret ; endp ``` stack block Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-24 14:57:55 "},"articles/iOS/renote/04_apple_der.html":{"url":"articles/iOS/renote/04_apple_der.html","title":"04_苹果证书相关","keywords":"","body":"苹果证书相关 iOS代码签名 简单签名，不适合多渠道（debug、企业发布...） 双向签名 p12：本地公私钥 描述文件 上述不能限制设备的安装数量，权限等等，所以有了描述文件 描述文件（Provisioning profile）一般包括三样东西：证书、App ID、设备。当我们在真机运行或者打包一个项目的时候，证书用来证明我们程序的安全性和合法性。 # 查看描述文件 $ security cms -D -i embedded.mobileprovision # 导出描述文件到一个plist文件 $ security cms -D -i embedded.mobileprovision > temp.plist Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-24 16:08:20 "},"articles/iOS/renote/05_resign.html":{"url":"articles/iOS/renote/05_resign.html","title":"05_重签名","keywords":"","body":"重签名 codesign签名 codesign是Xcode提供的签名工具 签名是可以替换的 签名就是用证书对一份代码进行签名，现在使用另一份证书对同一份代码进行签名 列出钥匙串里可签名的证书： $ security find-identity -v -p codesigning 查看Mach-O是否加密： $ otool -l HelloWorldApp.app/HelloWorldApp | grep cryptid -A 5 -B 5 Load command 13 cmd LC_ENCRYPTION_INFO_64 cmdsize 24 cryptoff 16384 cryptsize 16384 cryptid 0 # 0表示为加密 1表示加密 pad 0 加密并不是加密的全部Mach-O，只加密了代码段 重签名演练 1、删除插件和Watch，给可执行文件添加权限 2、使用codesign重签名framework $ codesign -fs 36833CADAC1367617DA226BE8F5490253208DB68 mm_dart_cpp.framework 3、使用Xcode生成描述文件，需要使用上述证书，将生成的描述文件拷贝到目标App的包内 4、在目标App包内的plist文件修改bundle id为和上述描述文件相同 5、拷贝出目标App的描述文件中的权限到一个新的plist文件中，然后通过指定权限文件对App的Mach-O进行重签名 $ codesign -fs 36833CADAC1367617DA226BE8F5490253208DB68 --no-strict --entitlements=entitlements.plist WeChat.app 6、重签完成，可以使用Xcode进行安装了，也可以使用Xcode进行调试了 上述步骤6，可以提前用Xcode生成一次，然后用上面的包在目标路径下替换然后重新运行Xcode，就能安装上了 脚本重签 1、用户组 2、Xcode脚本重签名 脚本的目录就是当前工程的根目录 # ${SRCROOT} 它是工程文件所在的目录 TEMP_PATH=\"${SRCROOT}/Temp\" #资源文件夹，我们提前在工程目录下新建一个APP文件夹，里面放ipa包 ASSETS_PATH=\"${SRCROOT}/APP\" #目标ipa包路径 TARGET_IPA_PATH=\"${ASSETS_PATH}/*.ipa\" #清空Temp文件夹 rm -rf \"${SRCROOT}/Temp\" mkdir -p \"${SRCROOT}/Temp\" #---------------------------------------- # 1. 解压IPA到Temp下 unzip -oqq \"$TARGET_IPA_PATH\" -d \"$TEMP_PATH\" # 拿到解压的临时的APP的路径 TEMP_APP_PATH=$(set -- \"$TEMP_PATH/Payload/\"*.app;echo \"$1\") # echo \"路径是:$TEMP_APP_PATH\" #---------------------------------------- # 2. 将解压出来的.app拷贝进入工程下 # BUILT_PRODUCTS_DIR 工程生成的APP包的路径 # TARGET_NAME target名称 TARGET_APP_PATH=\"$BUILT_PRODUCTS_DIR/$TARGET_NAME.app\" echo \"app路径:$TARGET_APP_PATH\" rm -rf \"$TARGET_APP_PATH\" mkdir -p \"$TARGET_APP_PATH\" cp -rf \"$TEMP_APP_PATH/\" \"$TARGET_APP_PATH\" #---------------------------------------- # 3. 删除extension和WatchAPP.个人证书没法签名Extention rm -rf \"$TARGET_APP_PATH/PlugIns\" rm -rf \"$TARGET_APP_PATH/Watch\" #---------------------------------------- # 4. 更新info.plist文件 CFBundleIdentifier # 设置:\"Set : KEY Value\" \"目标文件路径\" /usr/libexec/PlistBuddy -c \"Set :CFBundleIdentifier $PRODUCT_BUNDLE_IDENTIFIER\" \"$TARGET_APP_PATH/Info.plist\" #---------------------------------------- # 5. 给MachO文件上执行权限 # 拿到MachO文件的路径 APP_BINARY=`plutil -convert xml1 -o - $TARGET_APP_PATH/Info.plist|grep -A1 Exec|tail -n1|cut -f2 -d\\>|cut -f1 -d\\ 最新的Wechat(8.0.2)包里面，info.plist有个Support Device的，删掉 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-24 18:34:25 "},"articles/iOS/renote/06_inject.html":{"url":"articles/iOS/renote/06_inject.html","title":"06_代码注入","keywords":"","body":"代码注入 注入原理 程序的动态库会加载 动态库的加载时在App Mach-O中的LC中LC_LOAD_DYLIB标记 所以如果需要程序加载我们自己添加的动态库，需要修改Mach-O，添加对应的LC段 使用yololib 注入流程 Framwork注入 通过Xcode新建Framwork，将库安装进入APP包 通过yololib注入Framwork库路径。命令：$yololib（空格）MachO文件路径（空格）库路径 所有的Framwork加载都是由DYLD加载进入内存被执行的 注入成功的库路径会写入到MachO文件的LC_LOAD_DYLIB字段中 Dylib注入 通过Xcode新建Dylib库（注意：Dylib属于MacOS所以需要修改属性） 添加Target依赖(新建Copy到Framework)，让Xcode将自定义Dylib文件打包进入APP包。 利用yololib进行注入。 脚本注入 # ${SRCROOT} 它是工程文件所在的目录 TEMP_PATH=\"${SRCROOT}/Temp\" #资源文件夹，我们提前在工程目录下新建一个APP文件夹，里面放ipa包 ASSETS_PATH=\"${SRCROOT}/APP\" #目标ipa包路径 TARGET_IPA_PATH=\"${ASSETS_PATH}/*.ipa\" #清空Temp文件夹 rm -rf \"${SRCROOT}/Temp\" mkdir -p \"${SRCROOT}/Temp\" #---------------------------------------- # 1. 解压IPA到Temp下 unzip -oqq \"$TARGET_IPA_PATH\" -d \"$TEMP_PATH\" # 拿到解压的临时的APP的路径 TEMP_APP_PATH=$(set -- \"$TEMP_PATH/Payload/\"*.app;echo \"$1\") # echo \"路径是:$TEMP_APP_PATH\" #---------------------------------------- # 2. 将解压出来的.app拷贝进入工程下 # BUILT_PRODUCTS_DIR 工程生成的APP包的路径 # TARGET_NAME target名称 TARGET_APP_PATH=\"$BUILT_PRODUCTS_DIR/$TARGET_NAME.app\" echo \"app路径:$TARGET_APP_PATH\" rm -rf \"$TARGET_APP_PATH\" mkdir -p \"$TARGET_APP_PATH\" cp -rf \"$TEMP_APP_PATH/\" \"$TARGET_APP_PATH\" #---------------------------------------- # 3. 删除extension和WatchAPP.个人证书没法签名Extention rm -rf \"$TARGET_APP_PATH/PlugIns\" rm -rf \"$TARGET_APP_PATH/Watch\" #---------------------------------------- # 4. 更新info.plist文件 CFBundleIdentifier # 设置:\"Set : KEY Value\" \"目标文件路径\" /usr/libexec/PlistBuddy -c \"Set :CFBundleIdentifier $PRODUCT_BUNDLE_IDENTIFIER\" \"$TARGET_APP_PATH/Info.plist\" #---------------------------------------- # 5. 给MachO文件上执行权限 # 拿到MachO文件的路径 APP_BINARY=`plutil -convert xml1 -o - $TARGET_APP_PATH/Info.plist|grep -A1 Exec|tail -n1|cut -f2 -d\\>|cut -f1 -d\\ Method Swizzling注意事项 如果交换后，回调原来类的方法，SEL不存在的话，也会报错，因为img是根据sel去查找的 所以一般交换的话，就是给原始类添加一个方法，然后在原始类中进行交换 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-24 19:03:09 "},"articles/iOS/renote/07_macho.html":{"url":"articles/iOS/renote/07_macho.html","title":"07_Mach-O","keywords":"","body":"Mach-O 格式 编译顺序会影响Mach-O文件的内容 查看Mach-O代码段可以发现不同编译顺序出来的可执行文件的__TEXT的代码段排列就不一样 # 查看__text objdump --macho -d 通用二进制 Universal binary 多种架构的二进制文件 Mach-O文件格式 VM VM Addr : 虚拟内存地址 VM Size： 虚拟内存大小 File offset: 数据在文件中偏移量 File size: 数据在文件中的大小 FatHeader offset：距离文件开始地方的偏移 size：文件的大小 分页：x86_64 4096，iOS 16K Header struct mach_header_64 { uint32_t magic; /* mach magic number identifier 魔数 快速定位32位还是64位*/ cpu_type_t cputype; /* cpu specifier cpu类型 比如arm*/ cpu_subtype_t cpusubtype; /* machine specifier cpu具体类型 比如arm64*/ uint32_t filetype; /* type of file 文件类型 比如可执行文件*/ uint32_t ncmds; /* number of load commands LC数量*/ uint32_t sizeofcmds; /* the size of all the load commands LC总大小*/ uint32_t flags; /* flags 二进制文件支持的功能，主要用于加载、链接等等*/ uint32_t reserved; /* reserved 保留字段*/ }; Load Command pagezero：64和32位兼容，64位在地址上加上一个4G，vm size 4g，file size不占空间 LC_DYLD_INFO_ONLY：动态链接相关信息 PAGEZERO 64和32位兼容，64位在地址上加上一个4G，vm size 4g，file size不占空间 LC_SEGMENT_64 将文件中（32位或64位）的段映射到进程地址空间中 LC_DYLD_INFO_ONLY 动态链接相关信息 LC_SYMTAB 符号地址 LC_DYSYMTAB 动态符号表地址 LC_LOAD_DYLINKER 使用谁加载，我们使用dyld LC_UUID 文件的UUID LC_VERSION_MIN_MACOSX 支持最低的操作系统版本 LC_SOURCE_VERSION 源代码版本 LC_MAIN 设置程序主线程的入口地址和栈大小 LC_LOAD_DYLIB 依赖库的路径，包含三方库 LC_FUNCTION_STARTS 函数起始地址表 LC_CODE_SIGNATURE 代码签名 Data dyld绑定符号函数绑定，符号绑定也是一个函数，需要提前绑定，才能使用这个函数，绑定其他的符号 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-25 00:05:54 "},"articles/iOS/renote/08_dyld.html":{"url":"articles/iOS/renote/08_dyld.html","title":"08dyld_Load_initialize消息发送","keywords":"","body":"dyld&Load&initialize&objc_messageSend 自己引入的动态库的加载流程（Load方法执行） 在没有依赖关系的情况下，动态库的加载顺序由Link Binary With Libraries中的拖入顺序决定，可以通过Link Binary With Libraries来控制动态库的加载顺序，先拖入先执行 在有依赖的关系下，被依赖的子节点优先加载。 总结动态库的加载顺序为：先根据拖入配置的链接顺序加载，如有依赖的先递归式加载依赖。 注入的代码在主工程之前，但是在自己的动态库之后执行 单个Image文件中的Load加载顺序 有继承关系的类的+load方法的执行顺序，是从基类到子类的；没有继承关系的两个类的+load方法的执行顺序是与编译顺序有关的（Build Phases -> Compile Sources中的顺序）。 所有分类的+load方法都要在所有类的+load方法之后执行 所有分类的+load方法的执行顺序与编译顺序有关，与是谁的分类无关，也与一个类有几个分类无关 具体流程： 从load_images中的call_load_methods\u0001开始： 循环调用call_class_loads方法，直到没有可执行的+load方法 调用call_category_loads方法 重复1->2，直到所有的类和分类的+load方法都执行完毕 Load方法总结 +load方法是在dyld阶段的执行初始化方法步骤中执行的，其调用为load_images -> call_load_methods 一个类在代码中不主动调用+load方法的情况下，其类、子类实现的+load方法都会分别执行一次 父类的+load方法执行在前，子类的+load方法在后 在同一镜像中，所有类的+load方法执行在前，所有分类的+load方法执行在后 同一镜像中，没有关系的两个类的执行顺序与编译顺序有关（Compile ources中的顺序） 同一镜像中所有的分类的+load方法的执行顺序与编译顺序有关（Compile Sources中的顺序），与是谁的分类，同一个类有几个分类无关 同一镜像中主工程的+load方法执行在前，静态库的+load方法执行在后。有多个静态库时，静态库之间的执行顺序与编译顺序有关（Link Binary With Libraries中的顺序） 不同镜像中，动态库的+load方法执行在前，主工程的+load执行在后，多个动态库的+load方法的执行顺序编译顺序有关（Link Binary With Libraries中的顺序）。 initialize initialize在类或者其子类的第一个方法被调用前调用。即使类文件被引用进项目,但是没有使用,initialize不会被调用。由于是系统自动调用，也不需要再调用 [super initialize] ，否则父类的initialize会被多次执行。假如这个类放到代码中，而这段代码并没有被执行，这个函数是不会被执行的。 父类的initialize方法会比子类先执行 当子类未实现initialize方法时,会调用父类initialize方法,子类实现initialize方法时,会覆盖父类initialize方法. 当有多个Category都实现了initialize方法,会覆盖类中的方法,只执行一个(会执行Compile Sources 列表中最后一个Category 的initialize方法) OC消息发送 整个方法查找的过程，可以简单的概括为以下几个步骤 实现、初始化对应的类 根据是否支持垃圾回收机制(GC)判断是否忽略当前的方法调用 从cache中查找方法 cache中没有找到对应的方法，则到方法列表中查，查到则缓存 如果本类中查询到没有结果，则遍历所有父类重复上面的查找过程 最后都没有找到的方法的话，则执行 _class_resolveMethod 让调用者动态添加方法，并重复一轮查询方法的过程 若第六步没有完成动态添加方法，则把 _objc_msgForward_impcache 作为对应 SEL 的方法进行缓存，然后调用 _objc_msgForward_impcache 方法 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-25 15:41:03 "},"articles/iOS/renote/09_hook.html":{"url":"articles/iOS/renote/09_hook.html","title":"09_hook","keywords":"","body":"Hook Method Swizzle FishHook 重新绑定符号表 通过修改懒加载和非懒加载两个表的指针达到C函数HOOK的目的 流程 NSLog(@\"123\"); //创建rebinding 结构体 struct rebinding nslog; nslog.name = \"NSLog\"; nslog.replacement = my_NSLog; //保存NSLog系统函数地址的指针! nslog.replaced = (void *)&sys_nslog; //需求:HOOK NSLog struct rebinding bds[] = {nslog}; rebind_symbols(bds, 1); NSLog(@\"end\"); 程序编译之后，在Mach-O中有懒加载和非懒加载两张表。 这两张表中记录了需要bind的符号，我们这里演示的NSLog属于懒加载符号表，在使用的时候才进行绑定 在首次执行NSLog之前，先通过Mach-O和程序的ASLR查看内存中的存储值： 通过lldb查看ASLR # slide 为 0x25ac000 (lldb) image list [ 0] B5C04260-B346-3AEE-B640-D648C77F2D87 0x00000001025ac000 /Users/360jr/Library/Developer/Xcode/DerivedData/001--fishhookDemo-enjeubscnnocrabjzuikobbkipgr/Build/Products/Debug-iphoneos/001--fishhookDemo.app/001--fishhookDemo Mach-O中找到NSLog的函数地址信息： 通过通过程序起始地址0x00000001025ac000加上Offset0xc000，就的到NSLog符号在运行时的内存地址，查看内存空间 (lldb) x/g 0x00000001025ac000+0xc000 0x1025b8000: 0x00000001025b24ec 发现与Mach-O中的Data不一样，原因是因为这个Data其实是一个Mach-O中的函数地址，在dyld加载阶段进行了rebase，所有使用slide机上Data中的地址，即可的到相同的运行时的地址 (lldb) p/x 0x1000064ec + 0x25ac000 (long) $5 = 0x00000001025b24ec NSLog在第一次执行的会后，会跳到0x00000001025b24ec这个地址指向的函数，执行绑定工作，过掉第一个NSLog之后，会发现Data的值发生了改变 (lldb) x/g 0x00000001025ac000+0xc000 0x1025b8000: 0x000000018932b3c4 查看汇编，发现已经变成了NSLog的地址 (lldb) dis -s 0x000000018932b3c4 Foundation`NSLog: 0x18932b3c4 : pacibsp 0x18932b3c8 : sub sp, sp, #0x20 ; =0x20 0x18932b3cc : stp x29, x30, [sp, #0x10] 0x18932b3d0 : add x29, sp, #0x10 ; =0x10 0x18932b3d4 : adrp x8, 347853 0x18932b3d8 : ldr x8, [x8, #0xe0] 0x18932b3dc : ldr x8, [x8] 0x18932b3e0 : str x8, [sp, #0x8] 然后同样的方法，过掉fishhook之后的NSLog，发现地址有变化了，成为了我们自定义的地址 (lldb) x/g 0x00000001025ac000+0xc000 0x1025b8000: 0x00000001025b1614 (lldb) dis -s 0x00000001025b1614 001--fishhookDemo`my_NSLog: 0x1025b1614 : sub sp, sp, #0x30 ; =0x30 0x1025b1618 : stp x29, x30, [sp, #0x20] 0x1025b161c : add x29, sp, #0x20 ; =0x20 0x1025b1620 : sub x8, x29, #0x8 ; =0x8 0x1025b1624 : mov x9, #0x0 0x1025b1628 : stur xzr, [x29, #-0x8] 0x1025b162c : str x0, [sp, #0x10] 0x1025b1630 : mov x0, x8 汇编层面分析最终流程 源代码： - (void)viewDidLoad { [super viewDidLoad]; NSLog(@\"123\"); NSLog(@\"end\"); } 断点在第一个NSLog，进入汇编代码查看，会发现跳转到一个symbol stub的地址，通过lldb获取程序起始地址0x00000001005fc000 0x100601e38 : bl 0x1006024d4 ; symbol stub for: NSLog // 相减获取在macho中的偏移值 (lldb) p/x 0x1006024d4-0x00000001005fc000 (long) $1 = 0x00000000000064d4 macho中查看地址信息 这里的Data实际上是代码，通过汇编进入调试查看代码，发现最终跳转了一个地址，查看x16的地址 // 这段代码的意思就是去执行懒加载符号表中的地址 001--fishhookDemo`NSLog: -> 0x1006024d4 : nop 0x1006024d8 : ldr x16, #0x5b28 ; (void *)0x0000000100602588 0x1006024dc : br x16 (lldb) register read x16 x16 = 0x0000000100602588 // 获取macho中的偏移地址 (lldb) p/x 0x0000000100602588-0x00000001005fc000 (long) $2 = 0x0000000000006588 发现这个Symbol Stubs代码执行后跳转的是0x0000000000006588 0x0000000000006588在stub helper中执行两行代码，最终跳转到0x6579处执行代码，发现，最终都跳转到0x100008000处。这里的外部符号执行代码最终都是跳转到相同的地址 查看0x8000处，执行的是一个非懒加载绑定的dyld_stub_binder符号，非懒加载符号即是在dyld加载阶段就进行绑定的，这个函数执行后，懒加载符号表中的地址就被改变，下一次调用的时候，经过stub函数，直接就跳转到绑定后的位置了 使用 //创建rebinding 结构体 struct rebinding nslog; nslog.name = \"NSLog\"; nslog.replacement = my_NSLog; //保存NSLog系统函数地址的指针! nslog.replaced = (void *)&sys_nslog; //需求:HOOK NSLog struct rebinding bds[] = {nslog}; rebind_symbols(bds, 1); 源码解析 // Hook的结构体 struct rebinding { const char *name;//需要HOOK的函数名称，C字符串 void *replacement;//新函数的地址 void **replaced;//原始函数地址的指针！ }; // fishhook.c #include \"fishhook.h\" #include #include #include #include #include #include #include #include #ifdef __LP64__ typedef struct mach_header_64 mach_header_t; typedef struct segment_command_64 segment_command_t; typedef struct section_64 section_t; typedef struct nlist_64 nlist_t; #define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64 #else typedef struct mach_header mach_header_t; typedef struct segment_command segment_command_t; typedef struct section section_t; typedef struct nlist nlist_t; #define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT #endif #ifndef SEG_DATA_CONST #define SEG_DATA_CONST \"__DATA_CONST\" #endif struct rebindings_entry { struct rebinding *rebindings; size_t rebindings_nel; struct rebindings_entry *next; }; static struct rebindings_entry *_rebindings_head; static int prepend_rebindings(struct rebindings_entry **rebindings_head, struct rebinding rebindings[], size_t nel) { struct rebindings_entry *new_entry = (struct rebindings_entry *) malloc(sizeof(struct rebindings_entry)); if (!new_entry) { return -1; } new_entry->rebindings = (struct rebinding *) malloc(sizeof(struct rebinding) * nel); if (!new_entry->rebindings) { free(new_entry); return -1; } memcpy(new_entry->rebindings, rebindings, sizeof(struct rebinding) * nel); new_entry->rebindings_nel = nel; new_entry->next = *rebindings_head; *rebindings_head = new_entry; return 0; } static void perform_rebinding_with_section(struct rebindings_entry *rebindings, section_t *section, intptr_t slide, nlist_t *symtab, char *strtab, uint32_t *indirect_symtab) { //nl_symbol_ptr和la_symbol_ptrsection中的reserved1字段指明对应的indirect symbol table起始的index uint32_t *indirect_symbol_indices = indirect_symtab + section->reserved1; //slide+section->addr 就是符号对应的存放函数实现的数组也就是我相应的__nl_symbol_ptr和__la_symbol_ptr相应的函数指针都在这里面了，所以可以去寻找到函数的地址 void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section->addr); //遍历section里面的每一个符号 for (uint i = 0; i size / sizeof(void *); i++) { //找到符号在Indrect Symbol Table表中的值 //读取indirect table中的数据 uint32_t symtab_index = indirect_symbol_indices[i]; if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL || symtab_index == (INDIRECT_SYMBOL_LOCAL | INDIRECT_SYMBOL_ABS)) { continue; } //以symtab_index作为下标，访问symbol table uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx; //获取到symbol_name char *symbol_name = strtab + strtab_offset; //判断是否函数的名称是否有两个字符，为啥是两个，因为函数前面有个_，所以方法的名称最少要1个 bool symbol_name_longer_than_1 = symbol_name[0] && symbol_name[1]; //遍历最初的链表，来进行hook struct rebindings_entry *cur = rebindings; while (cur) { for (uint j = 0; j rebindings_nel; j++) { //这里if的条件就是判断从symbol_name[1]两个函数的名字是否都是一致的，以及判断两个 if (symbol_name_longer_than_1 && strcmp(&symbol_name[1], cur->rebindings[j].name) == 0) { //判断replaced的地址不为NULL以及我方法的实现和rebindings[j].replacement的方法不一致 if (cur->rebindings[j].replaced != NULL && indirect_symbol_bindings[i] != cur->rebindings[j].replacement) { //让rebindings[j].replaced保存indirect_symbol_bindings[i]的函数地址 *(cur->rebindings[j].replaced) = indirect_symbol_bindings[i]; } //将替换后的方法给原先的方法，也就是替换内容为自定义函数地址 indirect_symbol_bindings[i] = cur->rebindings[j].replacement; goto symbol_loop; } } cur = cur->next; } symbol_loop:; } } //回调的最终就是这个函数！ 三个参数：要交换的数组 、 image的头 、 ASLR的偏移 static void rebind_symbols_for_image(struct rebindings_entry *rebindings, const struct mach_header *header, intptr_t slide) { /*dladdr() 可确定指定的address 是否位于构成进程的进址空间的其中一个加载模块（可执行库或共享库）内，如果某个地址位于在其上面映射加载模块的基址和为该加载模块映射的最高虚拟地址之间（包括两端），则认为该地址在加载模块的范围内。如果某个加载模块符合这个条件，则会搜索其动态符号表，以查找与指定的address 最接近的符号。最接近的符号是指其值等于，或最为接近但小于指定的address 的符号。 */ /* 如果指定的address 不在其中一个加载模块的范围内，则返回0 ；且不修改Dl_info 结构的内容。否则，将返回一个非零值，同时设置Dl_info 结构的字段。 如果在包含address 的加载模块内，找不到其值小于或等于address 的符号，则dli_sname 、dli_saddr 和dli_size字段将设置为0 ； dli_bind 字段设置为STB_LOCAL ， dli_type 字段设置为STT_NOTYPE 。 */ //这个dladdr函数就是在程序里面找header Dl_info info; if (dladdr(header, &info) == 0) { return; } //下面就是定义好几个变量，准备从MachO里面去找！ segment_command_t *cur_seg_cmd; segment_command_t *linkedit_segment = NULL; struct symtab_command* symtab_cmd = NULL; struct dysymtab_command* dysymtab_cmd = NULL; //跳过header的大小，找loadCommand uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t); for (uint i = 0; i ncmds; i++, cur += cur_seg_cmd->cmdsize) { cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd->cmd == LC_SEGMENT_ARCH_DEPENDENT) { if (strcmp(cur_seg_cmd->segname, SEG_LINKEDIT) == 0) { linkedit_segment = cur_seg_cmd; } } else if (cur_seg_cmd->cmd == LC_SYMTAB) { symtab_cmd = (struct symtab_command*)cur_seg_cmd; } else if (cur_seg_cmd->cmd == LC_DYSYMTAB) { dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd; } } //如果刚才获取的，有一项为空就直接返回 if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment || !dysymtab_cmd->nindirectsyms) { return; } // Find base symbol/string table addresses //链接时程序的基址 = __LINKEDIT.VM_Address -__LINKEDIT.File_Offset + silde的改变值 uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment->vmaddr - linkedit_segment->fileoff; // printf(\"地址:%p\\n\",linkedit_base); //符号表的地址 = 基址 + 符号表偏移量 nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd->symoff); //字符串表的地址 = 基址 + 字符串表偏移量 char *strtab = (char *)(linkedit_base + symtab_cmd->stroff); // Get indirect symbol table (array of uint32_t indices into symbol table) //动态符号表地址 = 基址 + 动态符号表偏移量 uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd->indirectsymoff); cur = (uintptr_t)header + sizeof(mach_header_t); for (uint i = 0; i ncmds; i++, cur += cur_seg_cmd->cmdsize) { cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd->cmd == LC_SEGMENT_ARCH_DEPENDENT) { //寻找到data段 if (strcmp(cur_seg_cmd->segname, SEG_DATA) != 0 && strcmp(cur_seg_cmd->segname, SEG_DATA_CONST) != 0) { continue; } for (uint j = 0; j nsects; j++) { section_t *sect = (section_t *)(cur + sizeof(segment_command_t)) + j; //找懒加载表 if ((sect->flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) { perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); } //非懒加载表 if ((sect->flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) { perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); } } } } } static void _rebind_symbols_for_image(const struct mach_header *header, intptr_t slide) { rebind_symbols_for_image(_rebindings_head, header, slide); } int rebind_symbols_image(void *header, intptr_t slide, struct rebinding rebindings[], size_t rebindings_nel) { struct rebindings_entry *rebindings_head = NULL; int retval = prepend_rebindings(&rebindings_head, rebindings, rebindings_nel); rebind_symbols_for_image(rebindings_head, (const struct mach_header *) header, slide); if (rebindings_head) { free(rebindings_head->rebindings); } free(rebindings_head); return retval; } int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel) { //prepend_rebindings的函数会将整个 rebindings 数组添加到 _rebindings_head 这个链表的头部 //Fishhook采用链表的方式来存储每一次调用rebind_symbols传入的参数，每次调用，就会在链表的头部插入一个节点，链表的头部是：_rebindings_head int retval = prepend_rebindings(&_rebindings_head, rebindings, rebindings_nel); //根据上面的prepend_rebinding来做判断，如果小于0的话，直接返回一个错误码回去 if (retval next是否为空判断是不是第一次调用。 if (!_rebindings_head->next) { //第一次调用的话，调用_dyld_register_func_for_add_image注册监听方法. //已经被dyld加载的image会立刻进入回调。 //之后的image会在dyld装载的时候触发回调。 _dyld_register_func_for_add_image(_rebind_symbols_for_image); } else { //遍历已经加载的image，进行的hook uint32_t c = _dyld_image_count(); for (uint32_t i = 0; i inlineHook Cydia Substrate Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-25 15:04:21 "},"articles/iOS/renote/10_symbol.html":{"url":"articles/iOS/renote/10_symbol.html","title":"10_符号","keywords":"","body":"符号 间接符号查找过程 fishhook的查找过程图 TODO 去符号&恢复符号 xcode脱符号，strip，两个地方 断点不能来，可以符号断点间接符号，bt显示看不出来方法名 如何恢复？因为虽然去掉了符号，但是因为runtime的原因，仍然包含了类型和方法名，签名等信息 工具：restore-symbol https://github.com/tobefuturer/restore-symbol 使用fishhook防护 自己使用fishhook，hook runtime的一些方法，让别人不能进行方法交换,mehod_exchangeImplementations MonkeyDev issue 266 重签名 Hook->logos monkey内部用的method_setImplementation和method_getImplementation monkey会注入很多动态库，其中就有libsubstrate.dylib，这个库就是用来解析logos，将xm文件解析称为.mm文件 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-25 16:38:58 "},"articles/iOS/xcode/instruments/time_profiler.html":{"url":"articles/iOS/xcode/instruments/time_profiler.html","title":"TimeProfiler","keywords":"","body":"Time Profiler 1、设置profile为debug模式 要不然只能看到方法地址，看不到方法名，没有符号文件进行解析 2、使用 详情面板:在time profiler下主要是看Call Tree和Sample List这两种视图，一般使用Call Tree查看，比较简单明了： Weight：函数运行的时间，这个时间是累积时间 Self：在栈顶次数 Symbol Name：被调用函数的符号信息 Separate by Thread（建议选择）：线程分离,只有这样才能在调用路径中能够清晰看到占用CPU最大的线程.每个线程应该分开考虑。只有这样你才能揪出那些大量占用CPU的\"重\"线程，按线程分开做分析，这样更容易揪出那些吃资源的问题线程。特别是对于主线程，它要处理和渲染所有的接口数据，一旦受到阻塞，程序必然卡顿或停止响应。 Invert Call Tree（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。 Hide Missing Symbols（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。 Hide System Libraries（建议选择）：选上它只会展示与应用有关的符号信息，一般情况下我们只关心自己写的代码所需的耗时，而不关心系统库的CPU耗时。 Flatten Recursion（一般不选）：选上它会将调用栈里递归函数作为一个入口。 Top Functions（可选）：选上它会将最耗时的函数降序排列，而这种耗时是累加的，比如A调用了B，那么A的耗时数是会包含B的耗时数。 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-04-23 11:48:41 "},"articles/java/fundation.html":{"url":"articles/java/fundation.html","title":"Java基础编程","keywords":"","body":"Java 参考文献 MacOS Java环境配置 如何在苹果M1芯片 (Apple Silicon) 上安装 JDK 环境 Mac M1 Java 开发环境配置 Java8在线API文档 IDEA文档 鱼皮java学习路线 鱼皮github学习路线 java基础 java编译 一个java文件只能有一个public类，并且以这个public类命名 一个java文件可以有多个其他的类，javac编译后，每一个类都会生成对应的类名.class文件 非public类也可由main方法，直接运行生成的.class文件就可以运行指定的类.class的main方法 基本数据类型 public class PrimitiveTypeTest { public static void main(String[] args) { // byte System.out.println(\"基本类型：byte 二进制位数：\" + Byte.SIZE); System.out.println(\"包装类：java.lang.Byte\"); System.out.println(\"最小值：Byte.MIN_VALUE=\" + Byte.MIN_VALUE); System.out.println(\"最大值：Byte.MAX_VALUE=\" + Byte.MAX_VALUE); System.out.println(); // short System.out.println(\"基本类型：short 二进制位数：\" + Short.SIZE); System.out.println(\"包装类：java.lang.Short\"); System.out.println(\"最小值：Short.MIN_VALUE=\" + Short.MIN_VALUE); System.out.println(\"最大值：Short.MAX_VALUE=\" + Short.MAX_VALUE); System.out.println(); // int System.out.println(\"基本类型：int 二进制位数：\" + Integer.SIZE); System.out.println(\"包装类：java.lang.Integer\"); System.out.println(\"最小值：Integer.MIN_VALUE=\" + Integer.MIN_VALUE); System.out.println(\"最大值：Integer.MAX_VALUE=\" + Integer.MAX_VALUE); System.out.println(); // long System.out.println(\"基本类型：long 二进制位数：\" + Long.SIZE); System.out.println(\"包装类：java.lang.Long\"); System.out.println(\"最小值：Long.MIN_VALUE=\" + Long.MIN_VALUE); System.out.println(\"最大值：Long.MAX_VALUE=\" + Long.MAX_VALUE); System.out.println(); // float System.out.println(\"基本类型：float 二进制位数：\" + Float.SIZE); System.out.println(\"包装类：java.lang.Float\"); System.out.println(\"最小值：Float.MIN_VALUE=\" + Float.MIN_VALUE); System.out.println(\"最大值：Float.MAX_VALUE=\" + Float.MAX_VALUE); System.out.println(); // double System.out.println(\"基本类型：double 二进制位数：\" + Double.SIZE); System.out.println(\"包装类：java.lang.Double\"); System.out.println(\"最小值：Double.MIN_VALUE=\" + Double.MIN_VALUE); System.out.println(\"最大值：Double.MAX_VALUE=\" + Double.MAX_VALUE); System.out.println(); // char System.out.println(\"基本类型：char 二进制位数：\" + Character.SIZE); System.out.println(\"包装类：java.lang.Character\"); // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台 System.out.println(\"最小值：Character.MIN_VALUE=\" + (int) Character.MIN_VALUE); // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台 System.out.println(\"最大值：Character.MAX_VALUE=\" + (int) Character.MAX_VALUE); } } /** 基本类型：byte 二进制位数：8 包装类：java.lang.Byte 最小值：Byte.MIN_VALUE=-128 最大值：Byte.MAX_VALUE=127 基本类型：short 二进制位数：16 包装类：java.lang.Short 最小值：Short.MIN_VALUE=-32768 最大值：Short.MAX_VALUE=32767 基本类型：int 二进制位数：32 包装类：java.lang.Integer 最小值：Integer.MIN_VALUE=-2147483648 最大值：Integer.MAX_VALUE=2147483647 基本类型：long 二进制位数：64 包装类：java.lang.Long 最小值：Long.MIN_VALUE=-9223372036854775808 最大值：Long.MAX_VALUE=9223372036854775807 基本类型：float 二进制位数：32 包装类：java.lang.Float 最小值：Float.MIN_VALUE=1.4E-45 最大值：Float.MAX_VALUE=3.4028235E38 基本类型：double 二进制位数：64 包装类：java.lang.Double 最小值：Double.MIN_VALUE=4.9E-324 最大值：Double.MAX_VALUE=1.7976931348623157E308 基本类型：char 二进制位数：16 包装类：java.lang.Character 最小值：Character.MIN_VALUE=0 最大值：Character.MAX_VALUE=65535 * 基本数据类型转换 自动类型转换 强制类型转换 程序控制结构 switch For-Each循环 for(声明语句 : 表达式) { //代码句子 } public class Hello { public static void main(String[] args) { int[] nums = {1,2,3,4,5}; for(int num : nums) { System.out.println(num); } } } 包装类 将基础数据类型封装成一个对象，所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。 布尔类型的包装类是Boolean，char的包装类是Character 这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。 public class Hello { public static void main(String[] args) { Integer x = 5; x = x + 10; System.out.println(x); } } Math类 Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。 Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。 public class Hello { public static void main(String[] args) { System.out.println(\"90 度的正弦值：\" + Math.sin(Math.PI/2)); System.out.println(\"0度的余弦值：\" + Math.cos(0)); System.out.println(\"60度的正切值：\" + Math.tan(Math.PI/3)); System.out.println(\"1的反正切值： \" + Math.atan(1)); System.out.println(\"π/2的角度值：\" + Math.toDegrees(Math.PI/2)); System.out.println(Math.PI); } } String String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了 如果需要对字符串做很多修改，那么应该选择使用 StringBuffer & StringBuilder 类 StringBuffer 和 StringBuilder 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。 然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类 public class RunoobTest{ public static void main(String args[]){ StringBuilder sb = new StringBuilder(10); sb.append(\"Runoob..\"); System.out.println(sb); sb.append(\"!\"); System.out.println(sb); StringBuffer sBuffer = new StringBuffer(\"菜鸟教程官网：\"); sBuffer.append(\"www\"); sBuffer.append(\".runoob\"); sBuffer.append(\".com\"); System.out.println(sBuffer); } } Array 封装了一些操作数据的方法 import java.util.Arrays; public class Hello { public static void main(String[] args) { int[] nums = new int[3]; Arrays.fill(nums, 3); for (int i : nums) { System.out.println(i); } int[] height = {1,3,5,6,7,8,10,78,98,109}; int index = Arrays.binarySearch(height, 3); System.out.println(index); } } Date import java.util.Date; public class Hello { public static void main(String[] args) { Date date = new Date(); System.out.println(date); } } SimpleDateFormat import java.text.SimpleDateFormat; import java.util.Date; public class Hello { public static void main(String[] args) { Date date = new Date(); System.out.println(date); SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(format.format(date)); } } Sleep public class Hello { public static void main(String[] args) { try { System.out.println(\"start\"); Thread.sleep(1000 * 3); System.out.println(\"end\"); } catch (Exception e) { System.out.println(e.getMessage()); } } } Calender import java.util.Calendar; public class Hello { public static void main(String[] args) { Calendar c = Calendar.getInstance();//返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象 默认是当前日期 c.set(2009, 6 - 1, 25); c.set(Calendar.DATE, 27); System.out.println(c); } } 正则 java.util.regex 包主要包括以下三个类： Pattern 类： pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher 类： Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 PatternSyntaxException： PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 import java.util.regex.Pattern; public class Hello { public static void main(String[] args) { String content = \"I am noob from runoob.com.\"; String pattern = \".*runoob.*\"; boolean isMatch = Pattern.matches(pattern, content); System.out.println(isMatch); } } Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2022-02-27 23:22:37 "},"articles/java/oop.html":{"url":"articles/java/oop.html","title":"Java面向对象","keywords":"","body":"Java面向对象 方法 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2022-02-27 23:25:02 "},"articles/opensource/webkit/webkitcompile.html":{"url":"articles/opensource/webkit/webkitcompile.html","title":"WebKit编译","keywords":"","body":"WebKit 编译 参考自：Xcode编译WebKit 1.下载WebKit源码 1)进入https://webkit.org/ 2)点击页面的 Get Started 进入新页面，如下图所示 3)点击 Getting the code 进入新页面，如下图所示 4)在源码下载页面，有多种下载方式，包括直接下载代码zip包，通过SVN下载，通过Git下载。这里选择使用Git的方式进行下载，在控制台运行下面的命令。下载量有点大，约6G左右，耐心等待即可，下载完成会生成一个WebKit目录。 我是从这个地址下载的： git clone git://git.webkit.org/WebKit.git WebKit 2.Xcode编译 1)Embedded Builds 下载的WebKit目录里面有一个Tools/Scripts目录，这里面有各种脚本，包括使用命令行编译WebKit的脚本build-webkit，但是使用Xcode编译的时候用不着它。另一个重要的脚本就是configure-xcode-for-embedded-development，在控制台运行如下命令: sudo Tools/Scripts/configure-xcode-for-embedded-development 之所以需要这个脚本，是因为iOS属于嵌入式平台，编译给iOS嵌入式平台的WebKit需要一些命令行工具，上面的脚本就是让Xcode能够构建这些命令行工具的。否则，在编译诸如JavaScriptCore的时候，就会报如下错误:‘com.apple.product-type.tool’, but there’s no such product type for the embedded platform。 需要注意的是，运行完上面脚本之后，最好重启一下Xcode。 2)更改Xcode配置 WebKit源码下载完成之后，用Xcode打开里面的WebKit.xcworkspace。默认情况下，WebKit.xcworkspace里面的各个工程都是macos配置，需要进行更改， 左边红框就是需要更改的工程，右边红框是更改后的配置。 3)设置构建产物存储位置 选择Xcode的File菜单->Workspace Settings...打开Workspace设置窗口: 选择Advanced...按钮，打开如下窗口，按红框所示进行配置: 4)编译 选中 All Source选项，选择一个模拟器，然后点击Xcode的构建按钮开始构建。剩下的就是耐心等待，等待激动人心的 Build Success 提示(可能编译完成后有一个关于MiniBrowser工程的弹窗，直接关闭即可，不影响编译)。 3.创建调试工程 编译好WebKit之后，我们的目的当然是进行调试，以便用来学习WebKit的源码。那么，如何才能让我们新建的工程里面，使用自己编译的WebKit.framework，而不是系统自带的呢？ 1)用Xcode新建一个新的Project，示例里面是TestWKWebView，并将这个Project添加到WebKit.xcworkspace。 2)设置TestWKWebView的scheme 如下图所示，点击Edit Scheme，打开设置窗口 在Edit设置窗口选择 Arguments选项，在 Environment Variables里面添加一项，Name:DYLD_FRAMEWORK_PATH Value:Path_To_WebKit/DerivedData/WebKitBuild/Debug-iphonesimulator，这里的Path_To_WebKit就是WebKit目录所在路径。一个方便的方法是，在Xcode的WebKit工程打开Product目录，找到WebKit.framework然后Show in Finder，将包含WebKit.framework的目录复制下来即可。 做好上面的设置之后，就可以编写测试程序，然后打上断点,看是否能够成功断在WebKit的源码里面， 如果你能够成功进入断点，那么恭喜你，你已经能够调试WebKit源码了。 参考文献 Xcode编译WebKit http://webkit.org/ Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-11 21:31:25 "},"articles/opensource/llvm/llvmcompile.html":{"url":"articles/opensource/llvm/llvmcompile.html","title":"LLVM编译","keywords":"","body":"LLVM编译 参考自：LLVM编译踩坑 获取源码 git clone --depth 1 https://github.com/llvm/llvm-project.git 配置和构建 LLVM 和 Clang # 向~/.zshrc文件导入 OSX_COMMANDLINE_SDKROOT变量（指定为 # \"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk\"） $ echo 'export OSX_COMMANDLINE_SDKROOT=\"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk\"' >> ~/.zshrc $ source ~/.zshrc 如果/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk 路径不存在，则重新安装CommandLineTools xcode-select --install 或者直接官网下载 安装Cmake brew install cmake 编译 # 参数 2 代表电脑 CPU 核心数，自行查看 cmake -G Xcode -j 2 -DLLVM_ENABLE_PROJECTS='libcxx;libc++;clang;lldb' -DLLDB_USE_SYSTEM_DEBUGSERVER=ON -DLLDB_TEST_COMPILER=clang++ -DCMAKE_OSX_SYSROOT=$OSX_COMMANDLINE_SDKROOT ../llvm 编译出现CMakeCache.txt文件报错、表示已经编译过、出现了缓存文件。去 /llvm-Xcode/llvm-project/build/ 目录下删除CMakeCache.txt即可 编译完成后的项目打开项目： 选择Manually 方式、Automatically方式在增删target的时候会很卡很卡 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-11 21:43:07 "},"articles/algorithm/算法.html":{"url":"articles/algorithm/算法.html","title":"数据结构与算法","keywords":"","body":"算法 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-01-28 22:13:07 "},"articles/algorithm/geektime_note/01_复杂度.html":{"url":"articles/algorithm/geektime_note/01_复杂度.html","title":"复杂度","keywords":"","body":"复杂度 时间复杂度分析 时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。 只关注循环执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 几种常见时间复杂度实例分析 对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。 我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。 当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。 O(1) int i = 8; int j = 6; int sum = i + j; 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。 O(logn)、O(nlogn) // 2为底 i=1; while (i 实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？ 我们知道，对数之间是可以互相转换的，log3n 就等于 log32 log2n，所以 O(log3n) = O(C log2n)，其中 C=log32 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。 如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。 O(m+n)、O(m*n) int cal(int m, int n) { int sum_1 = 0; int i = 1; for (; i 从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。 针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)T2(n) = O(f(m) f(n))。 空间复杂度分析 空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。 我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。 TODO 浅析最好、最坏、平均、均摊时间复杂度 最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity） 参考文献 极客时间-数据结构与算法之美 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-01-28 22:13:07 "},"articles/algorithm/geektime_note/02_数组.html":{"url":"articles/algorithm/geektime_note/02_数组.html","title":"数组","keywords":"","body":"数组 来自极客时间《数据结构与算法之美》的学习笔记 数组概念 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 特点 第一是线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。 而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。 第二个是连续的内存空间和相同类型的数据。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。 我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址： a[i]_address = base_address + i * data_type_size 这里我要特别纠正一个“错误”。我在面试的时候，常常会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。 低效的“插入”和“删除” 插入和删除移动插入位置或者删除位置之后的所有元素 如何优化？ 对于插入： 如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。 对于删除： 在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？ 每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。 注意数据越界 容器能否完全替代数组？ 针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？ 这里我拿 Java 语言来举例。如果你是 Java 工程师，几乎天天都在用 ArrayList，对它应该非常熟悉。那它与数组相比，到底有哪些优势呢？ 我个人觉得，ArrayList 最大的优势就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是支持动态扩容。 数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。 如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。 不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。 比如我们要从数据库中取出 10000 条数据放入 ArrayList。我们看下面这几行代码，你会发现，相比之下，事先指定数据大小可以省掉很多次内存申请和数据搬移操作。 对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。 为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？ index代表和起始位置的偏移量 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-01-28 22:13:07 "},"articles/algorithm/geektime_note/03_链表.html":{"url":"articles/algorithm/geektime_note/03_链表.html","title":"链表","keywords":"","body":"链表 单链表 循环链表 双向链表 双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效 对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据 空间换时间 当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。 链表和数组 数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。 CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。 对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。 数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。 当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的 一般默认扩容到1.5倍大小 回文字符串问题：如何判断一个字符串是否是回文字符串 快慢指针定位中间节点 从中间节点对后半部分逆序 前后半部分比较，判断是否为回文 后半部分逆序复原 LRU缓存淘汰算法 常见的缓存策略：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used） 最近最少使用的最先淘汰 如何优雅的写出链表代码？6大学习技巧 一、理解指针或引用的含义 含义：将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用）。 示例： p—>next = q; 表示p节点的后继指针存储了q节点的内存地址。 p—>next = p—>next—>next; 表示p节点的后继指针存储了p节点的下下个节点的内存地址。 二、警惕指针丢失和内存泄漏（单链表） 插入节点 在节点a和节点b之间插入节点x，b是a的下一节点，，p指针指向节点a，则造成指针丢失和内存泄漏的代码：p—>next = x;x—>next = p—>next; 显然这会导致x节点的后继指针指向自身。 正确的写法是2句代码交换顺序，即：x—>next = p—>next; p—>next = x; 删除节点 在节点a和节点b之间删除节点b，b是a的下一节点，p指针指向节点a：p—>next = p—>next—>next; 三、利用“哨兵”简化实现难度 什么是“哨兵”？ 链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。 未引入“哨兵”的情况 如果在p节点后插入一个节点，只需2行代码即可搞定： new_node—>next = p—>next; p—>next = new_node; 但，若向空链表中插入一个节点，则代码如下： if(head == null){ head = new_node; } 如果要删除节点p的后继节点，只需1行代码即可搞定： p—>next = p—>next—>next; 但，若是删除链表的最有一个节点（链表中只剩下这个节点），则代码如下： if(head—>next == null){ head = null; } 从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。 引入“哨兵”的情况 “哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。 “哨兵”还有哪些应用场景？ 这个知识有限，暂时想不出来呀！但总结起来，哨兵最大的作用就是简化边界条件的处理。 四、重点留意边界条件处理 经常用来检查链表是否正确的边界4个边界条件： 如果链表为空时，代码是否能正常工作？ 如果链表只包含一个节点时，代码是否能正常工作？ 如果链表只包含两个节点时，代码是否能正常工作？ 代码逻辑在处理头尾节点时是否能正常工作？ 五、举例画图，辅助思考 核心思想：释放脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。 六、多写多练，没有捷径 5个常见的链表操作： 1.单链表反转（LeetCode206） 2.链表中环的检测（LeetCode141） 3.两个有序链表合并（LeetCode21） 4.删除链表倒数第n个节点（LeetCode19） 5.求链表的中间节点（LeetCode876） 代码总结 反转链表 // 反转链表 迭代 func reverseList(_ head: ListNode?) -> ListNode? { var _pre: ListNode? var _head = head while _head != nil { let tmp = _head?.next _head?.next = _pre _pre = _head _head = tmp } return _pre } // 反转链表 递归 func reverseList(_ head: ListNode?) -> ListNode? { if head == nil || head?.next == nil { return head } let p = reverseList(head?.next) head?.next?.next = head head?.next = nil return p } 链表中环的检测 快慢指针 func hasCycle(_ head: ListNode?) -> Bool { var slow = head var fast = head while fast?.next != nil { slow = slow?.next fast = fast?.next?.next if slow === fast { return true } } return false } 两个有序链表合并（LeetCode21） func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? { var stub : ListNode? = ListNode(0) var newHeader = stub var left = l1 var right = l2 while left != nil && right != nil { if left!.val > right!.val { stub!.next = right right = right!.next } else { stub!.next = left left = left!.next } stub = stub!.next } stub!.next = left != nil ? left : right return newHeader!.next } 删除链表倒数第n个节点 固定间隔往后遍历，注意是删除点的前一个元素 func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? { var preHead : ListNode? = ListNode(0) preHead!.next = head var stub = preHead var pHead = head var pN = n while pHead != nil { pHead = pHead!.next pN -= 1 if pN 求链表的中间节点 快慢指针求中间节点 func middleNode(_ head: ListNode?) -> ListNode? { var slow = head var fast = head while fast?.next != nil { slow = slow?.next fast = fast?.next?.next } return slow } Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-03 10:09:38 "},"articles/algorithm/geektime_note/04_栈.html":{"url":"articles/algorithm/geektime_note/04_栈.html","title":"栈","keywords":"","body":"栈 栈是一种“操作受限”的线性表，只允许在一端插入和删除数据 当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。 如何实现一个“栈”？ 栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。 支持动态扩容的顺序栈 使用可以扩容的容器作为底层存储数据模型。 通过这个例子的实战分析，也印证了前面讲到的，均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度 O 都是 O(1)，只有在个别时刻才会退化为 O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 O(1)。 不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。 栈在函数调用中的应用 栈在表达式求值中的应用 编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。 如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。 我将 3+5*8-6 这个表达式的计算过程画成了一张图，你可以结合图来理解我刚讲的计算过程。 栈在括号匹配中的应用 我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。 当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。 如何实现浏览器的前进、后退功能 我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。 双向链表也可以 数组也可以 问题 我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？ 为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？ 其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。 从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。 我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？ 内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。 内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。 静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。 栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。 堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。 LeetCode 有效的括号 class Solution { func isValid(_ s: String) -> Bool { var tmp : [Character] = [] for character in s { if character == \"(\" || character == \"{\" || character == \"[\" { tmp.append(character) } else { if character == \")\" && tmp.last == \"(\" { tmp.removeLast() } else if character == \"}\" && tmp.last == \"{\" { tmp.removeLast() } else if character == \"]\" && tmp.last == \"[\" { tmp.removeLast() } else { return false } } } return tmp.isEmpty } } 最小栈 辅助栈存储当前栈顶一一对应的最小值 class MinStack { var data = [Int]() var minData = [Int.max] var count = 0 /** initialize your data structure here. */ init() { } func push(_ x: Int) { data.append(x) count += 1 var minValue = min(minData.last!,x) minData.append(minValue) } func pop() { guard count > 0 else { return } data.removeLast() count -= 1 minData.removeLast() } func top() -> Int { guard count > 0 else { return Int.max } return data.last! } func getMin() -> Int { guard count > 0 else { return Int.max } return minData.last! } } 用栈实现队列 class MyQueue { var data = [Int]() /** Initialize your data structure here. */ init() { } /** Push element x to the back of queue. */ func push(_ x: Int) { data.append(x) } /** Removes the element from in front of queue and returns that element. */ func pop() -> Int { return data.removeFirst() } /** Get the front element. */ func peek() -> Int { return data.first! } /** Returns whether the queue is empty. */ func empty() -> Bool { return data.isEmpty } } 比较含退格的字符串 class Solution { func backspaceCompare(_ S: String, _ T: String) -> Bool { let _S = self.formatString(S) let _T = self.formatString(T) return _S == _T } func formatString(_ S: String) -> String { var data = [Character]() for (index,value) in S.enumerated() { if value == \"#\" { if data.isEmpty { continue } else { data.removeLast() } } else { data.append(value) } } return String(data) } } leetcode上关于栈的题目大家可以先做224,682,496. Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/05_队列.html":{"url":"articles/algorithm/geektime_note/05_队列.html","title":"队列","keywords":"","body":"队列 如何理解“队列”？ 先进者先出，这就是典型的“队列”。 基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。 队列跟栈一样，也是一种操作受限的线性表数据结构。 队列的实现 队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。 顺序队列中，当tail指针指向末尾的时候，一般进行数据搬移 循环队列 环形队列 难点：确定好队空和队满的判定条件。 当队满时，(tail+1)%n=head 当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。 阻塞队列和并发队列 阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。 线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。 实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/06_递归.html":{"url":"articles/algorithm/geektime_note/06_递归.html","title":"递归","keywords":"","body":"递归 一、什么是递归？ 递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。 方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。 基本上，所有的递归问题都可以用递推公式来表示，比如 f(n) = f(n-1) + 1; f(n) = f(n-1) + f(n-2); f(n)=n*f(n-1); 二、为什么使用递归？递归的优缺点？ 优点：代码的表达力很强，写起来简洁。 缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。 三、什么样的问题可以用递归解决呢？ 一个问题只要同时满足以下3个条件，就可以用递归来解决： 问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题。 问题与子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 四、如何实现递归？ 递归代码编写 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。 递归代码理解 对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。 那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。 因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 五、递归常见问题及解决方案 警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。 警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。 六、如何将递归改写为非递归代码？ 笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。 例如： f(x) =f(x-1)+1 int f(int n) { int ret = 1; for (int i = 2; i f(1) = 1; f(2) = 2; f(n) = f(n-1)+f(n-2) int f(int n) { if (n == 1) return 1; if (n == 2) return 2; int ret = 0; int pre = 2; int prepre = 1; for (int i = 3; i Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/07_排序_1.html":{"url":"articles/algorithm/geektime_note/07_排序_1.html","title":"排序（一）","keywords":"","body":"排序 一、几种经典排序算法及其时间复杂度级别 冒泡、插入、选择 O(n^2) 基于比较 快排、归并 O(nlogn) 基于比较 计数、基数、桶 O(n) 不基于比较 二、如何分析一个排序算法？ 学习排序算法的思路？明确原理、掌握实现以及分析性能。 如何分析排序算法性能？从执行效率、内存消耗以及稳定性3个方面分析排序算法的性能。 执行效率：从以下3个方面来衡量 1）最好情况、最坏情况、平均情况时间复杂度 2）时间复杂度的系数、常数、低阶：排序的数据量比较小时考虑 3）比较次数和交换（或移动）次数 内存消耗：通过空间复杂度来衡量。针对排序算法的空间复杂度，引入原地排序的概念，原地排序算法就是指空间复杂度为O(1)的排序算法。 稳定性：如果待排序的序列中存在值等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就说明这个排序算法时稳定的。 三、冒泡排序 排序原理 1）冒泡排序只会操作相邻的两个数据。 2）对相邻两个数据进行比较，看是否满足大小关系要求，若不满足让它俩互换。 3）一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。 4）优化：若某次冒泡不存在数据交换，则说明已经达到完全有序，所以终止冒泡。 代码实现 // 冒泡排序 static func bubbleSort(_ arr:inout [Int]) { for i in 0.. arr[j+1] { arr.swapAt(j, j+1) } } } } 性能分析 1）执行效率：最小时间复杂度、最大时间复杂度、平均时间复杂度 最小时间复杂度：数据完全有序时，只需进行一次冒泡操作即可，时间复杂度是O(n)。 最大时间复杂度：数据倒序排序时，需要n次冒泡操作，时间复杂度是O(n^2)。 平均时间复杂度：通过有序度和逆序度来分析。 什么是有序度？ 有序度是数组中具有有序关系的元素对的个数，比如[2,4,3,1,5,6]这组数据的有序度就是11，分别是[2,4][2,3][2,5][2,6][4,5][4,6][3,5][3,6][1,5][1,6][5,6]。同理，对于一个倒序数组，比如[6,5,4,3,2,1]，有序度是0；对于一个完全有序的数组，比如[1,2,3,4,5,6]，有序度为n*(n-1)/2，也就是15，完全有序的情况称为满有序度。 什么是逆序度？逆序度的定义正好和有序度相反。核心公式：逆序度=满有序度-有序度。 排序过程，就是有序度增加，逆序度减少的过程，最后达到满有序度，就说明排序完成了。 冒泡排序包含两个操作原子，即比较和交换，每交换一次，有序度加1。不管算法如何改进，交换的次数总是确定的，即逆序度。 对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏的情况初始有序度为0，所以要进行n(n-1)/2交换。最好情况下，初始状态有序度是n(n-1)/2，就不需要进行交互。我们可以取个中间值n(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。 换句话说，平均情况下，需要n(n-1)/4次交换操作，比较操作可定比交换操作多，而复杂度的上限是O(n^2)，所以平均情况时间复杂度就是O(n^2)。 以上的分析并不严格，但很实用，这就够了。 2）空间复杂度：每次交换仅需1个临时变量，故空间复杂度为O(1)，是原地排序算法。 3）算法稳定性：如果两个值相等，就不会交换位置，故是稳定排序算法。 四、插入排序 算法原理 首先，我们将数组中的数据分为2个区间，即已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间中的元素一直有序。重复这个过程，直到未排序中元素为空，算法结束。 代码实现 // 插入排序 static func insertionSort(_ arr: inout [Int]) { if arr.count = 0 { if arr[j] > value { arr[j+1] = arr[j] } else { break } j -= 1 } arr[j+1] = value } } 性能分析 1）时间复杂度：最好、最坏、平均情况 如果要排序的数组已经是有序的，我们并不需要搬移任何数据。只需要遍历一遍数组即可，所以时间复杂度是O(n)。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，因此时间复杂度是O(n^2)。而在一个数组中插入一个元素的平均时间复杂都是O(n)，插入排序需要n次插入，所以平均时间复杂度是O(n^2)。 2）空间复杂度：从上面的代码可以看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，是原地排序算法。 3）算法稳定性：在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现的元素的后面，这样就保持原有的顺序不变，所以是稳定的。 五、选择排序 选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。 选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。 选择排序是一种不稳定的排序算法 六、总结 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/07_排序_2.html":{"url":"articles/algorithm/geektime_note/07_排序_2.html","title":"排序（二）","keywords":"","body":"排序 归并排序和快速排序。这两种排序算法适合大规模的数据排序 归并排序和快速排序都用到了分治思想 分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。 分治思想跟我们前面讲的递归思想很像,分治算法一般都是用递归来实现的。 分治是一种解决问题的处理思想，递归是一种编程技巧 归并排序 归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。 归并排序的递推公式 //递推公式： merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r)) //终止条件： p >= r //不用再继续分解 伪代码 // 归并排序算法, A是数组，n表示数组大小 merge_sort(A, n) { merge_sort_c(A, 0, n-1) } // 递归调用函数 merge_sort_c(A, p, r) { // 递归终止条件 if p >= r then return // 取p到r之间的中间位置q q = (p+r) / 2 // 分治递归 merge_sort_c(A, p, q) merge_sort_c(A, q+1, r) // 将A[p...q]和A[q+1...r]合并为A[p...r] merge(A[p...r], A[p...q], A[q+1...r]) } // 合并 merge(A[p...r], A[p...q], A[q+1...r]) { var i := p，j := q+1，k := 0 // 初始化变量i, j, k var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组 while i 遗留问题：用哨兵优化 复杂度 稳定排序 最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。 空间复杂度O(n) 代码实现 // 归并排序 static func mergeSort(_ arr:inout [Int]) { self.merge_sort_c(&arr, 0, arr.count - 1) } static func merge_sort_c(_ arr:inout [Int],_ startIndex: Int,_ endIndex:Int) { guard startIndex 快速排序 快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。 我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。 根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。 递推公式 //递推公式： quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r) //终止条件： p >= r 伪代码 // 快速排序，A是数组，n表示数组的大小 quick_sort(A, n) { quick_sort_c(A, 0, n-1) } // 快速排序递归函数，p,r为下标 quick_sort_c(A, p, r) { if p >= r then return q = partition(A, p, r) // 获取分区点 quick_sort_c(A, p, q-1) quick_sort_c(A, q+1, r) } // 分组 partition(A, p, r) { pivot := A[r] i := p for j := p to r-1 do { if A[j] 分组过程： 复杂度 不稳定 最好情况时间复杂度： O(nlogn) 最坏情况时间复杂度：O(n^2) 空间复杂度：O(1) 代码实现 // 快速排序 static func quickSort(_ arr:inout [Int]) { self.quick_sort_c(&arr, 0, arr.count - 1) } static func quick_sort_c(_ arr:inout [Int],_ startIndex:Int,_ endIndex:Int) { guard startIndex Int { var i = startIndex let pValue = arr[endIndex] for j in startIndex...endIndex { if arr[j] Int { var tmpLittle = [Int]() var tmpLarge = [Int]() let pValue = arr[endIndex] for i in startIndex.. 归并和快排的区别 快排在拆分时排序，归并是在合并时排序。 问题求解 O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。 题解： 我们选择数组区间 A[0...n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0...n-1]原地分区，这样数组就分成了三部分，A[0...p-1]、A[p]、A[p+1...n-1]。 如果 p+1=K，那 A[p]就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 A[p+1...n-1]区间，我们再按照上面的思路递归地在 A[p+1...n-1]这个区间内查找。同理，如果 K 如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+...+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。 课后思考 现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？ 题解：每次从各个文件中取一条数据，在内存中根据数据时间戳构建一个最小堆，然后每次把最小值给写入新文件，同时将最小值来自的那个文件再出来一个数据，加入到最小堆中。这个空间复杂度为常数，但没能很好利用1g内存，而且磁盘单个读取比较慢，所以考虑每次读取一批数据，没了再从磁盘中取，时间复杂度还是一样O(n)。 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/07_排序_3.html":{"url":"articles/algorithm/geektime_note/07_排序_3.html","title":"排序（三）","keywords":"","body":"排序 一、线性排序算法介绍 线性排序算法包括桶排序、计数排序、基数排序。 线性排序算法的时间复杂度为O(n)。 此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。（桶内的元素还是需要进行比较排序算法的） 对排序数据的要求很苛刻，重点掌握此3种排序算法的适用场景。 二、桶排序（Bucket sort） 算法原理： 1）将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序或者归并排序。 2）桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。 使用条件 1）要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。 2）数据在各个桶之间分布是均匀的。 适用场景 1）桶排序比较适合用在外部排序中。 2）外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。 应用案例 1）需求描述： 有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序 但内存有限，仅几百MB 2）解决思路： 扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。 第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。 每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。 将100个小文件依次放入内存并用快排排序。 所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。 3）注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。 三、计数排序（Counting sort） 算法原理 1）计数其实就是桶排序的一种特殊情况。 2）当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶 3）每个桶内的数据值都是相同的，就省掉了桶内排序的时间。 代码实现 // 计数排序 static func countingSort(_ arr:inout [Int]) { guard arr.count > 1 else { return } // 查找数据范围 var max = arr[0] for i in arr { if max = 0 { tmp[countingArr[arr[index]] - 1] = arr[index] countingArr[arr[index]] = countingArr[arr[index]] - 1 index -= 1 } // 遍历tmp，将元素放入arr中 for (index,value) in tmp.enumerated() { arr[index] = value } } 案例分析： 假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。 使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。 C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。 对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。 数组R[8] = [0，0，2，2，3，3，3，5]存储考生名次。那么如何得到R[8]的呢？ 从后到前依次扫描数组A，比如扫描到3时，可以从数组C中取出下标为3的值7，也就是说，到目前为止，包括自己在内，分数小于等于3的考生有7个，也就是说3是数组R的第7个元素（也就是数组R中下标为6的位置）。当3放入数组R后，小于等于3的元素就剩下6个了，相应的C[3]要减1变成6。 以此类推，当扫描到第二个分数为3的考生时，就会把它放入数组R中第6个元素的位置（也就是下标为5的位置）。当扫描完数组A后，数组R内的数据就是按照分数从小到大排列的了。 使用条件 1）只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序； 2）计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数； 3）比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。 四、基数排序（Radix sort） 算法原理（以排序10万个手机号为例来说明） 1）比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。 2）借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。 3）经过11次排序后，手机号码就变为有序的了。 4）每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。 使用条件 1）要求数据可以分割独立的“位”来比较； 2）位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了； 3）每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。 五、思考 如何根据年龄给100万用户数据排序？ 根据年龄给 100 万用户排序，就类似按照成绩给 50 万考生排序。我们假设年龄的范围最小 1 岁，最大不超过 120 岁。我们可以遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。这样就得到了按照年龄排序的 100 万用户数据。 对D，a，F，B，c，A，z这几个字符串进行排序，要求将其中所有小写字母都排在大写字母前面，但是小写字母内部和大写字母内部不要求有序。比如经过排序后为a，c，z，D，F，B，A，这个如何实现呢？如果字符串中处理大小写，还有数字，将数字放在最前面，又该如何解决呢？ 根据ascii分桶 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/08_二分查找_1.html":{"url":"articles/algorithm/geektime_note/08_二分查找_1.html","title":"二分查找（一）","keywords":"","body":"二分查找 二分查找 二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。 复杂度O(logn) 代码实现 非递归 // arr 有序int数组，target 查找的数 返回target下标，不存在时返回-1 static func search(_ arr: [Int],_ target: Int) -> Int { var left = 0 var right = arr.count - 1 while left >1) if arr[mid] == target { return mid } else if arr[mid] > target { right = mid - 1 } else { left = mid + 1 } } return -1 } 递归 // 通过递归二分查找 static func recursionSearch(_ arr: [Int],_ target: Int) -> Int { return self.recursion_search_c(arr, target, 0, arr.count - 1); } static func recursion_search_c(_ arr: [Int],_ target: Int,_ left:Int, _ right:Int) -> Int{ let mid = left + ((right - left)>>1) while left target { return self.recursion_search_c(arr, target, left, mid - 1) } else { return self.recursion_search_c(arr, target, mid + 1, right) } } return -1 } 注意事项 循环退出条件 注意是 low mid 的取值 实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)>>1)。因为相比除法运算来说，计算机处理位运算要快得多。 low 和 high 的更新 low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出。 二分查找应用场景的局限性 首先，二分查找依赖的是顺序表结构，简单点说就是数组。 其次，二分查找针对的是有序数据。 再次，数据量太小不适合二分查找，序遍历就足够了。 最后，数据量太大也不适合二分查找。 二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。 注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。 课后思考 如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。 求平方根可以用二分查找或牛顿迭代法 如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？如果你自己推导一下，你就会深刻地认识到，为何我们会选择用数组而不是链表来实现二分查找了。 假设链表长度为n，二分查找每次都要找到中间点(计算中忽略奇偶数差异): 第一次查找中间点，需要移动指针n/2次； 第二次，需要移动指针n/4次； 第三次需要移动指针n/8次； ...... 以此类推，一直到1次为值 总共指针移动次数(查找次数) = n/2 + n/4 + n/8 + ...+ 1，这显然是个等比数列，根据等比数列求和公式：Sum = n - 1. 最后算法时间复杂度是：O(n-1)，忽略常数，记为O(n)，时间复杂度和顺序查找时间复杂度相同 但是稍微思考下，在二分查找的时候，由于要进行多余的运算，严格来说，会比顺序查找时间慢 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/08_二分查找_2.html":{"url":"articles/algorithm/geektime_note/08_二分查找_2.html","title":"二分查找（二）","keywords":"","body":"二分查找 查找第一个值等于给定值的元素 代码实现 // 烧脑实现 // 查找第一个值等于给定值的元素 返回元素的index static func firstEqualSearch(_ arr: [Int],_ target: Int) -> Int { var left = 0, right = arr.count - 1 while left >1) if arr[mid] >= target { right = mid - 1 } else { left = mid + 1 } } if left Int { var left = 0, right = arr.count - 1 while left >1) if arr[mid] > target { right = mid - 1 } else if arr[mid] 查找最后一个值等于给定值的元素 代码实现 // 查找最后一个等于给定值的元素 返回元素的index static func lastEqualSearch2(_ arr: [Int],_ target: Int) -> Int { var left = 0, right = arr.count - 1 let count = arr.count while left >1) if arr[mid] > target { right = mid - 1 } else if arr[mid] 查找第一个大于等于给定值的元素 代码实现 // 查找第一个大于等于给定值的元素 static func firstGreatThanSearch(_ arr:[Int], _ target: Int) -> Int { let count = arr.count var left = 0, right = count - 1 while left >1) if arr[mid] >= target { if mid == 0 || arr[mid - 1] 查找最后一个小于等于给定值的元素 代码实现 // 查找最后一个小于等于给定值的元素 static func lastLessThanSearch(_ arr:[Int], _ target: Int) -> Int { let count = arr.count var left = 0, right = count - 1 while left >1) if arr[mid] target { return mid } left = mid + 1 } else { right = mid - 1 } } return -1 } 如何快速定位出一个 IP 地址的归属地？ 可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。如何来排序呢？我们知道，IP 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。 然后，这个问题就可以转化为我刚讲的第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。 当我们要查询某个 IP 归属地时，我们可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。 内容小结 凡是用二分查找能解决的，绝大部分我们更倾向于用散列表或者二叉查找树。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。那二分查找真的没什么用处了吗？ 上一节讲的求“值等于给定值”的二分查找确实不怎么会被用到，二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。比如今天讲的这几种变体问题，用其他数据结构，比如散列表、二叉树，就比较难实现了。 注意：终止条件、区间上下界更新方法、返回值选择 课后思考 https://leetcode-cn.com/problems/search-in-rotated-sorted-array/ 思路：查找分界点，然后在确定分区中进行二分查找 class Solution { func search(_ nums: [Int], _ target: Int) -> Int { let count = nums.count // 查找中间螺旋点 小于前面元素 var seperateIndex = 0 var index = 1 while index >1) if nums[mid] == target { return mid } else if nums[mid] nums[seperateIndex - 1] { return -1 } // seperate...count-1 if target >1) if nums[mid] == target { return mid } else if nums[mid] >1) if nums[mid] == target { return mid } else if nums[mid] Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/09_跳表.html":{"url":"articles/algorithm/geektime_note/09_跳表.html","title":"跳表","keywords":"","body":"跳表 如何理解“跳表”？ 带索引的有序链表 用跳表查询到底有多快？ 当每两个结点会抽出一个结点作为上一级索引的结点，那么在跳表中查询任意数据的时间复杂度就是 O(logn)。相当于基于链表的二分查找 跳表是不是很浪费内存？ 空间复杂度还是 O(n) 与索引的间隔有关 实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。 高效的动态插入和删除 跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。 跳表索引动态更新 当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。 跳表是通过随机函数来维护前面提到的“平衡性”。 我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。 为什么 Redis 要用跳表来实现有序集合，而不是红黑树？ Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。 Redis 中的有序集合支持的核心操作主要有下面这几个： 插入一个数据；删除一个数据； 查找一个数据； 按照区间查找数据（比如查找值在[100, 356]之间的数据）； 迭代输出有序序列。 其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。 当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。 不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。 参考资料 Redis 为什么用跳表而不用平衡树？ Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/10_散列表_1.html":{"url":"articles/algorithm/geektime_note/10_散列表_1.html","title":"散列表（一）","keywords":"","body":"散列表 散列思想 散列表的英文叫“Hash Table”，我们平时也叫它“哈希表”或者“Hash 表” 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。 散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。 散列函数 散列函数，顾名思义，它是一个函数。我们可以把它定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。 该如何构造散列函数呢？我总结了三点散列函数设计的基本要求： 散列函数计算得到的散列值是一个非负整数； 如果 key1 = key2，那 hash(key1) == hash(key2)； 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。 散列冲突 再好的散列函数也无法避免散列冲突。那究竟该如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。 开放寻址法 开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。 那如何重新探测新的位置呢？ 线性探测（Linear Probing）。 插入：如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。 查找：在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。 删除：我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。 当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。 对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，二次探测（Quadratic probing）和双重散列（Double hashing）。 二次探测 跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22…… 双重散列 不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。 不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。 装载因子的计算公式是： 散列表的装载因子=填入表中的元素个数/散列表的长度 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。 链表法 链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。 当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？ 实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。 总结 散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。散列表两个核心问题是散列函数设计和散列冲突解决。散列冲突有两种常用的解决方法，开放寻址法和链表法。散列函数设计的好坏决定了散列冲突的概率，也就决定散列表的性能。 思考题 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？ 遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。 如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？ 以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/10_散列表_2.html":{"url":"articles/algorithm/geektime_note/10_散列表_2.html","title":"散列表（二）","keywords":"","body":"散列表 如何打造一个工业级水平的散列表？ 如何设计散列函数？ 首先，散列函数的设计不能太复杂。过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能。 其次，散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。 散列函数的设计方法还有很多，比如直接寻址法、平方取中法、折叠法、随机数法等，这些你只要了解就行了，不需要全都掌握。 装载因子过大了怎么办？ 装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。 针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置。 插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。 如何避免低效的扩容？ 为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。 当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。 这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。 通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。 如何选择冲突解决方法？ 开放寻址法 优势：开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。 劣势：用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。 总结：当数据量比较小、装载因子小的时候，适合采用开放寻址法。 链表法 优势：利用率高、对大装载因子的容忍度更高 劣势：消耗内存、链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。 改造：将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。 总结：基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。 何为一个工业级的散列表？ 工业级的散列表应该具有哪些特性？ 支持快速地查询、插入、删除操作； 内存占用合理，不能浪费过多的内存空间； 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。 如何实现这样一个散列表呢？ 设计一个合适的散列函数； 定义装载因子阈值，并且设计动态扩容策略； 选择合适的散列冲突解决方法。 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/10_散列表_3.html":{"url":"articles/algorithm/geektime_note/10_散列表_3.html","title":"散列表（三）","keywords":"","body":"散列表 LRU 缓存淘汰算法 需要淘汰一个数据的时候，我们就直接将链表头部的结点删除 当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 O(n)。 往缓存中添加一个数据； 从缓存中删除一个数据； 在缓存中查找一个数据。 这三个操作都要涉及“查找”操作，如果单纯地采用链表的话，时间复杂度只能是 O(n)。如果我们将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 O(1)。具体的结构就是下面这个样子： 前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。 这整个过程涉及的查找操作都可以通过散列表来完成。 总结：主要是利用散列表的O(1)查找复杂度 Redis 有序集合 为什么散列表和链表经常一块使用？ 散列表无序，配合链表进行有序访问 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/11_哈希算法.html":{"url":"articles/algorithm/geektime_note/11_哈希算法.html","title":"哈希算法","keywords":"","body":"哈希算法 什么是哈希算法？ 将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。 优秀哈希算法要求： 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）； 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同； 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小； 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。 常见应用场景： 安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。 应用一：安全加密 最常用于加密的哈希算法是 MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和 SHA（Secure Hash Algorithm，安全散列算法）。 其他常用比如 DES（Data Encryption Standard，数据加密标准）、AES（Advanced Encryption Standard，高级加密标准）。 应用二：唯一标识 类似签名 应用三：数据校验 还是类似签名 应用四：散列函数 散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。 字典攻击 针对字典攻击，我们可以引入一个盐（salt），跟用户的密码组合在一起，增加密码的复杂度。我们拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。不过我这里想多说一句，我认为安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，只是增加攻击的成本而已。 区块链使用的是哪种哈希算法吗？是为了解决什么问题而使用的呢？ 区块链是一块块区块组成的，每个区块分为两部分：区块头和区块体。 区块头保存着 自己区块体 和 上一个区块头 的哈希值。 因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。 区块链使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。 应用五：负载均衡 会话粘滞（session sticky）：同一个用户，同一个客户端，一次会话的所有请求都发送到同一个服务器上。 我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。 这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。 应用六：数据分片 如何统计“搜索关键词”出现的次数？ 假如我们有 1T 的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数，该怎么做呢？ 我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。 这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。 实际上，这里的处理过程也是 MapReduce 的基本设计思想。 如何快速判断图片是否在图库中？ 假设现在我们的图库中有 1 亿张图片，如何快速判断图片是否在图库中？（数据量巨大，需要分片处理） 通过哈希的方式建立了一个索引层，两层索引的架构，根据图片，通过哈希算出可能落在哪一台机器上，然后再去该机器上进行查找。 我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。 当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。 应用七：分布式存储 需要多台设备进行海量数据存储，需要分布式存储数据 该如何决定将哪个数据放到哪个机器上呢？我们可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。 当设备扩容时，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生雪崩效应，压垮数据库。 解决：一致性哈希算法 参考：白话解析：一致性哈希算法 consistent hashing Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/12_二叉树.html":{"url":"articles/algorithm/geektime_note/12_二叉树.html","title":"二叉树","keywords":"","body":"二叉树 树（Tree） 父节点 子节点 兄弟节点：父节点是同一个节点 根节点：没有父节点的节点叫做根节点 节点的高度、深度、层 二叉树（Binary Tree） 每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。 满二叉树：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做满二叉树 完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树 满二叉树是一种特殊的完全二叉树 如何表示（或者存储）一棵二叉树 二叉链式存储法 需要额外存储空间存放指针 基于数组的顺序存储法 把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 i = 2 的位置，右子节点存储在 2 i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 i = 2 2 = 4 的位置，右子节点存储在 2 i + 1 = 2 2 + 1 = 5 的位置。 如果节点 X 存储在数组中下标为 i 的位置，下标为 2 i 的位置存储的就是左子节点，下标为 2 i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。 完全二叉树仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间 堆其实就是一种完全二叉树，最常用的存储方式就是数组。 二叉树的遍历 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。 void preOrder(Node* root) { if (root == null) return; print root // 此处为伪代码，表示打印root节点 preOrder(root->left); preOrder(root->right); } void inOrder(Node* root) { if (root == null) return; inOrder(root->left); print root // 此处为伪代码，表示打印root节点 inOrder(root->right); } void postOrder(Node* root) { if (root == null) return; postOrder(root->left); postOrder(root->right); print root // 此处为伪代码，表示打印root节点 } 二叉树遍历的时间复杂度是 O(n)。 二叉查找树（Binary Search Tree） 二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。 二叉查找树的查找操作 如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。 public class BinarySearchTree { private Node tree; public Node find(int data) { Node p = tree; while (p != null) { if (data p.data) p = p.right; else return p; } return null; } public static class Node { private int data; private Node left; private Node right; public Node(int data) { this.data = data; } } } 二叉查找树的插入操作 新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。 如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。 public void insert(int data) { if (tree == null) { tree = new Node(data); return; } Node p = tree; while (p != null) { if (data > p.data) { if (p.right == null) { p.right = new Node(data); return; } p = p.right; } else { // data 二叉查找树的删除操作 第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55。 第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13。 第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。 public void delete(int data) { Node p = tree; // p指向要删除的节点，初始化指向根节点 Node pp = null; // pp记录的是p的父节点 while (p != null && p.data != data) { pp = p; if (data > p.data) p = p.right; else p = p.left; } if (p == null) return; // 没有找到 // 要删除的节点有两个子节点 if (p.left != null && p.right != null) { // 查找右子树中最小节点 Node minP = p.right; Node minPP = p; // minPP表示minP的父节点 while (minP.left != null) { minPP = minP; minP = minP.left; } p.data = minP.data; // 将minP的数据替换到p中 p = minP; // 下面就变成了删除minP了 pp = minPP; } // 删除节点是叶子节点或者仅有一个子节点 Node child; // p的子节点 if (p.left != null) child = p.left; else if (p.right != null) child = p.right; else child = null; if (pp == null) tree = child; // 删除的是根节点 else if (pp.left == p) pp.left = child; else pp.right = child; } 二叉查找树的其他操作 二叉查找树中还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点。 查找最大节点---直接向右遍历到底 查找最小节点---直接向左遍历到底 查找前驱节点---找到当前节点，对其左子树进行向右遍历到底 查找后继节点---找到当前节点，对其右子树进行向左遍历到底 中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。 支持重复数据的二叉查找树 第一种方法比较容易。二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。 第二种方法比较不好理解，不过更加优雅。每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。 当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。 对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。 二叉查找树的时间复杂度分析 时间复杂度其实都跟树的高度成正比，也就是 O(height) 完全二叉树的高度小于等于 log2n 在二叉查找树中，查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比。两个极端情况的时间复杂度分别是 O(n) 和 O(logn)，分别对应二叉树退化成链表的情况和完全二叉树。 二叉查找树存在性能退化问题，使用平衡二叉查找树。平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。 问题：有了如此高效的散列表，为什么还需要二叉树？ 第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。 第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。 第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。 第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。 最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。 问题：求出一棵给定二叉树的确切高度呢？ 递归法，根节点高度=max(左子树高度，右子树高度)+1 class Solution { func maxDepth(_ root: TreeNode?) -> Int { if root == nil { return 0 } var leftDepth = maxDepth(root!.left) var rightDepth = maxDepth(root!.right) return max(leftDepth,rightDepth)+1 } } Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 10:48:01 "},"articles/algorithm/geektime_note/13_红黑树.html":{"url":"articles/algorithm/geektime_note/13_红黑树.html","title":"红黑树","keywords":"","body":"红黑树 红黑树的演变和2-3树 什么是“平衡二叉查找树”？ 平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。 AVL 树，它严格符合平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。 如何定义一棵“红黑树”？ 红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树。 根节点是黑色的； 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据； 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；（相邻结点指的是同一路经上的结点） 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点； 为什么说红黑树是“近似平衡”的？ 红黑树的高度近似 2logn 所以，红黑树的高度只比高度平衡的 AVL 树的高度（logn）仅仅大了一倍，在性能上，下降得并不多。（这样推导出来的结果不够精确，实际上红黑树的性能更好。） 为什么工程中都用红黑树 AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。 红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。 所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。 总结 红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。 因为红黑树是一种性能非常稳定的二叉查找树，所以，在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到它。不过，它实现起来比较复杂，如果自己写代码实现，难度会有些高，这个时候，我们其实更倾向用跳表来替代它。 问题 动态数据结构支持动态的数据插入、删除、查找操作，除了红黑树，我们前面还学习过哪些呢？能对比一下各自的优势、劣势，以及应用场景吗？ 散列表：插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。 跳表：插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。 红黑树：插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。其实跳表更佳，但红黑树已经用于很多地方了。 红黑树的左旋和右旋 插入操作的平衡调整 红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。 如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。 如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。 CASE 1：如果关注节点是 a，它的叔叔节点 d 是红色 将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色； 将关注节点 a 的祖父节点 c 的颜色设置成红色； 关注节点变成 a 的祖父节点 c；如果节点c不是根节点，就转到case2或3；如果c是根节点，则将c转成黑色，就调整结束了。 跳到 CASE 2 或者 CASE 3。 CASE 2：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点 关注节点变成节点 a 的父节点 b； 围绕新的关注节点\bb 左旋； 跳到 CASE 3。 CASE 3：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点 围绕关注节点 a 的祖父节点 c 右旋； 将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。 调整结束。 删除操作的平衡调整 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-25 21:26:13 "},"articles/algorithm/swift_algorithm/":{"url":"articles/algorithm/swift_algorithm/","title":"Swift中相关的数据结构和算法","keywords":"","body":"Swift中相关的数据结构和算法 平时使用Swift进行算法相关操作，这里总结一些在LeetCode中使用到的Swift相关的数据结构 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-01-28 22:13:07 "},"articles/algorithm/swift_algorithm/String.html":{"url":"articles/algorithm/swift_algorithm/String.html","title":"字符串","keywords":"","body":"字符串的常见操作 String与基本数据类型转换 基本数据类型转String 直接使用String的初始化方法进行转换 print(String(\"a\")) // a print(String(1)) // 1 print(String(1.5)) // 1.5 print(String(false)) // false String转基本数据类型 print(Character(\"a\")) print(Int(\"1\") ?? -1) print(Double(\"1.34\") ?? 0.0) print(Bool(\"false\") ?? -1) String与ASCII的相互转化 比如 97->a、a->97 字符串转ASCII数组 unicodeScalars let str = \"abcdef\" let arr = str.unicodeScalars for i in arr { print(i.value) //97 98 99 100 101 102 } 单个字符与ASCII互转 let a : Character = \"a\" print(a.unicodeScalars.first?.value ?? 0) print(a.asciiValue ?? 0) let b : Character = Character(UnicodeScalar(97)) print(b) String和数组 数组转Stirng 如果是字符串数组，可使用数组的join方法 let arr1 : [String] = [\"1\",\"23\",\"45\"] let str1 = arr1.joined() print(str1) 如果是字符数组，可以使用字符串的字符数组初始化方法 let arr2 : [Character] = [\"1\",\"2\",\"5\"] let str2 = String(arr2) print(str2) 如果是其他类型 比如 Int 或者 Double let arr3 = [1,3,4] let str3 = arr3.reduce(\"\"){ $0 + String($1) } 字符串转字符数组 [Character] let str = \"abcde\" let arr = Array(str) print(arr) String 与 集合 可以用来过滤String中的重复字符 集合转String 类似数组操作 注意无序 let set : Set = [\"a\",\"b\",\"c\",\"a\",\"c\"] let str = String(set) print(str) let set1 : Set = [\"1\",\"2\",\"3\",\"哈哈\",\"哈哈\"] let str1 = set1.joined() print(str1) String 转集合 可以去除重复字符 let str = \"112233哈哈\" let set = Set(str) print(set) Character的操作 let c : Character = \"c\" print(c.uppercased()) print(c.isUppercase) print(c.isLowercase) print(c.isLetter) print(c.isNumber) print(c.asciiValue ?? 0) 字符串的操作 字符串格式化 let str = String(format: \"%d个哈哈\", 15) print(str) 访问字符串中的字符 var str1 = \"abcdefg\" print(str1[str1.startIndex]) print(str1[str1.index(before: str1.endIndex)]) 字符串删除 str1.removeFirst() print(str1) str1.remove(at: str1.index(str1.startIndex, offsetBy: 1)) print(str1) str1.removeLast() print(str1) str1.removeFirst(2) print(str1) str1.removeLast(2) print(str1) str1 = \"Hello World\" str1.removeSubrange(str1.index(after: str1.startIndex)...str1.index(str1.startIndex, offsetBy: 3)) print(str1) if let range = str1.range(of: \"orl\") { str1.removeSubrange(range) } print(str1) str1.removeAll() print(str1) 字符串比较 let str1 = \"bbc\" let str2 = \"adbc\" let compare = str1.compare(str2) print(compare.rawValue) #endif 字符串包含 let str1 = \"Hello\" let str2 = \"Hello World\" if str2.contains(str1) { print(\"contains\") } 字符串分割 let str1 = \"Hello World\" let ret = str1.split(separator: \" \") print(ret) 字符串截取子串 let str1 = \"Hello World\" // 截取头部 print(str1.prefix(2)) // 截取尾部 print(str1.suffix(2)) // 截取指定index print(str1[str1.index(str1.startIndex, offsetBy: 2)...str1.index(str1.startIndex, offsetBy: 5)]) // 指定range let range = str1.range(of: \"llo W\") if let r = range { print(str1[r.lowerBound.. 字符串替换 let str1 = \"Hello World\" let str2 = str1.replacingOccurrences(of:\"He\",with:\"St\") print(str2) 字符串插入 var str1 = \"Hello World\" str1.insert(\"A\", at: str1.startIndex) print(str1) str1.insert(contentsOf:\"666\",at: str1.endIndex) print(str1) Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-01-28 22:13:07 "},"articles/algorithm/swift_algorithm/Array.html":{"url":"articles/algorithm/swift_algorithm/Array.html","title":"数组","keywords":"","body":"数组 初始化 let arr : [Int] = [1,2,3] let arr1 : [Any] = [1,\"2\"] let arr3 = Array(repeating: -1, count: 10) let arr4 = [Int]() let arr5 : Array = [] 访问指定位置数据 let arr = [1,3,4,5,6,7] print(arr[1])//下标访问 print(arr.first!)//可选值 print(arr.last!)//可选值 遍历 let arr = [1,3,4,5,6,7] // 不需要index for value in arr { print(value) } // 需要index for i in 0.. 添加 var arr = [1,3,4] arr.append(4) print(arr) // [1, 3, 4, 4] arr.append(contentsOf: [4,5,6]) print(arr) // [1, 3, 4, 4, 4, 5, 6] let ret = stride(from: 10, to: 20, by: 2).map{$0} print(ret) // [10, 12, 14, 16, 18] let ret2 = stride(from: 10, through: 20, by: 2).map{$0} print(ret2) // [10, 12, 14, 16, 18, 20] arr.append(contentsOf: stride(from: 10, to: 20, by: 3)) print(arr) //[1, 3, 4, 4, 4, 5, 6, 10, 13, 16, 19] 插入 var arr = [1,3,4] arr.insert(7, at: 1) print(arr) // [1, 7, 3, 4] arr.insert(contentsOf: [2,3,4], at: 1) print(arr) // [1, 2, 3, 4, 7, 3, 4] 删除 var arr = [1, 2, 3, 4, 7, 3, 4, 1, 2, 3, 4, 7] arr.removeFirst() print(arr)//[2, 3, 4, 7, 3, 4, 1, 2, 3, 4, 7] arr.removeLast() print(arr)//[2, 3, 4, 7, 3, 4, 1, 2, 3, 4] arr.removeFirst(2) print(arr)//[4, 7, 3, 4, 1, 2, 3, 4] arr.removeLast(3) print(arr)//[4, 7, 3, 4, 1] arr.remove(at: 2) print(arr)//[4, 7, 4, 1] arr.removeSubrange(0...2) print(arr)//[1] arr.removeAll() print(arr)//[] let arr1 = [1, 2, 3, 4, 7, 3] print(arr1.drop{$0 运算符操作 let arr = [1, 2, 3, 4, 7, 3] var ret = arr + [5] print(ret)//[1, 2, 3, 4, 7, 3, 5] ret = [6] + arr print(ret)//[6, 1, 2, 3, 4, 7, 3] //reduce可以利用这个操作进行魔法 属性&常用操作 let arr = [1, 2, 3, 4, 7, 3] print(arr.count) // 6 print(arr.isEmpty) // false print(arr.capacity) // 6 print(arr.min()!) // 1 print(arr.max()!) // 7 print(arr.contains(3))//true print(arr.lastIndex(of: 2)!)//1 print(arr.firstIndex(of: 4)!)//3 高阶函数 Map 对集合进行循环，并对集合中的每个元素采取相同的操作。 //Map let arr = [1,3,4,5,6,7] var newArr = arr.map({(value:Int)->Int in return value + 1 }) print(newArr)//[2, 4, 5, 6, 7, 8] newArr = arr.map{$0+1}//尾随闭包 print(newArr)//[2, 4, 5, 6, 7, 8] compactMap 执行转换，解包所有可选选项并丢弃nil值 let arr = [\"1\",\"2\",\"3\",\"a\",\"b\",\"6\"] var newArr = arr.map{Int($0)} print(newArr) // [Optional(1), Optional(2), Optional(3), nil, nil, Optional(6)] let newArr2 = arr.compactMap{Int($0)} print(newArr2) // [1, 2, 3, 6] flatMap 对于集合的集合，进行降纬处理 flatMap还有一种使用方式可以去除nil，目前已经废弃，由compactMap替代 let arr = [[1,3,4],[4,5,6]] print(arr.flatMap{$0}) // [1, 3, 4, 4, 5, 6] filter 使用规则过滤集合 let arr = [1,3,4,5,6,7] print(arr.filter{$0>4}) //[5,6,7] reduce 归纳合并成一个元素 let arr = [1,3,4,5,6,7] print(arr.reduce(0){$0+$1}) // 26 sort 排序 let arr = [4,1,8,3,2,10] print(arr.sorted{$1 reverse 翻转 var arr = [4,1,8,3,2,10] arr.reverse() print(arr) let arr1 = [4,1,8,3,2,10] print(arr1.reversed()) // 注意类型 for value in arr1.reversed() { print(value) } for (index,value) in arr1.enumerated().reversed() { print(\"\\(index),\\(value)\") } Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-01-28 22:13:07 "},"articles/algorithm/swift_algorithm/Dictionary.html":{"url":"articles/algorithm/swift_algorithm/Dictionary.html","title":"字典","keywords":"","body":"字典 初始化 let dic : Dictionary = [:] let dic1 : [String : Int] = [:] let dic2 = [String : Int]() var dic3 = Dictionary() 常用属性 let dic = [String:Int]() print(dic.isEmpty) // true print(dic.count) // 0 所有keys values let dic = [\"name\":\"lisi\",\"class\":\"3\"] print(dic.keys) // [\"name\", \"class\"] print(dic.values) // [\"lisi\", \"3\"] 遍历 遍历的输入是一个元组 let dic = [\"name\":\"lisi\",\"class\":\"3\"] for (key,value) in dic { print(\"\\(key),\\(value)\") } dic.forEach{(key,value) in print(\"\\(key),\\(value)\")} dic.map{print(\"\\($0.0),\\($0.1)\")} 字典取值 字典取值是可选值 let dic = [\"name\":\"lisi\",\"class\":\"3\"] // 字典取值是可选值 print(dic[\"name\"] ?? \"\") // list print(dic[\"age\"]) // nil 增删改 var dic = [\"name\":\"lisi\",\"class\":\"3\",\"book\":\"yuwen\"] dic[\"name\"] = \"zhangsan\" print(dic) //[\"class\": \"3\", \"name\": \"zhangsan\", \"book\": \"yuwen\"] dic.updateValue(\"wangwu\", forKey: \"name\") print(dic)//[\"class\": \"3\", \"name\": \"wangwu\", \"book\": \"yuwen\"] dic[\"name\"] = nil print(dic)//[\"class\": \"3\", \"book\": \"yuwen\"] dic.removeValue(forKey:\"book\") print(dic)//[\"class\": \"3\"] Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-01-28 22:13:07 "},"articles/algorithm/swift_algorithm/Set.html":{"url":"articles/algorithm/swift_algorithm/Set.html","title":"集合","keywords":"","body":"集合 去重 初始化 let set1 : Set = [\"1\",\"2\",\"2\",\"3\"] print(set1) // [\"3\", \"1\", \"2\"] // 从序列初始化（数组、字符串等） let set2 = Set([\"1\",\"2\",\"2\",\"3\"]) print(set2) 常用方法 var set : Set = [\"1\",\"2\",\"2\",\"3\",\"哈哈\",\"呵呵\",\"&#x1F336;\"] print(set.isEmpty) print(set.count) print(set.contains(\"&#x1F336;\")) print(set.max()!,set.min()!) for value in set { print(value) } // 插入 set.insert(\"&#x1F634;\") print(set) set.remove(\"2\") print(set) 交集 并集 补集 差集 var set1 : Set = [\"1\",\"2\",\"2\",\"3\",\"哈哈\",\"呵呵\",\"&#x1F336;\"] var set2 : Set = [\"1\",\"7\",\"2\",\"3\",\"嘻嘻\",\"呵呵\",\"☺\"] // 交集 print(set1.intersection(set2)) //[\"呵呵\", \"2\", \"3\", \"1\"] // 并集 print(set1.union(set2)) //[\"7\", \"哈哈\", \"3\", \"☺\", \"呵呵\", \"&#x1F336;\", \"1\", \"嘻嘻\", \"2\"] // 补集 set1中有而set2中没有的 print(set1.subtracting(set2)) // [\"哈哈\", \"&#x1F336;\"] // 差集 并集-交集=差集 相互没有的 print(set1.symmetricDifference(set2)) Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-01-28 22:13:07 "},"articles/algorithm/js_algorithm/":{"url":"articles/algorithm/js_algorithm/","title":"JavaScript中相关的数据结构和算法","keywords":"","body":"JavaScript中相关的数据结构和算法 平时使用JavaScript进行算法相关操作，这里总结一些在LeetCode中使用到的JavaSCript相关的数据结构 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-06-05 21:51:41 "},"articles/algorithm/js_algorithm/String.html":{"url":"articles/algorithm/js_algorithm/String.html","title":"字符串","keywords":"","body":"字符串的常见操作 JavaScript中，字符串是不可变的 JavaScript中，所有字符串都使用UTF-16编码 大写字母对应的ASCII范围为：65~90 小写字母对应的ASCII范围为：97~122 基本操作 字符串可以包含在单引号、双引号或反引号中： let single = 'single-quoted'; let double = \"double-quoted\"; let backticks = `backticks`; 单引号和双引号基本相同。但是，反引号允许我们通过 ${…} 将任何表达式嵌入到字符串中： function sum(a, b) { return a + b; } alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3. 使用反引号的另一个优点是它们允许字符串跨行： let guestList = `Guests: * John * Pete * Mary `; alert(guestList); // 客人清单，多行 字符串长度 alert( `My\\n`.length ); // 3 访问字符 let str = `Hello`; // 第一个字符 alert( str[0] ); // H alert( str.charAt(0) ); // H // 最后一个字符 alert( str[str.length - 1] ); // o 遍历字符串 for..of for (let char of \"Hello\") { alert(char); // H,e,l,l,o（char 变为 \"H\"，然后是 \"e\"，然后是 \"l\" 等） } 改变大小写 alert( 'Interface'.toUpperCase() ); // INTERFACE alert( 'Interface'.toLowerCase() ); // interface 查找字符串 str.indexOf(substr, pos)：它从给定位置 pos 开始，在 str 中查找 substr，如果没有找到，则返回 -1，否则返回匹配成功的位置。 lastIndexOf：和indexOf类型，从结尾开始搜索 let str = 'Widget with id'; alert( str.indexOf('Widget') ); // 0，因为 'Widget' 一开始就被找到 alert( str.indexOf('widget') ); // -1，没有找到，检索是大小写敏感的 alert( str.indexOf(\"id\") ); // 1，\"id\" 在位置 1 处（……idget 和 id） let str = 'Widget with id'; alert( str.indexOf('id', 2) ) // 12 includes、startWith、endWith str.includes(subStr,pos) alert( \"Widget with id\".includes(\"Widget\") ); // true alert( \"Hello\".includes(\"Bye\") ); // false alert( \"Midget\".includes(\"id\") ); // true alert( \"Midget\".includes(\"id\", 3) ); // false, 从位置 3 开始没有 \"id\" alert( \"Widget\".startsWith(\"Wid\") ); // true，\"Widget\" 以 \"Wid\" 开始 alert( \"Widget\".endsWith(\"get\") ); // true，\"Widget\" 以 \"get\" 结束 获取子串 str.slice(start [, end]) let str = \"stringify\"; alert( str.slice(0, 5) ); // 'strin'，从 0 到 5 的子字符串（不包括 5） alert( str.slice(0, 1) ); // 's'，从 0 到 1，但不包括 1，所以只有在 0 处的字符 // 如果没有第二个参数，slice 会一直运行到字符串末尾： let str = \"stringify\"; alert( str.slice(2) ); // 从第二个位置直到结束 // start/end 也有可能是负值。它们的意思是起始位置从字符串结尾计算： let str = \"stringify\"; // 从右边的第四个位置开始，在右边的第一个位置结束 alert( str.slice(-4, -1) ); // 'gif' str.substring(start [, end]) 返回字符串在 start 和 end 之间 的部分。 这与 slice 几乎相同，但它允许 start 大于 end。 不支持负参数。 let str = \"stringify\"; // 这些对于 substring 是相同的 alert( str.substring(2, 6) ); // \"ring\" alert( str.substring(6, 2) ); // \"ring\" // ……但对 slice 是不同的： alert( str.slice(2, 6) ); // \"ring\"（一样） alert( str.slice(6, 2) ); // \"\"（空字符串） str.substr(start [, length]) 返回字符串从 start 开始的给定 length 的部分。 let str = \"stringify\"; alert( str.substr(2, 4) ); // 'ring'，从位置 2 开始，获取 4 个字符 // 第一个参数可能是负数，从结尾算起： let str = \"stringify\"; alert( str.substr(-4, 2) ); // 'gi'，从第 4 位获取 2 个字符 字符串比较 str.codePointAt(pos) ：返回unicode编码 // 不同的字母有不同的代码 alert( \"z\".codePointAt(0) ); // 122 alert( \"Z\".codePointAt(0) ); // 90 String.fromCodePoint(code)：通过code创建字符串 alert( String.fromCodePoint(90) ); // Z 用 \\u 后跟十六进制代码，通过这些代码添加 unicode 字符： // 在十六进制系统中 90 为 5a alert( '\\u005a' ); // Z 字符和ASCII转换 let str = \"abc\" console.log(str.charCodeAt(0)) // 97 console.log(String.fromCharCode(97)) // a Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-06-15 12:21:56 "},"articles/algorithm/js_algorithm/Array.html":{"url":"articles/algorithm/js_algorithm/Array.html","title":"数组","keywords":"","body":"数组 定义数组 let arr = new Array(); let arr = []; var arr = [1, 2, 3.14, 'Hello', null, true]; length 直接给Array的length赋一个新的值会导致Array大小的变化： var arr = [1, 2, 3.14, 'Hello', null, true]; arr.length; // 6 var arr = [1, 2, 3]; arr.length; // 3 arr.length = 6; arr; // arr变为[1, 2, 3, undefined, undefined, undefined] arr.length = 2; arr; // arr变为[1, 2] 基本操作 如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化： var arr = ['A', 'B', 'C']; arr[1] = 99; arr; // arr现在变为['A', 99, 'C'] var arr = [1, 2, 3]; arr[5] = 'x'; arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] 从尾部添加和删除 var arr = [1, 2]; arr.push('A', 'B'); // 返回Array新的长度: 4 arr; // [1, 2, 'A', 'B'] arr.pop(); // pop()返回'B' arr; // [1, 2, 'A'] arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次 arr; // [] arr.pop(); // 空数组继续pop不会报错，而是返回undefined arr; // [] 从头部添加和删除 var arr = [1, 2]; arr.unshift('A', 'B'); // 返回Array新的长度: 4 arr; // ['A', 'B', 1, 2] arr.shift(); // 'A' arr; // ['B', 1, 2] arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次 arr; // [] arr.shift(); // 空数组继续shift不会报错，而是返回undefined arr; // [] 搜索 indexOf/lastIndexOf 和 includes arr.indexOf(item, from) 从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1。 arr.lastIndexOf(item, from) —— 和上面相同，只是从右向左搜索。 arr.includes(item, from) —— 从索引 from 开始搜索 item，如果找到则返回 true（译注：如果没找到，则返回 false）。 let arr = [1, 0, false]; alert( arr.indexOf(0) ); // 1 alert( arr.indexOf(false) ); // 2 alert( arr.indexOf(null) ); // -1 alert( arr.includes(1) ); // true 搜索 find 和 findIndex 找到具有特定条件的对象 let result = arr.find(function(item, index, array) { // 如果返回 true，则返回 item 并停止迭代 // 对于假值（falsy）的情况，则返回 undefined }); 如果它返回 true，则搜索停止，并返回 item。如果没有搜索到，则返回 undefined。 // 例如，我们有一个存储用户的数组，每个用户都有 id 和 name 字段。让我们找到 id == 1 的那个用户： let users = [ {id: 1, name: \"John\"}, {id: 2, name: \"Pete\"}, {id: 3, name: \"Mary\"} ]; let user = users.find(item => item.id == 1); alert(user.name); // John arr.findIndex 方法（与 arr.find 方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 -1。 过滤 filter 返回的是所有匹配元素组成的数组 let results = arr.filter(function(item, index, array) { // 如果 true item 被 push 到 results，迭代继续 // 如果什么都没找到，则返回空数组 }); let users = [ {id: 1, name: \"John\"}, {id: 2, name: \"Pete\"}, {id: 3, name: \"Mary\"} ]; // 返回前两个用户的数组 let someUsers = users.filter(item => item.id 转换数组 map let result = arr.map(function(item, index, array) { // 返回新值而不是当前元素 }) let lengths = [\"Bilbo\", \"Gandalf\", \"Nazgul\"].map(item => item.length); alert(lengths); // 5,7,6 子数组 slice 截取Array的部分元素，然后返回一个新的Array： var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C'] arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] 注意到slice()的起止参数包括开始索引，不包括结束索引。 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; var aCopy = arr.slice(); aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G'] aCopy === arr; // false 排序 Sort sort()方法会直接对Array进行修改，它返回的结果仍是当前Array sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序： var arr = ['B', 'C', 'A']; arr.sort(); arr; // ['A', 'B', 'C'] Array的sort()方法默认把所有元素先转换为String再排序： 要按数字大小排序，可以自定义sort排序函数： 'use strict'; var arr = [10, 20, 1, 2]; arr.sort(function (x, y) { return x - y }); console.log(arr); // [1, 2, 10, 20] 默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以： var arr = ['Google', 'apple', 'Microsoft']; arr.sort(function (s1, s2) { x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 x2) { return 1; } return 0; }); // ['apple', 'Google', 'Microsoft'] 翻转 reverse var arr = ['one', 'two', 'three']; arr.reverse(); arr; // ['three', 'two', 'one'] 删除添加若干元素 splice var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle']; // 从索引2开始删除3个元素,然后再添加两个元素: arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite'] arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] // 只删除,不添加: arr.splice(2, 2); // 删除['Google', 'Facebook'] arr; // ['Microsoft', 'Apple', 'Oracle'] // 只添加,不删除: arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素 arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] 根据数组计算单个值 reduce/reduceRight let value = arr.reduce(function(accumulator, item, index, array) { // ... }, [initial]); // accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）。 // item —— 当前的数组元素。 // index —— 当前索引。 // arr —— 数组本身。 let arr = [1, 2, 3, 4, 5]; let result = arr.reduce((sum, current) => sum + current, 0); alert(result); // 15 合并 concat concat()方法并没有修改当前Array，而是返回了一个新的Array var arr = ['A', 'B', 'C']; var added = arr.concat([1, 2, 3]); added; // ['A', 'B', 'C', 1, 2, 3] arr; // ['A', 'B', 'C'] concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里： var arr = ['A', 'B', 'C']; arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] 数组元素转字符串 join 如果Array的元素不是字符串，将自动转换为字符串后再连接。 var arr = ['A', 'B', 'C', 1, 2, 3]; arr.join('-'); // 'A-B-C-1-2-3' 迭代 for循环 let arr = [\"Apple\", \"Orange\", \"Pear\"]; for (let i = 0; i for..of： let fruits = [\"Apple\", \"Orange\", \"Plum\"]; // 遍历数组元素 for (let fruit of fruits) { alert( fruit ); } Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-06-05 23:01:34 "},"articles/algorithm/js_algorithm/Map.html":{"url":"articles/algorithm/js_algorithm/Map.html","title":"映射","keywords":"","body":"Map 初始化 初始化Map需要一个二维数组，或者直接初始化一个空Map。 var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]); m.get('Michael'); // 95 var m = new Map(); // 空Map m.set('Adam', 67); // 添加新的key-value 基本操作 new Map() —— 创建 map。 map.set(key, value) —— 根据键存储值。 map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。 map.has(key) —— 如果 key 存在则返回 true，否则返回 false。 map.delete(key) —— 删除指定键的值。 map.clear() —— 清空 map。 map.size —— 返回当前元素个数。 let map = new Map(); map.set('1', 'str1'); // 字符串键 map.set(1, 'num1'); // 数字键 map.set(true, 'bool1'); // 布尔值键 // 还记得普通的 Object 吗? 它会将键转化为字符串 // Map 则会保留键的类型，所以下面这两个结果不同： alert( map.get(1) ); // 'num1' alert( map.get('1') ); // 'str1' alert( map.size ); // 3 Map 还可以使用对象作为键。 let john = { name: \"John\" }; // 存储每个用户的来访次数 let visitsCountMap = new Map(); // john 是 Map 中的键 visitsCountMap.set(john, 123); alert( visitsCountMap.get(john) ); // 123 每一次 map.set 调用都会返回 map 本身，所以我们可以进行“链式”调用： map.set('1', 'str1') .set(1, 'num1') .set(true, 'bool1'); Map 迭代 如果要在 map 里使用循环，可以使用以下三个方法： map.keys() —— 遍历并返回所有的键（returns an iterable for keys）， map.values() —— 遍历并返回所有的值（returns an iterable for values）， map.entries() —— 遍历并返回所有的实体（returns an iterable for entries）[key, value]，for..of 在默认情况下使用的就是这个。 forEach let recipeMap = new Map([ ['cucumber', 500], ['tomatoes', 350], ['onion', 50] ]); // 遍历所有的键（vegetables） for (let vegetable of recipeMap.keys()) { alert(vegetable); // cucumber, tomatoes, onion } // 遍历所有的值（amounts） for (let amount of recipeMap.values()) { alert(amount); // 500, 350, 50 } // 遍历所有的实体 [key, value] for (let entry of recipeMap) { // 与 recipeMap.entries() 相同 alert(entry); // cucumber,500 (and so on) } // 对每个键值对 (key, value) 运行 forEach 函数 recipeMap.forEach( (value, key, map) => { alert(`${key}: ${value}`); // cucumber: 500 etc }); Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-06-05 22:34:09 "},"articles/algorithm/js_algorithm/Set.html":{"url":"articles/algorithm/js_algorithm/Set.html","title":"集合","keywords":"","body":"集合 去重 初始化 new Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。 let set = new Set(); let set = new Set([\"oranges\", \"apples\", \"bananas\"]); 常用方法 set.add(value) —— 添加一个值，返回 set 本身 set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。 set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。 set.clear() —— 清空 set。 set.size —— 返回元素个数。 let set = new Set(); let john = { name: \"John\" }; let pete = { name: \"Pete\" }; let mary = { name: \"Mary\" }; // visits，一些访客来访好几次 set.add(john); set.add(pete); set.add(mary); set.add(john); set.add(mary); // set 只保留不重复的值 alert( set.size ); // 3 for (let user of set) { alert(user.name); // John（然后 Pete 和 Mary） } 迭代 可以使用 for..of 或 forEach 来遍历 Set： let set = new Set([\"oranges\", \"apples\", \"bananas\"]); for (let value of set) alert(value); // 与 forEach 相同： set.forEach((value, valueAgain, set) => { alert(value); }); 注意一件有趣的事儿。forEach 的回调函数有三个参数：一个 value，然后是 同一个值 valueAgain，最后是目标对象。没错，同一个值在参数里出现了两次。 forEach 的回调函数有三个参数，是为了与 Map 兼容。当然，这看起来确实有些奇怪。但是这对在特定情况下轻松地用 Set 代替 Map 很有帮助，反之亦然。 Map 中用于迭代的方法在 Set 中也同样支持： set.keys() —— 遍历并返回所有的值（returns an iterable object for values）， set.values() —— 与 set.keys() 作用相同，这是为了兼容 Map， set.entries() —— 遍历并返回所有的实体（returns an iterable object for entries）[value, value]，它的存在也是为了兼容 Map。 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-06-05 22:34:04 "},"articles/c++/教程/基础语法.html":{"url":"articles/c++/教程/基础语法.html","title":"基础语法","keywords":"","body":"基础语法 基本语法大同小异，这里记录一些不同点 浮点型 // 浮点型 float c = 3.1415926f; cout 科学计数法 // 科学计数法 float e = 0.3e-2; cout 字符串 注意导入 #include // 字符串 // c风格字符串 char g[] = \"abcde\"; cout string h = \"hello\"; cout goto // goto 无条件跳转标记 cout 数组 相同数据类型 连续空间 一维数组 // 一维数组 // 声明 1 int arr[5]; cout 二维数组 // 二维数组 // 声明 1 int array[2][3]; cout 函数 函数声明 提前声明，编译编译阶段不报错。类似@class 函数分文件编写 创建.h头文件 创建.cpp源文件 头文件中写函数声明 源文件中写函数实现 使用时导入头文件 指针 指针类型大小 指针占用的内存空间和当前操作系统的位数有关。32位是4个字节，64位是8个字节 空指针NULL 内存编号0~255是系统占用内存，不允许用户访问 访问空指针变量会报错 一般用于初始化指针 // 指针 int *p = NULL; *p = 100; //EXC_BAD_ACCESS (code=1, address=0x0) 空指针异常 野指针 避免出现野指针 int *p = (int *)0x10000456; cout const修饰指针 常量指针 // 常量指针 const int *p = &a; // 这里报错，不能修改 p指向的空间的值 *p = 11; // 但可以修改p的指向 p = &b; 指针常量 // 指针常量 int * const p = &a; // p是一个指针常量，不能修改指向 p = &b; // 但可以修改p指向的空间的值 *p = 11; const修饰指针 & 修饰常量 // 指针常量 const int * const p = &a; // 不能修改 p = &b; // 不能修改 *p = 11; 指针和数组 数组名就是数组的首地址，可以直接赋值给指针 int arr[5] = {1,2,3,4,5}; cout 指针和函数 通过指针参数传递，可以再函数内部修改外部变量值 void mySwap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } 函数指针，同数组，函数名也是函数的地址，可以直接赋值给指针 int add(int a, int b) { return a + b; } int main(int argc, const char * argv[]) { // insert code here... int (*p)(int a, int b); p = add; cout 结构体 属于用户自定义数据类型，允许用户存储不同类型的数据 结构体定义 struct Student { string name; int age; int score; }; 结构体变量创建 先创建结构体变量，再初始化 Student a; a.name = \"jone\"; a.age = 18; a.score = 100; cout 创建结构体变量的时候直接初始化 Student a = {\"jone\", 18, 100}; cout 结构体定义的时候，直接创建一个变量 struct Student { string name; int age; int score; } a; a.name = \"jone\"; a.age = 18; a.score = 100; cout 结构体数组 struct Student { string name; int age; int score; }; int main(int argc, const char * argv[]) { // insert code here... struct Student arr[2] = {{\"zhangan\",18,90},{\"李四\",20,100}}; cout 结构体指针 结构体指针通过 -> 访问成员属性 struct Student { string name; int age; int score; }; int main(int argc, const char * argv[]) { // insert code here... Student a = {\"lisi\",18,99}; Student *p = &a; cout name age score system()执行脚本 system(\"pwd\"); // /Users/admin/Library/Developer/Xcode/DerivedData/CPPDemo-guygysvxscuculbwrpamjbmvnccu/Build/Products/Debug Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 17:24:59 "},"articles/c++/教程/核心编程.html":{"url":"articles/c++/教程/核心编程.html","title":"核心编程","keywords":"","body":"核心编程 内存四大区 代码区 全局区 栈区 堆区 C++中的new c++中使用new操作符在堆区开辟空间 堆区由程序员手动管理，释放时使用delete，释放数组时要加[] 语法：new 数据类型 使用new创建的数据，会返回该数据类型的指针 // 开辟普通数据类型空间 struct Student { string name; int age; int score; }; int main(int argc, const char * argv[]) { // insert code here... Student *p = new Student({\"lisi\",18,99}); cout name age score name age score 引用 作用：给一个变量起别名 语法：数据类型 &别名 = 原名； 必须初始化 初始化后不能发生改变 int a = 10; int &b = a; b = 100; cout 引用传递：可以作为函数形参方便修饰实参，替代指针传递 // 引用传递 void mySwap(int &a, int &b) { int temp = a; a = b; b = temp; } int c = 10; int d = 100; mySwap(c, d); cout 引用作为函数的返回值 注意不要返回局部变量，会释放 如果函数返回值作为左值，必须返回引用 int& test() { int a = 10; return a; } int &ref = test(); cout 引用的本质 引用的本质，在C++内部是一个指针常量 常量引用 常量引用主要用来修饰函数参数，防止参数修改导致原数据修改，导致误操作 void showValue(const int &a) { cout 函数的高级用法 函数的默认参数 如果从某个位置开始有默认参数，那么从这个位置开始，后面的参数都要有默认参数 如果函数声明有默认参数，那么函数实现就不能有默认参数 int add(int a = 10, int b = 100) { return a + b; } cout 函数的占位参数 函数参数列表中用来占位，调用时必须传递该位置 占位参数也可以有默认值 // 第二个int为占位参数，调用函数时必须要传递一个参数 void showValue(int a, int) { cout 函数重载 函数名相同，提高复用性 重载条件 同一个作用域下 函数名称相同 函数参数类型不同、个数不同或者顺序不同 函数返回值不可以作为函数重载的条件 注意事项 引用作为参数的重载 void func(int &a) { cout 函数重载遇到默认参数 void func(int a, int b = 10) { cout 类 声明 class Student { public: string name; int id; void showStudent() { cout 访问权限 public：内部可以访问、子类可以访问、外部可以访问 protected：内部可以访问、子类可以访问、外部不可以访问 private：内部可以访问、子类不可以访问、外部不可以访问 类和结构体的区别 class默认权限为private struct默认权限为public 成员属性设置为私有 自己控制读写权限 写权限判断数据有效性 抛出public的设置/获取方法给外部 构造函数 类型(){} 没有返回值，也不用写void 函数名和类名相同 构造函数可以有参数，可以发生重载 拷贝构造函数 属于有参构造，传入一个同类型对象，复制一个对象，类似深拷贝，注意传参，使用const修饰的引用，防止内部改变外部传入的对象 Person(const Person &p) { name = p.name; cout 构造函数的调用 括号法 无参构造不要使用括号调用，因为编译器或把它看做是函数声明 Person p1; // 默认构造 Person p2(\"lisi\"); // 有参构造 Person p3(p2); // 拷贝构造 匿名对象不能使用拷贝构造，编译器会认为重定义被拷贝的对象 Person(p3); // p3重定义 Person(p3) 等价于 Person p3； 显示法 Person p1 = Person(); // 默认构造 Person p2 = Person(\"lisi\"); // 有参构造 Person p3 = Person(p2); // 拷贝构造 隐式转换 Person p2 = \"lisi\"; // 有参构造 等价于 Person p2 = Person(\"lisi\"); Person p3 = p2; // 拷贝构造 等价于 Person p3 = Person(p2); 拷贝函数的调用时机 使用一个已经创建完毕的对象来初始化一个新对象 Person p; Person p2(p); // 这里会调用拷贝构造函数 值传递的方式给函数传参，会调用拷贝构造函数 void doWork(Person p) { p.name = \"lisi\"; // 这里不会修改原有的对象值 } void test() { Person p; doWork(p); // 这里会调用拷贝构造函数 } 值方式返回对象，会调用拷贝构造函数 Person doWork() { Person p; return p; } void test() { Person p = doWork(); // 这里会调用拷贝构造函数 } 构造函数的调用规则 只要写一个类，编译器至少给一个类默认添加三个函数 默认构造函数（无参，函数体为空） 默认析构函数（无参，函数体为空） 默认拷贝构造函数，对属性值进行值拷贝 如果用户定义有参构造函数，C++不在提供默认无参构造函数，但是会提供默认拷贝构造函数 如果用户定义拷贝构造函数，C++不会再提供其他构造函数 深拷贝&浅拷贝 浅拷贝带来的问题：堆区非法释放 使用深拷贝解决 如果有在堆区开辟内存，一定看下是否需要使用深拷贝 class Person { public: Person(int age, int height) { m_age = age; m_height = new int(height); } Person(const Person &p) { m_age = p.m_age; m_height = new int(*p.m_height); } int m_age; int *m_height; ~Person(){ if (m_height != NULL) { delete m_height; m_height = NULL; } cout 初始化列表 C++提供了初始化列表语法糖，用来初始化属性 语法：构造函数():属性1(值1),属性2(值2)...{} class Person { public: int m_A; int m_B; int m_C; // 传统的初始化方式 /* Person(int a, int b, int c) { m_A = a; m_B = b; m_C = c; } */ // 带初始化值的初始化列表 /* Person():m_A(10),m_B(20),m_C(30){ // 其他初始化动作 }; */ Person(int a, int b, int c):m_A(a),m_B(b),m_C(c){ // 其他初始化动作 }; }; int main(int argc, const char * argv[]) { // insert code here... //Person p; // 会调用带初始化值的初始化列表 Person p(10,20,30); cout 类对象最为类成员 当其他类对象作为本类成员，构造时候先构造类对象，在构造自身。析构的时候先析构自身，再析构成员对象 class Phone { public: string m_PName; Phone(string pName) { cout 静态成员 静态成员变量 静态成员变量不属于某个对象，所有对象共享同一份数据 静态成员变量也是有访问权限的 在编译期分配内存（全局区） 类内声明，类外初始化 静态成员变量有两种方式 通过对象进行访问 通过类名进行访问 class Person { public: static int age; private: static int sore; }; int Person::age = 18; // 类内声明，类外初始化 int Person::sore = 69; int main(int argc, const char * argv[]) { // insert code here... Person p; p.age = 20; Person p1; cout 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 静态成员函数也是有访问权限的 两种访问方式 对象访问 类名直接访问 class Person { public: static int age; int score; static void func() { age = 100; // 调用静态成员变量 score = 200; // 错误 静态函数只能访问静态成员变量，不能访问普通成员变量（不清楚改变哪个对象的成员变量） cout C++对象模型 C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 C++空对象占用1个字节空间 class Person { }; int main(int argc, const char * argv[]) { Person p; // 空对象占用的内存空间: 1个字节 // C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置 // 每个空对象也应该有一个独一无二的内存地址 cout 普通成员变量属于对象存储空间 class Person { int m_A; }; int main(int argc, const char * argv[]) { Person p; cout 静态成员变量和成员函数、静态成员函数不属于对象存储空间 class Person { int m_A; void func_A() { } static int m_B; static void func_B() { } }; int main(int argc, const char * argv[]) { Person p; cout this指针 this指向被调用的成员函数所属的对象，即this指向对象 this是一个指针常量，不能修改this的指向 this指针的用途： 当形参和成员变量同名时，可以用this进行区分 在类的非静态成员函数中返回对象本身，可使用return *this this访问成员变量 class Person { public: int age; Person(int age) { // age = age; 有问题 age都被认为是形参 this->age = age; } }; int main(int argc, const char * argv[]) { Person p(10); cout 返回对象本身return *this class Person { public: int age; Person(int age) { // age = age; 有问题 age都被认为是形参 this->age = age; } // 这里如果将返回值改成Person，则下面链式调用最终打印结果是20，因为当返回值是一个Person类型，会调用Person的拷贝构造函数，实际返回值不再是p2，而是一个新的Person Person& addAge(Person &p) { this->age += p.age; return *this; } }; int main(int argc, const char * argv[]) { Person p(10); cout 空指针访问成员函数 空指针不能访问成员属性，因为没有实际对象，堆上没有开辟空间，不知道访问啥 空指针可以访问没有使用成员属性的成员函数，但是不能访问使用了成员属性的成员函数，因为成员函数中的成员属性实际上也相当于是this->属性，但是这里的this是一个nullptr，所以会报错，原因同上 class Person { public: void showName() { cout m_Age，this是一个nullptr，不能访问成员变量 } }; int main(int argc, const char * argv[]) { Person *p = NULL; p->showName(); // 可以调用 // p->m_Age = 100; // 错误 空指针不能访问成员变量 p->showAge(); return 0; } const修饰成员函数 成员函数后加const，称为常函数，常函数内不可以修改成员属性，如果要修改，需要在属性前面加mutable，加了mutable之后，常函数和常对象都能修改 常函数后面的const，本质上修饰的是里面的this指针，this指针本身是一个指针常量，再加const之后，就相当于是一个指针常量&常量指针，既不能修改指向，也不能修改指向的空间的值 声明对象前加const，称为常对象，常对象只能调用常函数，因为普通成员函数可以修改成员属性 class Person { public: Person() { } // 常函数 void func() const { // m_Age = 10; // 错误 不能修改 m_Score = 100; // 正确 可以修改 } // 普通成员函数 void func2() { } int m_Age; mutable int m_Score; }; int main(int argc, const char * argv[]) { // 常对象 const Person p; // p.m_Age = 10; // 错误 不能修改 p.m_Score = 100; // 正确 可以修改 // p.func2(); // 错误 不能调用 p.func(); // 正确 可以调用 return 0; } 友元 friend 友元的目的，就是让一个函数或者一个类，访问另一个类中的私有成员 友元的三种实现 全局函数做友元 类做友元 成员函数做友元 全局函数做友元 class Build { friend void goodGay(const Build &build); // 声明友元全局函数 ，可以访问私有成员 public: string m_SettingRoom; Build() { m_SettingRoom = \"客厅\"; m_BedRoom = \"卧室\"; } private: string m_BedRoom; }; void goodGay(const Build &build) { // cout 友元类 class Build; class GoodGay { public: Build *build; void visit(); }; class Build { friend class GoodGay; // 声明友元类 这个类内部可以访问Build的私有成员 public: string m_SettingRoom; Build(); private: string m_BedRoom; }; Build::Build() { m_SettingRoom = \"客厅\"; m_BedRoom = \"卧室\"; } void GoodGay::visit() { cout m_SettingRoom m_BedRoom 成员函数做友元 class Build; class GoodGay { public: Build *build; void visit(); // 让这个不能访问build私有成员 void visit2();// 让这个可以访问build私有成员 }; class Build { friend void GoodGay::visit2(); // 声明友元函数 这个函数内部可以访问Build成员 public: string m_SettingRoom; Build(); private: string m_BedRoom; }; Build::Build() { m_SettingRoom = \"客厅\"; m_BedRoom = \"卧室\"; } void GoodGay::visit() { cout m_SettingRoom m_BedRoom m_SettingRoom m_BedRoom Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-03 22:12:39 "},"articles/c++/教程/运算符重载.html":{"url":"articles/c++/教程/运算符重载.html","title":"运算符重载","keywords":"","body":"运算符重载 运算符重载的方式 成员函数重载 全局函数重载 运算符重载，也可以进行函数重载 总结： 内置数据类型不能进行运算符重载 不能滥用运算符重载（符合运算符意义，避免歧义） 加法运算符重载 + class Person { public: int age; // Person operator+(Person &p) { // Person temp; // temp.age = age + p.age; // return temp; // } // Person operator+(int age) { // Person temp; // temp.age = this->age + age; // return temp; // } }; Person operator+(Person &p1, Person &p2) { Person temp; temp.age = p1.age + p2.age; return temp; } Person operator+(Person &p1, int age) { Person temp; temp.age = p1.age + age; return temp; } int main(int argc, const char * argv[]) { Person p1; p1.age = 18; Person p2; p2.age = 20; Person p3 = p1 + p2; cout 左移运算符重载 自定义类型输出（cout 不会利用成员函数重载左移运算符，因为无法实现cout函数在左侧 只能利用全局函数重载左移运算符 class Person { friend ostream& operatorage = age; } private: int age; }; ostream& operator 递增运算符重载 ++ class MyInt { friend ostream& operator 赋值运算符重载 = 编译器默认提供一个复制运算符重载，实现是浅拷贝 如果自己的数据中存在开辟了堆内存，需要自行重载赋值运算符，进行深拷贝，防止重复释放崩溃 class Person { public: Person(int a) { age = new int(a); } int *age; ~Person() { if (age != NULL) { delete age; age = NULL; } } Person& operator=(const Person& p) { if (age != NULL) { delete age; age = NULL; } age = new int(*p.age); return *this; } }; int main(int argc, const char * argv[]) { Person p1(18); Person p2(28); Person p3(38); cout 关系运算符重载 == != class Person { public: Person(string name, int age) { m_Name = name; m_Age = age; } bool operator==(const Person& p) { if (this->m_Name == p.m_Name && this->m_Age == p.m_Age) { return true; } return false; } bool operator!=(const Person& p) { if (this->m_Name == p.m_Name && this->m_Age == p.m_Age) { return false; } return true; } private: string m_Name; int m_Age; }; int main(int argc, const char * argv[]) { Person p1(\"lisi\",18); Person p2(\"lisi\",18); if (p1 == p2) { cout 函数调用运算符重载 () class MyAdd { public: int operator()(int a, int b) { return a + b; } }; int main(int argc, const char * argv[]) { MyAdd myadd; cout Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-11-30 23:37:16 "},"articles/c++/教程/继承.html":{"url":"articles/c++/教程/继承.html","title":"继承","keywords":"","body":"继承 语法 class 子类：继承方式 父类 {}; class SubClass: public SuperClass { }; 继承方式 public 父类中的私有成员不能访问，公共成员仍未公共，保护成员仍为保护 protected 父类中的私有成员不能访问，公共成员和保护成员均变为保护 private 父类中的私有成员不能访问，公共成员和保护成员均变为私有 继承中的对象模型 父类中所有的非静态成员属性都会被继承下去 私有成员只是访问不到，但是还是会继承下去，再子类中拥有 继承中的构造和析构顺序 先构造父类，再构造子类 先析构子类，再析构父类 继承同名成员处理方式 访问子类同名成员，直接访问 通过子类对象访问父类同名成员，需要加作用域 如果子类中出现了和父类重名的成员函数，子类的同名成员函数会隐藏父类中所有的同名成员函数（所有包含重载的函数），如果要访问父类中被隐藏的同名重载函数，需要加作用域 同名静态成员处理方式同上 class Base { public: int m_age; Base() { m_age = 40; } void func() { cout 多继承 class 子类：继承方式 父类1,继承方式 父类2,...,继承方式 父类n {}; 多继承会引发父类同名成员冲突，需要加作用域区分 菱形继承 两个派生类同时继承了同一个基类，又有某个类同时继承了两个派生类 资源浪费，只需要一份数据，确有两份 利用虚继承，可以解决菱形继承问题 class 子类：virtual public Animal {};// Animal称为虚基类，重复父类数据只有一份。虚继承需要使用在顶层的父类上 虚继承时，子类中没有从父类中继承成员属性，只有一个虚基类指针vbptr，指向虚基类表vbtable，vbtable中记录了一个偏移量，指向父类 class Sheep: virtual pulic Animal {}; class Tuo: virtual pulic Animal {}; class SheepTuo: pulic Sheep, pulic Tuo{}; Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-03 22:12:39 "},"articles/c++/教程/多态.html":{"url":"articles/c++/教程/多态.html","title":"多态","keywords":"","body":"多态 基本概念 静态多态：函数重载、运算符重载属于静态多态，函数名重用 静态多态编译器确定函数地址， 动态多态：派生类和虚函数实现运行时多态 动态多态运行时确定函数地址 动态多态条件 有继承关系 子类要重写父类虚函数 动态多态使用 父类的指针或者引用，指向子类对象 父类有虚函数，编译后父类就会有一个vfptr，指向父类的虚函数表，内部保存了虚函数 子类集成父类之后，会继承这个vfptr，指向子类的虚函数表，内部保存了父类的虚函数 当子类重写了父类的虚函数时，子类的虚函数表也重写了父类的这个虚函数，变成了自己的函数 class Animal { public: virtual void speak() { cout 多态好处 组织结构清晰 可读性强 扩展性强 class AbstractCalculator { public: virtual int getResult() { return 0; } int num1; int num2; }; class AddCalculator: public AbstractCalculator { public: int getResult() { return num1 + num2; } }; class MultiCalculator: public AbstractCalculator { public: int getResult() { return num1 * num2; } }; class SubCalculator: public AbstractCalculator { public: int getResult() { return num1 - num2; } }; int main(int argc, const char * argv[]) { AbstractCalculator *calc = new AddCalculator(); calc->num1 = 10; calc->num2 = 19; cout getResult() num1 = 10; calc->num2 = 19; cout getResult() num1 = 10; calc->num2 = 19; cout getResult() 纯虚函数和抽象类 纯虚函数：一般基类的虚函数没有什么用，不需要实现，可以将虚函数改成纯虚函数。virtual 返回值类型 函数名(参数列表) = 0; 类中只要有一个纯虚函数，就成为抽象类 抽象类不能实例化对象 抽象类的子类必须要重写父类纯虚函数，否则子类也是抽象类 虚析构和纯虚析构 虚析构：virtual ~类名(){}; 纯虚析构：virtual ~类名() = 0;类内声明，需要在类外实现：类名::~类名(){}; 多态使用时，如果子类有属性开辟到了堆区，那么父类指针在释放时，无法调用子类的析构代码 将父类的析构函数改成虚析构或者纯虚析构 虚析构和纯虚析构共性 解决父类指针释放子类对象 都需要具体的函数实现 虚析构和纯虚析构差异 如果是纯虚析构，则属于抽象类，无法实例化对象 父类指针在delete的时候不会走子类的析构函数，如果要解决，需要将父类的析构函数改为虚析构 纯虚析构必须要有代码实现，因为父类也有可能需要释放堆上空间 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-04 22:46:57 "},"articles/c++/教程/文件操作.html":{"url":"articles/c++/教程/文件操作.html","title":"文件操作","keywords":"","body":"文件操作 头文件 ofstream：写操作 ifstream：读操作 fstream：读写操作 读写操作 导入头文件 include 创建流对象 ofstream ofs; / ifstream ifs; 打开文件 ofs.open(\"文件路径\",打开方式); 判断文件是否打开成功 ofs.is_open() 写数据 / 读数据 读数据有四种方式，见demo ofs 关闭文件 ofs.close(); 文件的打开方式 ios::in 为读打开 ios::out 为写打开 ios::ate 初始位置文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在，先删除，再创建 ios::binary 二进制方式 可以多选，配合 | 操作符使用 #include void writeFile() { ofstream ofs; ofs.open(\"text.txt\", ios::out); ofs > buf) { cout 二进制方式 class Person { public: string name; int age; }; void writeFile() { Person p; p.name = \"李四\"; p.age = 19; ofstream ofs(\"Person.txt\", ios::out | ios::binary); ofs.write((const char *)&p, sizeof(p)); ofs.close(); } void readFile() { Person p; ifstream ifs; ifs.open(\"Person.txt\", ios::in | ios::binary); ifs.read((char *)&p, sizeof(p)); ifs.close(); cout Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-05 10:49:22 "},"articles/c++/教程/模板.html":{"url":"articles/c++/教程/模板.html","title":"模板","keywords":"","body":"模板 概念 泛型编程 类模板、函数模板 模板只是一个框架，不能直接使用 模板并不能通用 语法 template // typename可以替换成class 等价于 template 函数声明或者定义 template void mySwap(T& a, T& b) { T temp = a; a = b; b = temp; } int main(int argc, const char * argv[]) { // 隐式调用，编译器自动推到 int a = 10; int b = 20; mySwap(a, b); cout (d, e); cout 注意事项 模板必须要确定的 T ，一致的 T 才能执行 模板函数和普通函数的区别 普通函数可以进行隐式类型转换 模板函数隐式调用，不能进行隐式类型转换 模板函数显示调用，可以进行隐式类型转换 普通函数和模板函数的调用规则 如果普通函数和模板函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用模板函数 模板函数可以发生重载 如果模板函数可以发生更好的匹配，优先调用模板函数 void myPrint(int a, int b) { cout void myPrint(T a, T b) { cout void myPrint(T a, T b, T c) { cout (10, 20); // 模板函数可以发生重载 myPrint(10, 20, 30); // 如果模板函数可以发生更好的匹配，优先调用模板函数 myPrint('C', 'B'); return 0; } 模板局限性 模板类型在随后的调用中，不一定满足相关计算规则 针对特性类型，进行模板重载， 提供特定的模板 class Person { public: Person(string name, int age) { this->name = name; this->age = age; } string name; int age; }; template bool compare(T& a, T& b) { if (a == b) { return true; } return false; } // 针对特定类型，提供特定模板 template<> bool compare(Person& a, Person& b) { if (a.name == b.name && a.age == b.age) { return true; } return false; } int main(int argc, const char * argv[]) { Person p1(\"list\", 20); Person p2(\"wangwu\", 34); if (compare(p1, p2)) { cout 类模板 template 类 template class Person { public: Person(NameType name, AgeType age) { this->name = name; this->age = age; } void showPerson() { cout p(\"lisi\", 20); p.showPerson(); return 0; } 类模板和函数模板的区别 类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数 template 类模板中成员函数的创建时机 普通类中的成员函数一开始就创建 类模板中的成员函数调用时才创建 class Person1 { public: void showPerson1() { cout class MyPerson { public: T obj; // 这里可以通过编译 类模板中的成员函数调用时才创建 运行时确定 void func1() { obj.showPerson1(); } void func2() { obj.showPerson2(); } }; int main(int argc, const char * argv[]) { MyPerson p; p.func1(); // p.func2(); // 这里调用会失败 return 0; } 类模板对象做函数参数 指定传入类型：直接显示对象的数据类型 (最常用) 参数模板化：将对象中的参数变为模板进行传递 整个类模板化：将整个对象类型模板化进行传递 template class Person { public: Person(T1 name, T2 age){ this->name = name; this->age = age; } void showPerson() { cout & p) { p.showPerson(); } // 2. 参数模板化 template void show2(Person& p) { p.showPerson(); cout void show3(T& p) { p.showPerson(); cout p(\"list\", 20); show1(p); show2(p); show3(p); return 0; } 类模板与继承 当父类是一个类模板时，子类在声明时，需要指出 T 的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指出 T 的类型，子类也要变为类模板 template class Person { T name; }; // 子类集成类模板，必须要指定类型 class Student: public Person { }; // 如果需要动态指定类型，也可以使用类模板 template class Driver: public Person { }; int main(int argc, const char * argv[]) { Driver d; return 0; } 类模板成员函数的类外实现 template class Person { public: Person(T1 name, T2 age); void showPerson(); T1 name; T2 age; }; template Person::Person(T1 name, T2 age) { this->name = name; this->age = age; } template void Person::showPerson() { cout p(\"lisi\", 23); p.showPerson(); return 0; } 类模板分文件编写 类模板中的成员函数是运行时创建的，所以只导入 .h 编译时没错，但是运行时出错，无法解析的外部符号 解决方式： 导入 .cpp 源码文件 将.h 和 .cpp 写入到一个文件中，使用 .hpp后缀。约定俗成 .hpp一般为类模板 类模板和友元 全局函数类内实现：直接在类内声明友元 全局函数类外实现：需提前让编译器知道全局函数的存在 // 类外实现需要前置声明 template class Person; template void showPerson02(Person& p) { cout class Person { friend void showPerson01(Person& p) { cout (Person& p); public: Person(T1 name, T2 age) { this->name = name; this->age = age; } private: T1 name; T2 age; }; void test01() { Person p(\"lisi\", 18); showPerson01(p); } void test02() { Person p(\"wangwu\", 20); showPerson02(p); } int main(int argc, const char * argv[]) { test01(); test02(); return 0; } Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-07 23:12:45 "},"articles/c++/教程/STL.html":{"url":"articles/c++/教程/STL.html","title":"STL","keywords":"","body":"STL 基本概念 STL广义上分为容器、算法和迭代器 容器和算法通过迭代器无缝连接 STL六大组件 容器：vector、list、map... 算法：sort、find、for_each... 迭代器：容器和算法之间的胶合剂 仿函数：行为类似函数，可所谓算法的某种策略。（重载（）运算符） 适配器：一种用来修饰容器、迭代器或者仿函数接口的东西 空间配置器：负责空间的配置与管理。 容器初识 基本使用 & 迭代 #include #include using namespace std; void myPrint(int val) { cout v; v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); // 第一种遍历 /* vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout ::iterator itBegin = v.begin(); itBegin != v.end(); itBegin++) { cout 自定义类型 #include #include // 自定义数据类型 class Person { public: Person(string name, int age) { this->name = name; this->age = age; } string name; int age; }; void test01() { Person p1(\"lisi\", 18); Person p2(\"zhaoliu\", 29); Person p3(\"wangwu\", 37); Person p4(\"zhangsan\", 12); vector v; v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); for (vector::iterator it = v.begin(); it != v.end(); it++) { cout vector嵌套 #include #include // 嵌套 void test01() { vector> v; for (int i = 0; i v1; for (int j = 0; j >::iterator it = v.begin(); it != v.end(); it++) { for (vector::iterator it2 = (*it).begin(); it2 != (*it).end(); it2++) { cout string容器 构造函数 // string 构造 void test01() { // 无参构造 创建一个空串 string s1; cout 赋值操作 // string 赋值 void test01() { // = 赋值 string s1; s1 = \"Hello World\"; cout 拼接 void myPrint(string s) { cout 查找和替换 void test01() { string s1 = \"Hello Hello World\"; // 查找str 从第一个位置开始(包含这个位置) 没找到返回-1 long ret = s1.find(\"Hello\", 1); // 6 cout 比较 比较字符串的ASCII码 void test01() { string s1 = \"Dello\"; string s2 = \"Dello\"; string s3 = \"Fello\"; string s4 = \"Aello\"; int ret = s1.compare(s2); // 0 相等 cout 访问或者修改单个字符串中的单个字符 void test01() { string s1 = \"Hello\"; cout 插入和删除 void test01() { string s1 = \"Hello World\"; // 在第一个位置插入 \"AA\" s1.insert(1, \"AA\"); // HAAello World cout 截取子串 void test01() { string s1 = \"Hello World\"; // s1中从1开始，4个长度的子串 string sub = s1.substr(1,4); // ello cout vector Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-10 00:15:41 "},"articles/c++/教程/string.html":{"url":"articles/c++/教程/string.html","title":"string","keywords":"","body":"String string容器 构造函数 // string 构造 void test01() { // 无参构造 创建一个空串 string s1; cout 赋值操作 // string 赋值 void test01() { // = 赋值 string s1; s1 = \"Hello World\"; cout 拼接 void myPrint(string s) { cout 查找和替换 void test01() { string s1 = \"Hello Hello World\"; // 查找str 从第一个位置开始(包含这个位置) 没找到返回-1 long ret = s1.find(\"Hello\", 1); // 6 cout 比较 比较字符串的ASCII码 void test01() { string s1 = \"Dello\"; string s2 = \"Dello\"; string s3 = \"Fello\"; string s4 = \"Aello\"; int ret = s1.compare(s2); // 0 相等 cout 访问或者修改单个字符串中的单个字符 void test01() { string s1 = \"Hello\"; cout 插入和删除 void test01() { string s1 = \"Hello World\"; // 在第一个位置插入 \"AA\" s1.insert(1, \"AA\"); // HAAello World cout 截取子串 void test01() { string s1 = \"Hello World\"; // s1中从1开始，4个长度的子串 string sub = s1.substr(1,4); // ello cout Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-10 23:03:48 "},"articles/c++/教程/vector.html":{"url":"articles/c++/教程/vector.html","title":"vector","keywords":"","body":"STL vector 动态扩展 构造函数 void printVector(vector& v) { for (vector::iterator it = v.begin(); it != v.end(); it++) { cout v; for (int i = 0; i v1(v.begin(), v.end()); printVector(v1); // 0 1 2 3 4 5 6 7 8 9 // n个element 构造 vector v2(5,100); printVector(v2); // 100 100 100 100 100 // 拷贝构造 vector v3(v2); printVector(v3); // 100 100 100 100 100 } int main(int argc, const char * argv[]) { test01(); return 0; } 赋值 void printVector(vector& v) { for (vector::iterator it = v.begin(); it != v.end(); it++) { cout v; for (int i = 0; i v1; v1 = v; printVector(v1); // assign 区间赋值 vector v2; v2.assign(v.begin(), v.end()); printVector(v2); // assign n个elem vector v3; v3.assign(5, 1); printVector(v3); } int main(int argc, const char * argv[]) { test01(); return 0; } 容量和大小 resize不改变容量 void printVector(vector& v) { for (vector::iterator it = v.begin(); it != v.end(); it++) { cout v; for (int i = 0; i 插入和删除 void printVector(vector& v) { for (vector::iterator it = v.begin(); it != v.end(); it++) { cout v; for (int i = 0; i 数据存取 void printVector(vector& v) { for (vector::iterator it = v.begin(); it != v.end(); it++) { cout v; for (int i = 0; i 容器互换 void printVector(vector& v) { for (vector::iterator it = v.begin(); it != v.end(); it++) { cout v; for (int i = 0; i v1; for (int i = 3; i > 0; i--) { v1.push_back(i + 3); } printVector(v1); v.swap(v1); // 容器交换 printVector(v); printVector(v1); } int main(int argc, const char * argv[]) { test01(); return 0; } 实际用途：巧用swap可以收缩内存空间 void printVector(vector& v) { for (vector::iterator it = v.begin(); it != v.end(); it++) { cout v; for (int i = 0; i (v).swap(v); cout 预留空间 void test01() { vector v; v.reserve(10000); int *p = NULL; int num = 0; for (int i = 0; i 1 } int main(int argc, const char * argv[]) { test01(); return 0; } Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-11 00:38:59 "},"articles/c++/教程/deque.html":{"url":"articles/c++/教程/deque.html","title":"deque","keywords":"","body":"deque 功能 双端数组，可对头部进行插入删除操作 头部操作比vector快 vector随机访问比deque快 底层原理 中控器 + 缓冲区 内部有一个中控器，中控器维护了n段连续的存储缓冲区，使得deque看上去像一个连续的存储空间 构造 // 参数const 防止 d被重新复制 void showDeque(const deque& d) { // 常量迭代器 防止 *it被修改 for (deque::const_iterator it = d.begin(); it != d.end(); it++) { cout d; for (int i = 0; i d1(d.begin()+1, d.end()); showDeque(d1); // n和elem构造 deque d2(5, 66); showDeque(d2); // 拷贝构造 deque d3(d2); showDeque(d3); } int main(int argc, const char * argv[]) { test01(); return 0; } 赋值 // 参数const 防止 d被重新复制 void showDeque(const deque& d) { // 常量迭代器 防止 *it被修改 for (deque::const_iterator it = d.begin(); it != d.end(); it++) { cout d; for (int i = 0; i d1 = d; showDeque(d1); // assign 区间 deque d2; d2.assign(d1.begin(), d1.end()); showDeque(d2); // assign n 个 elem deque d3; d3.assign(4, 44); showDeque(d3); } int main(int argc, const char * argv[]) { test01(); return 0; } 大小操作 // 参数const 防止 d被重新复制 void showDeque(const deque& d) { // 常量迭代器 防止 *it被修改 for (deque::const_iterator it = d.begin(); it != d.end(); it++) { cout d; for (int i = 0; i 插入和删除 // 参数const 防止 d被重新复制 void showDeque(const deque& d) { // 常量迭代器 防止 *it被修改 for (deque::const_iterator it = d.begin(); it != d.end(); it++) { cout d; // 头尾操作 d.push_back(9); d.push_back(8); showDeque(d); d.push_front(-1); d.push_front(-2); showDeque(d); d.pop_back(); d.pop_front(); showDeque(d); // 指定位置操作 // 指定位置插入 d.insert(d.begin(), 66); showDeque(d); // 指定位置插入 n 和 elem d.insert(d.begin(), 2, 99); showDeque(d); // 指定位置插入 区间数据 d.insert(d.begin(), d.begin(), d.end()); showDeque(d); // 删除数据 // 删除指定位置 d.erase(d.begin()); showDeque(d); // 删除指定区间 d.erase(d.begin() + 2, d.end() - 2); showDeque(d); // 清空 d.clear(); showDeque(d); } int main(int argc, const char * argv[]) { test01(); return 0; } 数据存取 // 参数const 防止 d被重新复制 void showDeque(const deque& d) { // 常量迭代器 防止 *it被修改 for (deque::const_iterator it = d.begin(); it != d.end(); it++) { cout d; for (int i = 0; i 排序 // 参数const 防止 d被重新复制 void showDeque(const deque& d) { // 常量迭代器 防止 *it被修改 for (deque::const_iterator it = d.begin(); it != d.end(); it++) { cout d; for (int i = 9; i > 3; i--) { d.push_back(i); } showDeque(d); // 支持随机访问迭代器的容器，都可以使用sort进行排序 sort(d.begin(), d.end()); showDeque(d); } int main(int argc, const char * argv[]) { test01(); return 0; } Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-12 23:43:57 "},"articles/c++/教程/stack.html":{"url":"articles/c++/教程/stack.html","title":"stack","keywords":"","body":"stack 功能 先进后出 没有迭代器，不支持遍历，随机访问 构造 void test01() { // 默认构造 stack s; s.push(10); s.push(11); cout s1(s); cout 赋值 void test01() { // 默认构造 stack s; s.push(10); s.push(11); cout s1; s1 = s; cout 数据存取 void test01() { // 默认构造 stack s; // 入栈 s.push(10); s.push(11); s.push(12); // 弹栈 s.pop(); // 获取栈顶元素 cout 判断大小 void test01() { // 默认构造 stack s; // 入栈 s.push(10); s.push(11); s.push(12); cout Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-13 00:03:03 "},"articles/c++/教程/queue.html":{"url":"articles/c++/教程/queue.html","title":"queue","keywords":"","body":"queue 功能 先进先出 没有迭代器，不支持遍历，随机访问 构造 void test01() { // 默认构造 queue q; q.push(10); q.push(11); cout q1(q); cout 赋值 void test01() { // 默认构造 queue q; q.push(10); q.push(11); cout q1; q1 = q; cout 数据存取 void test01() { // 默认构造 queue q; // 入队 q.push(11); q.push(12); // 出队 q.pop(); // 获取队头 cout 判断大小 void test01() { // 默认构造 queue q; // 入栈 q.push(10); q.push(11); q.push(12); cout Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-13 00:02:22 "},"articles/c++/教程/list.html":{"url":"articles/c++/教程/list.html","title":"list","keywords":"","body":"list 概念 双向循环链表 构造函数 void showList(list& l) { for (list::const_iterator it = l.begin(); it != l.end(); it++) { cout l; l.push_back(11); l.push_back(12); l.push_back(13); l.push_back(14); l.push_back(15); showList(l); // assign赋值 // 区间赋值 } int main(int argc, const char * argv[]) { test01(); return 0; } 赋值 void showList(list& l) { for (list::const_iterator it = l.begin(); it != l.end(); it++) { cout l; l.push_back(11); l.push_back(12); l.push_back(13); l.push_back(14); l.push_back(15); showList(l); // assign 区间赋值 list l1; l1.assign(l.begin(),l.end()); showList(l1); // assign n个elem赋值 list l2; l2.assign(5,5); showList(l2); // = 赋值 list l3 = l2; showList(l3); // 将list与本身的元素互换 swap(l, l3); showList(l); showList(l3); } int main(int argc, const char * argv[]) { test01(); return 0; } 大小操作 void showList(list& l) { for (list::const_iterator it = l.begin(); it != l.end(); it++) { cout l; l.push_back(11); l.push_back(12); l.push_back(13); l.push_back(14); l.push_back(15); showList(l); // 判空 if (l.empty()) { cout 插入删除 void showList(list& l) { for (list::const_iterator it = l.begin(); it != l.end(); it++) { cout l; l.push_back(1); l.push_back(2); l.push_front(-1); l.push_front(-2); showList(l); l.pop_back(); l.pop_front(); showList(l); // insert l.insert(l.begin(), -2); showList(l); l.insert(l.begin(), 3, -3); showList(l); l.insert(l.begin(), l.begin(), l.end()); showList(l); l.erase(l.begin()); showList(l); l.erase(l.begin(),++l.begin()); showList(l); // 删除所有与 elem相同的节点 l.remove(-3); showList(l); l.clear(); showList(l); } int main(int argc, const char * argv[]) { test01(); return 0; } 数据存取 void showList(list& l) { for (list::const_iterator it = l.begin(); it != l.end(); it++) { cout l; l.push_back(1); l.push_back(2); l.push_front(-1); l.push_front(-2); showList(l); cout 翻转和排序 void showList(list& l) { for (list::const_iterator it = l.begin(); it != l.end(); it++) { cout b; } void test01() { // 默认构造 list l; l.push_back(1); l.push_back(2); l.push_front(-1); l.push_front(-2); showList(l); l.reverse(); showList(l); // 全局函数的sort不支持非随机访问迭代器的排序 // 默认升序 l.sort(); showList(l); // 降序 l.sort(mySort); showList(l); } int main(int argc, const char * argv[]) { test01(); return 0; } Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-14 23:29:31 "},"articles/c++/教程/set.html":{"url":"articles/c++/教程/set.html","title":"set","keywords":"","body":"set/multiset 基本概念 属于关联容器，底层二叉树结构 所有元素在插入是会自动排序 set中不允许有重复元素，multiset允许有重复元素 set构造和赋值 void showSet(set& s) { for (set::iterator it = s.begin(); it != s.end(); it++) { cout s1; s1.insert(30); s1.insert(10); s1.insert(20); s1.insert(10); // 10 20 30 不论插入先后顺序，遍历输出是有序的 showSet(s1); // 拷贝构造 set s2(s1); showSet(s2); // 赋值 set s3; s3 = s2; showSet(s3); } int main(int argc, const char * argv[]) { test01(); return 0; } set大小和交换 void showSet(set& s) { for (set::iterator it = s.begin(); it != s.end(); it++) { cout s1; s1.insert(30); s1.insert(10); s1.insert(20); s1.insert(10); showSet(s1); // 判空 if (s1.empty()) { cout s2; s2.insert(77); s2.insert(99); s2.insert(66); s2.insert(33); showSet(s2); swap(s1, s2); showSet(s1); showSet(s2); } int main(int argc, const char * argv[]) { test01(); return 0; } set插入和删除 void showSet(set& s) { for (set::iterator it = s.begin(); it != s.end(); it++) { cout s1; // 插入 s1.insert(30); s1.insert(10); s1.insert(20); showSet(s1); // 删除指定位置 s1.erase(++s1.begin()); showSet(s1); // 删除指定区间 s1.erase(s1.begin(),s1.end()); showSet(s1); s1.insert(30); s1.insert(10); s1.insert(20); // 删除指定元素 s1.erase(20); showSet(s1); // 清空 s1.clear(); showSet(s1); } int main(int argc, const char * argv[]) { test01(); return 0; } set查找和统计 void showSet(set& s) { for (set::iterator it = s.begin(); it != s.end(); it++) { cout s1; // 插入 s1.insert(30); s1.insert(10); s1.insert(20); s1.insert(20); s1.insert(20); s1.insert(20); showSet(s1); // find 查找 set::iterator it = s1.find(30); // 找不到就返回 s1.end()迭代器 if (it != s1.end()) { cout set和multiset区别 set不可以有重复数据，multiset可以 set插入数据会返回插入结果，表示是否插入成功，返回一个对组pair multiset不会校验插入数据，可以重复插入，返回一个迭代器，代表插入位置 void showSet(set& s) { for (set::iterator it = s.begin(); it != s.end(); it++) { cout s1; pair::iterator, bool> ret = s1.insert(10); if (ret.second) { cout 对组pair void showSet(set& s) { for (set::iterator it = s.begin(); it != s.end(); it++) { cout p1(\"lisi\",20); cout p2 = make_pair(\"wangwu\", 18); cout set排序 默认升序 可以使用仿函数进行排序 void showSet(set& s) { for (set::iterator it = s.begin(); it != s.end(); it++) { cout b; } }; void test01() { set s1; s1.insert(99); s1.insert(44); s1.insert(66); s1.insert(11); s1.insert(55); showSet(s1); // 默认升序 // set没有sort函数，需要使用仿函数进行排序，需要在定义的时候就传入 set s2; s2.insert(99); s2.insert(44); s2.insert(66); s2.insert(11); s2.insert(55); for (set::iterator it = s2.begin(); it != s2.end(); it++) { cout 自定义数据排序：必须指定排序规则 class Person { public: Person(string name, int age) { this->name = name; this->age = age; } bool operator()(Person& p1, Person& p2) { return p1.age > p2.age; } string name; int age; }; class MyCompare { public: bool operator()(const Person& p1, const Person& p2) { return p1.age > p2.age; } }; void test01() { Person p1(\"张三\", 23); Person p2(\"李四\", 24); Person p3(\"王五\", 25); set s1; s1.insert(p1); s1.insert(p2); s1.insert(p3); for (set::iterator it = s1.begin(); it != s1.end(); it++) { cout name age Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-15 23:36:52 "},"articles/c++/教程/map.html":{"url":"articles/c++/教程/map.html","title":"map","keywords":"","body":"map 概念 map中所有的元素都是pair pair中的第一个元素为key，起到索引作用，第二个值为value 所有元素都会根据key进行升序排序 关联式容器，底层使用二叉树实现 map中不允许有重复key，multimap允许有重复key 插入数据时，使用对组 构造和复制 void showMap(map& m) { for (map::iterator it = m.begin(); it != m.end(); it++) { cout first second m; m.insert(pair(1,10)); m.insert(pair(2,20)); m.insert(pair(3,30)); m.insert(pair(4,40)); showMap(m); // 拷贝构造 map m1(m); showMap(m1); // 赋值 map m2 = m; showMap(m2); } int main(int argc, const char * argv[]) { test01(); return 0; } 大小和交换 size()返回大小 empty()判空 swap(st)交换两个容器 插入和删除 insert(elem) 插入元素 void showMap(map& m) { for (map::iterator it = m.begin(); it != m.end(); it++) { cout first second m; m.insert(pair(1,10)); m.insert(make_pair(2, 20)); m.insert(map::value_type(3, 30)); m[4] = 40; // 如果key之前存在，会直接修改之前的值，但是上面的方法不会修改之前的值，会修改失败 // 使用[]访问一个不存在的key是，会直接赋值0 cout clear() 删除所有元素 erase(pos) 删除迭代器所指的元素，返回下一个元素的迭代器 erase(begin,end) 删除迭代器区间，前闭后开，返回下一个元素的迭代器 earse(key) 删除容器中为key的元素 查找和统计 find(key) 查找key是否存在，若存在，返回这个key的迭代器，不存在返回map.end迭代器 count(key) 统计key的元素个数，map中为0或者1，multimap可能存在多个 排序 默认按照key升序排列 利用仿函数，可以改变排序规则 class MyCompare { public: // 注意const bool operator()(int a, int b) const{ return a > b; } }; void showMap(map& m) { for (map::iterator it = m.begin(); it != m.end(); it++) { cout first second m; m.insert(pair(1,10)); m.insert(pair(2,20)); m.insert(pair(4,40)); m.insert(pair(3,30)); m.insert(pair(5,50)); // 默认升序 showMap(m); // map m1; m1.insert(make_pair(1,10)); m1.insert(make_pair(2,20)); m1.insert(make_pair(4,40)); m1.insert(make_pair(3,30)); m1.insert(make_pair(5,50)); for (map::iterator it = m1.begin(); it != m1.end(); it++) { cout first second Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-20 01:04:34 "},"articles/c++/教程/函数对象.html":{"url":"articles/c++/教程/函数对象.html","title":"函数对象","keywords":"","body":"函数对象 概念 重载了函数调用符的类，其对象称为函数对象 函数对象使用重载的（）时，行为类似函数调用，也叫仿函数 本质：函数对象（仿函数）是一个类，不是一个函数 使用 函数对象在使用时，可以像普通函数那样调用，可以有参数、返回值 函数对象超出普通函数的概念，可以有自己的状态 函数对象可以作为参数传递 class MyPrint { public: void operator()(string str) { cout count++; cout count Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-28 00:10:09 "},"articles/linux/常用命令.html":{"url":"articles/linux/常用命令.html","title":"常用命令","keywords":"","body":"常用命令 ar 归档命令 # 分离静态库 ar -x ../libAnalyticsSdk_v7 clang 编译指令 # 重写OC为C++ $ clang -rewrite-objc main.m class-dump 通过Mach-O 文件导出项目头文件 class-dump -H #mach-o文件路径# -o #头文件导出位置# class-dump -H #安装包文件路径# -o #头文件导出地址# codesign Xcode提供的签名工具 # 查看签名信息 $ codesign -vv -d WeChat.app # 重签名 强制替换签名 $ codesign –fs 证书串 文件名 $ codesign -fs 36833CADAC1367617DA226BE8F5490253208DB68 mm_dart_cpp.framework # 重签名 通过指定权限文件对App进行重签名 $ codesign -fs 36833CADAC1367617DA226BE8F5490253208DB68 --no-strict --entitlements=entitlements.plist WeChat.app df 查看磁盘空间 df -hl #查看磁盘剩余空间 df -h #查看每个根路径的分区大小 du -sh [目录名] #返回该目录的大小 du -sm [文件夹] #返回该文件夹总M数 du -h [目录名] #查看指定文件夹下的所有文件大小（包含子文件夹） file 显示文件相关信息 file AliyunIdentityManager find 查找文件 # 在/usr 目录下，查找文件名后缀为.a的文件 $ find /usr -name \"*.a\" hexdump 查看文件二进制信息 只看二进制数据 xxd更好用 $ hexdump array.js libtool 将目标文件.o合并为静态库 libtool -static -o xxxx.a *.o lipo 静态库、mach-o相关信息及操作 # 查看架构 $ lipo -info BioAuthEngine.framework # 架构分离 $ lipo 文件路径 -thin 架构类型 -output 输出文件路径 $ lipo BioAuthEngine.framework/BioAuthEngine -thin arm64 -o BioAuthEngine64 # 架构合并 $ lipo -create 文件路径1 文件路径2 -output 输出文件路径 mdfind Spotlight的命令行工具，查找很方便 # 查找文件名中有dyld的文件 mdfind -name dyld # 查找文件内容中有dyld的文件 mdfind dyld # 在指定路径下查找 $ mdfind -name dyld -onlyin ~/Desktop nm 查看符号 names 主要是用来列出某些文件中的符号（说白了就是一些函数和全局变量等） # 人类友好的方式输出符号表 $ nm -m # -n 排序 -p 不排序 ojbcdump 查看mach-o信息，更容易阅读 # 查看header & lc objdump --macho --private-header # 查看__text objdump --macho -d # 查看符号表 # objdump --macho -syms objdump --macho -syms # 查看符号表 objdump --macho -t # 查看导出符号 objdump --macho --exports-trie # 查看间接符号 objdump --macho --indirect-symbols otool 显示mach-o相关信息 otool -l #print the load commands otool -h #print the mach header security 苹果证书、描述文件操作 # 列出要是串里可签名的证书 $ security find-identity -v -p codesigning # 查看描述文件 $ security cms -D -i embedded.mobileprovision # 导出描述文件到一个plist文件 $ security cms -D -i embedded.mobileprovision > temp.plist strings 显示二进制文件中的字符串 # 查看二进制文件中的strings $ strings qihooloan_ios | grep --color=auto -ir \"checkCachedLicense\" swift swift相关命令 # 源码编译为sil中间文件 | 编译后的符号解析 $ swiftc -emit-sil main.swift | xcrun swift-demangle >> ./main.sil && open main.sil # 生成抽象语法树 $ swiftc -dump-ast main.swift unzip 解压缩 $ unzip -oqq -d xattr 文件系统的扩展属性 # mac应用不可用的一种操作 $ xattr -r -d com.apple.quarantine /Applications/XMind\\ ZEN.app xcode xcode相关命令 # 查看当前环境的SDK版本 $ xcodebuild -showsdks # 查看编译时间 $ defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES xcrun 编译相关命令 # OC重写为c++ $ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m # 恢复swift mangleName $ xcrun swift-demangle s7LGSwift1tAA9LGTeacherVvp $s7LGSwift1tAA9LGTeacherVvp ---> LGSwift.t : LGSwift.LGTeacher # 查看Rebase和Bind信息 $ xcrun dyldinfo -bind InjectDemo # 查看预处理 xcrun clang -E main.c # 词法分析 生成token $ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.c # 语法分析 抽象语法树 $ xcrun clang -fsyntax-only -Xclang -ast-dump main.c | open -f # CodeGen 生成中间代码IR $ xcrun clang -S -emit-llvm main.c -o main.ll # 生成汇编代码 $ xcrun clang -S main.c -o main.s # 生成目标文件 汇编器 $ xcrun clang -fmodules -c main.c -o main.o # 链接 $ xcrun clang main.o -o main xxd 查看文件二进制信息 对ascii进行编码显示 $ xxd array.js zip 压缩 # Zip –ry 输出文件 输入文件 将输入文件压缩为输出文件 $ zip -ry $ zip -ry text.zip text.txt Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-25 13:00:31 "},"articles/linux/shell_script.html":{"url":"articles/linux/shell_script.html","title":"Shell脚本","keywords":"","body":"Shell脚本 脚本解释器 在 shell 脚本，#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。#! 被称作shebang（也称为 Hashbang ）。 指定sh解释器 #!/bin/bash #!/bin/sh #!/bin/zsh 注意 上面的指定解释器的方式是比较常见的，但有时候，你可能也会看到下面的方式： #!/usr/bin/env bash 这样做的好处是，系统会自动在 PATH 环境变量中查找你指定的程序（本例中的bash）。相比第一种写法，你应该尽量用这种写法，因为程序的路径是不确定的。这样写还有一个好处，操作系统的PATH变量有可能被配置为指向程序的另一个版本。比如，安装完新版本的bash，我们可能将其路径添加到PATH中，来“隐藏”老版本。如果直接用#!/bin/bash，那么系统会选择老版本的bash来执行脚本，如果用#!/usr/bin/env bash，则会使用新版本。 模式 交互模式：终端中执行命令 非交互模式：脚本 基本语法 解释器 #! 决定了脚本可以像一个独立的可执行文件一样执行，而不用在终端之前输入sh, bash, python, php等。 # 以下两种方式都可以指定 shell 解释器为 bash，第二种方式更好 #!/bin/bash #!/usr/bin/env bash 注释 单行注释 - 以 # 开头，到行尾结束。 多行注释 - 以 : 开头，到 EOF 结束。 #-------------------------------------------- # shell 注释示例 # author：zp #-------------------------------------------- # echo '这是单行注释' ########## 这是分割线 ########## : echo 输出普通字符串 echo \"hello, world\" # Output: hello, world 字符串中引号转义 echo \"hello, \\\"zp\\\"\" # Output: hello, \"zp\" 带变量 name=zp echo \"hello, \\\"${name}\\\"\" # Output: hello, \"zp\" 换行符 # 输出含换行符的字符串 echo \"YES\\nNO\" # Output: YES\\nNO echo -e \"YES\\nNO\" # -e 开启转义 # Output: # YES # NO echo -e \"YES\\c\" # -e 开启转义 \\c 不换行 echo \"NO\" # Output: # YESNO 输出重定向至文件 echo \"Hello World\" > hello.txt 输出执行结果 echo `pwd` 参考文献 一篇文章让你彻底掌握 shell 语言 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-10-14 00:29:48 "},"articles/linux/linux三剑客.html":{"url":"articles/linux/linux三剑客.html","title":"Linux三剑客","keywords":"","body":"linux三剑客 普通剑客 $ cat student.txt id12-张三-25-男-178-55 id24-李四-34-男-189-89 id05-王五-28-男-168-65 id19-赵华-20-男-179-60 id45-牛莉-28-女-160-45 cut 用指定规则来切分文本 # 用 \"-\" 切分文本的每行，展示前三列 $ cut -d '-' -f1,2,3 student.txt id12-张三-25 id24-李四-34 id05-王五-28 id19-赵华-20 id45-牛莉-28 sort 对文本中的行进行排序 $ sort student.txt id05-王五-28-男-168-65 id12-张三-25-男-178-55 id19-赵华-20-男-179-60 id24-李四-34-男-189-89 id45-牛莉-28-女-160-45 # sort -r 逆序 $ sort -r student.txt id45-牛莉-28-女-160-45 id24-李四-34-男-189-89 id19-赵华-20-男-179-60 id12-张三-25-男-178-55 id05-王五-28-男-168-65 # 使用 '-' 切分 然后用第三列排序 默认比较的是字符串 $ sort -t '-' -k3 student.txt id19-赵华-20-男-179-60 id12-张三-25-男-178-55 id45-牛莉-28-女-160-45 id05-王五-28-男-168-65 id24-李四-34-男-189-89 # 使用 '-' 切分 然后用第三列排序 -n 是按照数字大小进行比较 $ sort -t '-' -n -k3 student.txt id19-赵华-20-男-179-60 id12-张三-25-男-178-55 id05-王五-28-男-168-65 id45-牛莉-28-女-160-45 id24-李四-34-男-189-89 wc word count 统计单词 $ wc student.txt # 行 单词数量 字符数量 5 6 130 student.txt # 也可以使用 -l 统计行 $ wc -l student.txt 5 student.txt # 使用 -w 统计单词 以空格分隔单词 $ wc -w student.txt 6 student.txt # 使用 -c 统计字符 $ wc -c student.txt 130 student.txt 高级剑客 grep 正则参考 # -n 显示行号 可以查询多个文本 $ grep 1 -n student.txt /Users/360jr/Downloads/https.txt student.txt:1:id12-张三-25-男-178-55 student.txt:2:id24-李四-34-男-189-89 student.txt:3:id05-王五-28-男-168-65 student.txt:4:id19-赵华-20-男-179-60 student.txt:5:id45-牛莉-28-女-160-45 /Users/360jr/Downloads/https.txt:1:http://cdnimg.3g.qq.com/qq_product_operations/nettest/index.html?r=1525275329 /Users/360jr/Downloads/https.txt:2:http://cdnimg.3g.qq.com/qq_product_operations/nettest/index.html?r=1525275330 # -v 显示不匹配 -i忽略大小写 $ grep 45 -nvi student.txt 1:id12-张三-25-男-178-55 2:id24-李四-34-男-189-89 3:id05-王五-28-男-168-65 4:id19-赵华-20-男-179-60 # -E 使用正则匹配 $ grep -E \"张\" -n student.txt 1:id12-张三-25-男-178-55 sed 对文本增删改查 普通操作只是显示在终端，不会真实改变文本，如果改变需要使用 sed -i sed参考 Sed命令是操作，过滤和转换文本内容的强大工具。常用功能有增删改查（增加，删除，修改，查询），其中查询的功能中最常用的2大功能是过滤（过滤指定字符串），取行（取出指定行）。 语法 sed [options] [sed -commands][input -file] sed [选项] 【sed命令】 【输入文件】 Sed软件从文件或管道中读取一行，处理一行，输出一行；再读取一行，再处理一行，再输出一行....，不会把文件全部读入内存，对内存的压力很小 awk awk参考 awk 是一门语言 awk -F 操作什么数据，执行什么动作 # 以 '-' 分组 ，行号大于等于2 小于等于4 $ awk -F '-' 'NR>=2&&NR 使用awk获取本机ip Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-19 23:44:36 "},"articles/linux/shell教程/基本概念.html":{"url":"articles/linux/shell教程/基本概念.html","title":"基本概念","keywords":"","body":"基本概念 Shell是什么 如果以./方式运行以文件，首先需要增加可执行权限，然后系统默认会使用bash进行执行 如果要以./方式运行，需要在脚本文件头部加上解析器#!/bin/python,#!/bin/bash Shell特性 table自动补全 history查看历史 alias查看所有别名 alias tt='echo tt'设置别名 unalias tt删除别名 常用快捷键 ctrl + u 删除光标前所有字符（mac上为删除行） ctrl + k 删除光标后所有字符 ctrl + a 移动光标到头 ctrl + e 移动光标到尾 ctrl + l 清屏 ctrl + c 终止前台程序，另起一行 ctrl + z 挂起 ctrl + d 删除光标所在字符 ctrl + w 删除光标前一个单词 ctrl + r 输入单词搜索历史命令 ctrl + y 粘贴ctrl+U/K剪切的内容 Shell执行的三种方式 使用./path.sh执行：需要添加可执行权限 使用sh path.sh执行 使用source path.sh执行 使用1、2方式执行脚本，相当于另起一个进程执行脚本；而使用 3 方式执行脚本，就是在当前进行执行。 当跨进程执行脚本时，其中使用到的变量，会首先在当前进程进行查找，如果找不到，会到父进程中进行查找。 父进程中的变量默认是不对子进程可见的，如果需要可见，使用export导出 三种执行方式 [lighthouse@VM-20-7-centos LearnShell]$ ls hello.sh [lighthouse@VM-20-7-centos LearnShell]$ chmod +x hello.sh [lighthouse@VM-20-7-centos LearnShell]$ ./hello.sh Hello World [lighthouse@VM-20-7-centos LearnShell]$ sh hello.sh Hello World [lighthouse@VM-20-7-centos LearnShell]$ source hello.sh Hello World [lighthouse@VM-20-7-centos LearnShell]$ cat hello.sh #!/bin/bash echo 'Hello World' [lighthouse@VM-20-7-centos LearnShell]$ 进程的区别 [lighthouse@VM-20-7-centos LearnShell]$ cat hello.sh #!/bin/bash echo 'Hello World' echo $age [lighthouse@VM-20-7-centos LearnShell]$ age=8 [lighthouse@VM-20-7-centos LearnShell]$ ./hello.sh Hello World [lighthouse@VM-20-7-centos LearnShell]$ sh hello.sh Hello World [lighthouse@VM-20-7-centos LearnShell]$ source hello.sh Hello World 8 [lighthouse@VM-20-7-centos LearnShell]$ 导出变量 [lighthouse@VM-20-7-centos LearnShell]$ cat hello.sh #!/bin/bash echo 'Hello World' echo $age [lighthouse@VM-20-7-centos LearnShell]$ age=8 [lighthouse@VM-20-7-centos LearnShell]$ ./hello.sh Hello World [lighthouse@VM-20-7-centos LearnShell]$ sh hello.sh Hello World [lighthouse@VM-20-7-centos LearnShell]$ source hello.sh Hello World 8 [lighthouse@VM-20-7-centos LearnShell]$ export age [lighthouse@VM-20-7-centos LearnShell]$ ./hello.sh Hello World 8 [lighthouse@VM-20-7-centos LearnShell]$ sh hello.sh Hello World 8 [lighthouse@VM-20-7-centos LearnShell]$ source hello.sh Hello World 8 [lighthouse@VM-20-7-centos LearnShell]$ Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-16 00:20:48 "},"articles/linux/shell教程/基础语法.html":{"url":"articles/linux/shell教程/基础语法.html","title":"基础语法","keywords":"","body":"基础语法 变量 # 定义变量 [lighthouse@VM-20-7-centos ~]$ a=10 # 使用变量 [lighthouse@VM-20-7-centos ~]$ echo $a 10 # 删除变量 [lighthouse@VM-20-7-centos ~]$ unset a [lighthouse@VM-20-7-centos ~]$ echo $a [lighthouse@VM-20-7-centos ~]$ url='https://www.baidu.com' [lighthouse@VM-20-7-centos ~]$ echo $url https://www.baidu.com # 设置变量只读 [lighthouse@VM-20-7-centos ~]$ readonly url [lighthouse@VM-20-7-centos ~]$ url=10 -bash: url: readonly variable # 只读不能修改 [lighthouse@VM-20-7-centos ~]$ unset url # 只读不能删除 -bash: unset: url: cannot unset: readonly variable [lighthouse@VM-20-7-centos ~]$ 字符串 字符串可以使用单引号，也可以使用双引号，也可以不使用引号 如果字符串中有空格，就需要用引号括起来 单引号 单引号中的任何字符，都会原样输出，单引号字符串中的变量是无效的 单引号字符串中不能出现单个单引号，但可以成对出现，作为字符串拼接使用 双引号 双引号中可以有变量 双引号中可以出现转义字符 # 字符串拼接 双引号 [lighthouse@VM-20-7-centos ~]$ name=\"lisi\" [lighthouse@VM-20-7-centos ~]$ str=\"hello\"$name\"。！\" [lighthouse@VM-20-7-centos ~]$ echo $str hellolisi。！ [lighthouse@VM-20-7-centos ~]$ str=\"hello $name 。！\" [lighthouse@VM-20-7-centos ~]$ echo $str hello lisi 。！ [lighthouse@VM-20-7-centos ~]$ # 字符串拼接 单引号 [lighthouse@VM-20-7-centos ~]$ name=\"wangwu\" [lighthouse@VM-20-7-centos ~]$ str='hello'$name'00000' [lighthouse@VM-20-7-centos ~]$ echo $str hellowangwu00000 [lighthouse@VM-20-7-centos ~]$ str='hello $name 00000' [lighthouse@VM-20-7-centos ~]$ echo $str hello $name 00000 [lighthouse@VM-20-7-centos ~]$ # 字符串长度 [lighthouse@VM-20-7-centos ~]$ name=\"lisi\" [lighthouse@VM-20-7-centos ~]$ echo ${#name} 4 # 字符串截取 [lighthouse@VM-20-7-centos ~]$ echo ${name:1:2} is 数组 bash支持一维数组，不支持多维数组，并且没有限定数组大小 数组下标从0开始，访问数组元素需要通过下标。下标可以是整数或者算数表达式，值应该大于等于0 # 数组声明 [lighthouse@VM-20-7-centos ~]$ arr=(\"lisi\" \"zhangan\" \"wangwu\") # 数组名变量为数组第一个元素 [lighthouse@VM-20-7-centos ~]$ echo $arr lisi # 通过下标访问数组元素 [lighthouse@VM-20-7-centos ~]$ echo ${arr[1]} zhangan # 通过@或者*获取数组所有元素 [lighthouse@VM-20-7-centos ~]$ echo ${arr[@]} lisi zhangan wangwu [lighthouse@VM-20-7-centos ~]$ echo ${arr[*]} lisi zhangan wangwu # 获取数组长度 [lighthouse@VM-20-7-centos ~]$ echo ${#arr[@]} 3 [lighthouse@VM-20-7-centos ~]$ 注释 单行注释 # 多行注释 : 运算符 expr运算表达式 expr运算表达式：注意乘法 * 为特殊字符，需要使用转义 \\* [lighthouse@VM-20-7-centos ~]$ a=3 [lighthouse@VM-20-7-centos ~]$ b=4 [lighthouse@VM-20-7-centos ~]$ echo `expr $a + $b` 7 [lighthouse@VM-20-7-centos ~]$ echo `expr $a \\* $b` 12 [lighthouse@VM-20-7-centos ~]$ echo `expr $a - $b` -1 [lighthouse@VM-20-7-centos ~]$ echo `expr $a / $b` 0 [lighthouse@VM-20-7-centos ~]$ echo `expr $a % $b` 3 [lighthouse@VM-20-7-centos ~]$ 比较运算符 a=10 b=20 if [ $a == $b ] then echo \"a == b\" fi if [ $a != $b ] then echo \"a != b\" fi 关系运算符只支持数字，不支持字符串，除非字符串是数字 a=10 b=20 # equal 等于 if [ $a -eq $b ] then echo \" a 等于 b\" else echo \"a 不等于 b\" fi # not equal 不等于 if [ $a -ne $b ] then echo \"a 不等于 b\" fi # great than 大于 if [ $a -gt $b ] then echo \"a 大于 b\" fi # less than 小于 if [ $a -lt $b ] then echo \"a 小于 b\" fi # great equal 大于等于 if [ $a -ge $b ] then echo \"a 大于等于 b\" fi # less equal 小于等于 if [ $a -le $b ] then echo \"a 小于等于 b\" fi 布尔运算符 ! 非运算符 -o 或运算符 -a 与运算符 a=10 b=20 c=false if [ !$c ] then echo \"!c\" fi if [ $a != $b -o $c ] then echo \" a 不等于 b 或者 c是true \" fi if [ $a != $b -a !$c ] then echo \"a 不等于 b 且 非c是true\" fi 逻辑运算符 || 短路或 && 短路与 字符串运算符 a=\"abc\" b=\"dge\" c=\"abc\" # 字符串相等 if [ $a == $b ] then echo \"a == b\" else echo \"a != b\" fi # 字符串不相等 if [ $a != $c ] then echo \"a != c\" else echo \"a == c\" fi # 字符串长度为0 if [ -z $a ] then echo \"a 长度为 0\" else echo \"a 长度不为 0\" fi # 字符串长度不为0 if [ -n $b ] then echo \"b 长度不为 0\" else echo \"b 长度为 0\" fi # 字符串不为空 if [ $c ] then echo \"c 不为空\" else echo \"c 为空\" fi 文件测试运算符 file=\"/home/lighthouse/LearnShell/hello.sh\" # 判断文件可读 if [ -r $file ] then echo \"文件可读\" else echo \"文件不可读\" fi # 判断文件可写 if [ -w $file ] then echo \"文件可写\" else echo \"文件不可写\" fi # 判断文件可执行 if [ -x $file ] then echo \"文件可执行\" else echo \"文件不可执行\" fi # 判断文件是否是普通文件 if [ -f $file ] then echo \"普通文件\" else echo \"特殊文件\" fi # 判断是否是目录 if [ -d $file ] then echo \"是一个目录\" else echo \"不是目录\" fi # 判断文件是否为空 if [ -s $file ] then echo \"文件不为空\" else echo \"文件为空\" fi # 判断文件是否存在 if [ -e $file ] then echo \"文件存在\" else echo \"文件不存在\" fi echo # echo -e 输出转义字符 echo -e \"hello \\n\" echo \"world\" # echo -n 不换行输出 echo -n \"echo -e 输出转义字符请输入一个数字：\" # echo `date` 显示命令执行结果 $ echo `date` 2021年12月18日 星期六 23时41分10秒 CST test test命令用于检查某个条件是否成立，用它可以进行数值、字符、文件三个方面的测试 #!/bin/bash a=10 b=20 if test $a -eq $b then echo \"a == b\" else echo \"a != b\" fi 流程控制语句 if #!/bin/bash score=66 if [ $score -ge 90 ] then echo \"优秀\" elif [ $score -ge 80 ] then echo \"良好\" elif [ $score -ge 70 ] then echo \"一般\" elif [ $score -ge 60 ] then echo \"及格\" else echo \"不及格\" fi case case为多选择语句，可以用case匹配一个值与一个模式，如果匹配成功，执行相匹配的命令 语法 case 值 in 模式1) command1 command2 .... ;; 模式2) command1 command2 .... ;; esac 案例 #!/bin/bash echo \"请输入一个数字：\" read num case $num in 1) echo \"输入的是 1\" echo \"又打印了一遍 1\" ;; 2) echo \"输入的是 2\" ;; 3) echo \"输入的是 3\" ;; *) echo \"其他数字\" ;; esac # 匹配多个值 case $num in 1|2|3|4) echo \"输入的是 1 - 4 之间\" ;; *) echo \"其他数字\" ;; esac for 当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值 命令可为任何有效的shell命令和语句，in列表可以包含替换、字符串和文件名 in列表是可选的，如果不用它，for循环使用命令行的位置参数 语法 for var in item1 item2 ... itemN do command1 command2 ... done 案例 #!/bin/bash arr=(\"李四\" \"张安\" \"王五\" \"赵六\") for str in ${arr[@]} # 注意这里获取数组的所有元素 do echo \"名字是：$str\" done for num in 1 2 3 4 5 do echo \"num is $num\" done while while用于不断执行一系列命令，也用于从文件中读取数据，命令通常为测试条件 语法 while confition do command done # 无限循环 while true do command done 案例 # let命令用于执行一个或者多个表达式，表达式中的变量不需要使用$ #!/bin/bash num=0 while(( $num break 跳出所有循环 continue 跳出当次循环 函数 可以function func()定义，也可以直接func()定义 参数返回，可以加：return返回，也可以不加。如果不加，将会以最后一条命令的运行结果返回。return后跟数值n（0-255） 函数返回值，在调用函数后通过$?获取 #!/bin/bash # 定义一 function func() { echo \"Hello World\" } # 定义二 func1() { echo \"Hello World other\" } # 带return func2() { a=1 b=2 return $(($a + $b)) } # 函数参数 funcWithParams() { echo \"第一个参数 $1\" echo \"第二个参数 $2\" echo \"第十个参数 ${10}\" echo \"参数个数 $#\" echo \"所有参数 $*\" } # 调用 func func1 func2 # 获取返回值 echo $? # 直接获取返回值 num=`func2` echo \"$num\" # 函数传参 funcWithParams 1 2 3 4 5 6 7 8 9 10 11 12 echo $? Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-12-19 22:42:24 "},"articles/gitbook/01_创建gitbook.html":{"url":"articles/gitbook/01_创建gitbook.html","title":"创建gitbook","keywords":"","body":"Gitbook创建 安装 $ npm install gitbook-cli -g 查看安装后的版本 # 注意大写的V $ gitbook -V # 首次会安装 $ gitbook --version CLI version: 2.3.2 Installing GitBook 3.2.3 SOLINK_MODULE(target) Release/.node CXX(target) Release/obj.target/fse/fsevents.o SOLINK_MODULE(target) Release/fse.node SOLINK_MODULE(target) Release/.node CXX(target) Release/obj.target/fse/fsevents.o SOLINK_MODULE(target) Release/fse.node /... # 安装完成 $ gitbook --version CLI version: 2.3.2 GitBook version: 3.2.3 写作 初始化 $ gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished 新建了两个文件，其中SUMMARY.md为目录 预览 i$ gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 0.5s ! Starting server ... Serving book on http://localhost:4000 配置文件 { \"title\": \"lifeasy 的文档库\", \"author\": \"Liang_QL\", \"description\": \"随便写写\", \"language\": \"zh-hans\", \"styles\": { \"website\": \"./public-repertory/css/gitbook-configure.css\" }, \"links\": { \"sidebar\": { \"我的小站\": \"https://www.liangqili.com\" } }, \"plugins\": [ \"theme-comscore\", \"prism\", \"-highlight\", \"copy-code-button\", \"search-pro\", \"-search\", \"-lunr\", \"expandable-chapters\", \"splitter\", \"-sharing\", \"github\", \"github-buttons\", \"donate\", \"tbfed-pagefooter\", \"anchor-navigation-ex\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/lifeasy\" }, \"github-buttons\": { \"buttons\": [ { \"user\": \"lifeasy\", \"repo\": \"mybook\", \"type\": \"star\", \"count\": true, \"size\": \"small\" }, { \"user\": \"lifeasy\", \"width\": \"160\", \"type\": \"follow\", \"count\": true, \"size\": \"small\" } ] }, \"donate\": { \"button\": \"打赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\", \"alipay\": \"./source/images/alipay.jpeg\", \"wechat\": \"./source/images/wxpay.jpeg\" }, \"prism\": { \"css\": [ \"prismjs/themes/prism-solarizedlight.css\" ] }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy lifeasy.top 2020\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"anchor-navigation-ex\": { \"showLevel\": false } } } 转换 安装ebook-convert 生成电子书 (epub, mobi, pdf) 时需要ebook-convert App下载地址 下载完成后可创建符号连接到一个环节变量地址中，方便命令行调用 $ sudo ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin 转pdf、epub、mobi $ gitbook epub $ gitbook pdf $ gitbook mobi 目前存在排版和乱码问题，后续解决 存在问题 TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:184:5) 和node版本有关 解决： node降级 注释/usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js62-64行 fs.stat = statFix(fs.stat) fs.fstat = statFix(fs.fstat) fs.lstat = statFix(fs.lstat) 参考文献 官方文档 GitBook - 快速打造可留言的博客 | 插件介绍详细 GitBook 使用教程 | 入门教程 安装ebook-convert Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-11-29 18:01:00 "},"articles/tool/homebrew/homebrew换源.html":{"url":"articles/tool/homebrew/homebrew换源.html","title":"homebrew换源","keywords":"","body":"homebrew 换源 使用腾讯源 测试了下，腾讯源比较快，这里使用腾讯源 替换brew.git: cd \"$(brew --repo)\" git remote set-url origin https://mirrors.cloud.tencent.com/homebrew/brew.git 替换homebrew-core.git: cd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\" git remote set-url origin https://mirrors.cloud.tencent.com/homebrew/homebrew-core.git 注意：这步未验证 cd \"$(brew --repo)/Library/Taps/homebrew/homebrew-cask\" git remote set-url origin https://mirrors.cloud.tencent.com/homebrew/homebrew-cask.git 更新 bottles源 对于bash用户： echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.cloud.tencent.com/homebrew-bottles' >> ~/.bash_profile source ~/.bash_profile 对于zsh用户: echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.cloud.tencent.com/homebrew-bottles' >> ~/.zshrc source ~/.zshrc 这里记录下，我安装到了zsh的配置文件中 更新 brew update 之前brew有问题，这里使用update-reset brew update-reset 问题解决 brew 执行出现如下问题 Traceback (most recent call last): 11: from /usr/local/Homebrew/Library/Homebrew/brew.rb:23:in `' 10: from /usr/local/Homebrew/Library/Homebrew/brew.rb:23:in `require_relative' 9: from /usr/local/Homebrew/Library/Homebrew/global.rb:37:in `' 解决步骤： 替换腾讯源 brew update-reset 参考文献 mac brew更换国内源 清华源 腾讯源 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-11-29 18:01:00 "},"articles/tool/homebrew/brew基本使用.html":{"url":"articles/tool/homebrew/brew基本使用.html","title":"brew基本使用","keywords":"","body":"brew基本使用 安装卸载 中文官网 Homebrew 的两个术语 Formulae：软件包，包括了这个软件的依赖、源码位置及编译方法等； Casks：已经编译好的应用包，如图形界面程序等。 Homebrw相关的几个文件夹用途 bin：用于存放所安装程序的启动链接（相当于快捷方式） etc：brew安装程序的配置文件默认存放路径 Library：Homebrew 系统自身文件夹 Cellar：通过brew安装的程序将以 [程序名/版本号] 存放于本目录下 常用的 brew 命令 查看brew版本：brew -v 更新brew版本：brew update 本地软件库列表：brew list 查看软件库版本：brew list --versions 查找软件包：brew search xxx （xxx为要查找软件的关键词） 安装软件包：brew install xxx （xxx为软件包名称） 卸载软件包：brew uninstall xxx 安装软件：brew cask install xxx（xxx为软件名称） 卸载软件：brew cask uninstall xxx 查找软件安装位置：which xxx （xxx为软件名称） brew install 和 brew cask install brew install brew 是下载源码解压，然后 ./configure && make install ，同时会包含相关依存库，并自动配置好各种环境变量。 brew cask install brew cask 是针对已经编译好了的应用包（.dmg/.pkg）下载解压，然后放在统一的目录中（Caskroom），省掉了自己下载、解压、安装等步骤。 简单来说 brew install 用来安装一些不带界面的命令行工具和第三方库。 brew cask install 用来安装一些带界面的应用软件。 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-09-16 10:51:21 "},"articles/tool/node/npm修改配置文件.html":{"url":"articles/tool/node/npm修改配置文件.html","title":"npm修改配置文件","keywords":"","body":"npm修改配置文件 查看npm配置 $ npm config ls ; cli configs metrics-registry = \"https://registry.npm.taobao.org/\" scope = \"\" user-agent = \"npm/6.14.9 node/v14.15.1 darwin x64\" ; userconfig /Users/360jr/.npmrc prefix = \"/usr/local\" registry = \"https://registry.npm.taobao.org/\" ; node bin location = /usr/local/bin/node ; cwd = /usr/local ; HOME = /Users/360jr ; \"npm config ls -l\" to show all defaults. 恢复默认配置 删除上述 userconfig的值 npm 换源 $ npm config set registry http://mirrors.cloud.tencent.com/npm/ 修改npm -g 默认安装位置 $ npm config set prefix '/usr/local' 默认安装位置为 /usr/local/lib/node_modules 查看默认安装位置 $ npm root -g npm取消ssl验证 $ npm config set strict-ssl false Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-06-24 14:36:22 "},"articles/tool/node/卸载node.html":{"url":"articles/tool/node/卸载node.html","title":"卸载重装node","keywords":"","body":"卸载重装node npm 出现问题，这里演示卸载，并通过brew安装 卸载 如果不是通过brew安装的 # 新建脚本并执行 #!/bin/bash lsbom -f -l -s -pf /var/db/receipts/org.nodejs.pkg.bom \\ | while read i; do sudo rm /usr/local/${i} done sudo rm -rf /usr/local/lib/node \\ /usr/local/lib/node_modules \\ /var/db/receipts/org.nodejs.* 如果是通过官方网站安装的执行下面命令 sudo rm -rf /usr/local/{bin/{node,npm},lib/node_modules/npm,lib/node,share/man/*/node.*} 安装node brew install node 安装后有可能在终端中输入node找不到该命令，执行如下命令 brew link node 得到如下结果 Linking /usr/local/Cellar/node/11.2.0... Error: Could not symlink include/node/common.gypi Target /usr/local/include/node/common.gypi already exists. You may want to remove it: rm '/usr/local/include/node/common.gypi' To force the link and overwrite all conflicting files: brew link --overwrite node To list all files that would be deleted: brew link --overwrite --dry-run node localhost:wkdir meng$ brew link --overwrite node Linking /usr/local/Cellar/node/11.2.0... Error: Could not symlink include/node/common.gypi /usr/local/include/node is not writable. 根据提示执行 brew link --overwrite --dry-run node 根据提示删除这些冲突： rm -rf /usr/local/include/node/common.gypi rm -rf /usr/local/include/node/config.gypi rm -rf /usr/local/include/node/libplatform/libplatform-export.h rm -rf /usr/local/include/node/libplatform/libplatform.h rm -rf /usr/local/include/node/libplatform/v8-tracing.h ... 删除上面的冲突的文件再运行 brew link --overwrite node 如果报错 $ brew link node Linking /usr/local/Cellar/node/15.11.0... Error: Could not symlink share/systemtap/tapset/node.stp /usr/local/share/systemtap/tapset is not writable. 解决： $ sudo chown -R 360jr:admin /usr/local/share/systemtap $ sudo rm -rf /usr/local/share/systemtap/tapset/node.stp # 再执行 $ brew link node Linking /usr/local/Cellar/node/15.11.0... 7 symlinks created. 参考文献 brew install node brew link node 遇到问题解决 Mac卸载node并使用brew重新安装 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-16 19:03:53 "},"articles/tool/git/git常用命令.html":{"url":"articles/tool/git/git常用命令.html","title":"git常用命令","keywords":"","body":"Git常用命令 git diff 看看你今天写了多少行代码 git diff --shortstat \"@{0 day ago}\" # 4 files changed, 47 insertions(+), 3 deletions(-) 增量包 git diff b1dfbcc893dbb5d232235c3c8a313f570ff590ae b7ce5b8f0144e10b4ef1c4fcc30af067810ee657 | xargs tar -czvf update.tar.gz git diff 78a12defeb251ecf218f41661b6b435 721699b0f9db5756ea84977b9de13 --name-only | xargs zip update.zip git diff e1571c141c659 d3e15e29a934d git diff e1571c141c659 d3e15e29a934d -name-only Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-17 17:23:41 "},"articles/tool/git/git常用操作.html":{"url":"articles/tool/git/git常用操作.html","title":"git常用操作","keywords":"","body":"Git常用操作 刷新.gitignore 当文件已经被git跟踪时，.gitignore不生效，需要清除缓存重新跟踪 git rm -r --cached . git add . git commit -m 'update .gitignore' 修改全局配置 git config --global user.name xxx git config --global user.email xxx oh-my-zsh git 慢/卡顿问题 oh-my-zsh slow, but only for certain Git repo $ git config --add oh-my-zsh.hide-dirty 1 $ git config --add oh-my-zsh.hide-status 1 Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-03-10 10:58:31 "},"articles/tool/reg/reg.html":{"url":"articles/tool/reg/reg.html","title":"Js中的正则表达式","keywords":"","body":"正则表达式 参考文献 learn-regex 一文掌握开发利器：正则表达式 现代JavaScript教程/正则表达式 1. 基本匹配 正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。 例如：一个正则表达式 the，它表示一个规则：由字母t开始，接着是h，再接着是e。 let string = \"i am the first\"; let regex = /the/; console.log(string.match(regex)) /** * [ 'the', index: 5, input: 'i am the first', groups: undefined ] */ 2. 元字符 元字符 描述 . 句号匹配任意单个字符除了换行符。 [ ] 字符种类。匹配方括号内的任意字符。 否定的字符种类。匹配除了方括号里的任意字符 * 匹配>=0个重复的在*号之前的字符。 + 匹配>=1个重复的+号前的字符。 ? 标记?之前的字符为可选. {n,m} 匹配num个大括号之前的字符或字符集 (n (xyz) 字符集，匹配与 xyz 完全相等的字符串. \\ 或运算符，匹配符号前或后的字符. \\ 转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \\ ` ^ 从开始行开始匹配. $ 从末端开始匹配. 2.1 点运算符 . .是元字符中最简单的例子。 .匹配任意单个字符，但不匹配换行符。 例如，表达式.ar匹配一个任意字符后面跟着是a和r的字符串。 let string = \"far a way from home\"; let regex = /.ar/; console.log(string.match(regex)) /** * [ 'far', index: 0, input: 'far a way from home', groups: undefined ] */ 2.2 字符集 [] 字符集也叫做字符类。 方括号用来指定一个字符集。 在方括号中使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。 例如，表达式[rh]om 匹配 rom 和 hom。 let string = \"far a way from home\"; let regex = /[rh]om/g; console.log(string.match(regex)) /** [ 'rom', 'hom' ] */ 方括号的句号就表示句号。 表达式 ar[.] 匹配 ar.字符串 2.2.1 否定字符集 一般来说 ^ 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 例如，表达式[^h]om 匹配一个后面跟着om的除了h的任意字符。 let string = \"far a way from home\"; let regex = /[^h]om/g; console.log(string.match(regex)) /** [ 'rom' ] */ 2.3 重复次数 后面跟着元字符 +，* or ? 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。 2.3.1 * 号 *号匹配 在*之前的字符出现大于等于0次。 例如，表达式 a* 匹配0或更多个以a开头的字符。表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串。 let string = \"ther is aaaaaabc\"; let regex = /a*bc/; console.log(string.match(regex)) /** [ 'aaaaaabc', index: 8, input: 'ther is aaaaaabc', groups: undefined ] */ *字符和.字符搭配可以匹配所有的字符.*。 *和表示匹配空格的符号\\s连起来用，如表达式\\s*cat\\s*匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。 let string = \"The fat cat sat on the concatenation.\"; let regex = /\\s*cat\\s*/g; console.log(string.match(regex)) /** [ ' cat ', 'cat' ] */ 2.3.2 + 号 +号匹配+号之前的字符出现 >=1 次。 例如表达式c.+t 匹配以首字母c开头以t结尾，中间跟着至少一个字符的字符串。 let string = \"there is a caaaat\"; let regex = /ca+t/; console.log(string.match(regex)) /** [ 'caaaat', index: 11, input: 'there is a caaaat', groups: undefined ] */ 2.3.3 ? 号 在正则表达式中元字符 ? 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 [T]?he 匹配字符串 he 和 The。 let string = \"The fat cat sat on the mat.\"; let regex = /[T]?he/g; console.log(string.match(regex)) /** [ 'The', 'he' ] */ 2.4 {} 号 在正则表达式中 {} 是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式 [0-9]{2,3} 匹配最少 2 位最多 3 位 0~9 的数字。 let string = \"The number was 9.9997 but we rounded it off to 10.0.\"; let regex = /[0-9]{2,3}/g; console.log(string.match(regex)) /** [ '999', '10' ] */ 我们可以省略第二个参数。 例如，[0-9]{2,} 匹配至少两位 0~9 的数字。 let string = \"The number was 9.9997 but we rounded it off to 10.0.\"; let regex = /[0-9]{2,}/g; console.log(string.match(regex)) /** [ '9997', '10' ] */ 如果逗号也省略掉则表示重复固定的次数。 例如，[0-9]{3} 匹配3位数字 let string = \"The number was 9.9997 but we rounded it off to 10.0.\"; let regex = /[0-9]{3}/g; console.log(string.match(regex)) /** [ '999' ] */ 2.5 (...) 特征标群 特征标群是一组写在 (...) 中的子模式。(...) 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 (ab)* 匹配连续出现 0 或更多个 ab。如果没有使用 (...) ，那么表达式 ab* 将匹配连续出现 0 或更多个 b 。再比如之前说的 {} 是用来表示前面一个字符出现指定次数。但如果在 {} 前加上特征标群 (...) 则表示整个标群内的字符重复 N 次。 我们还可以在 () 中用或字符 | 表示或。例如，(c|g|p)ar 匹配 car 或 gar 或 par. let string = \"The number was 9.9997 but we rounded it off to 10.0.\"; let regex = /n(um)?/g; console.log(string.match(regex)) /** [ 'num', 'n' ] */ let string = \"The number was 9.9997 but we rounded it off to 10.0.\"; let regex = /o(u|f)/g; console.log(string.match(regex)) /** [ 'ou', 'of' ] */ 2.6 | 或运算符 或运算符就表示或，用作判断条件。 例如 (T|t)he|car 匹配 (T|t)he 或 car。 let string = \"The car is parked in the garage.\"; let regex = /[T|t]he|car/g; console.log(string.match(regex)) /** [ 'The', 'car', 'the' ] */ 2.7 转码特殊字符 反斜线 \\ 在表达式中用于转码紧跟其后的字符。用于指定 { } [ ] / \\ + * . $ ^ | ? 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 \\。 例如 . 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 . 则要写成 \\. 以下这个例子 \\.?是选择性匹配. let string = \"The fat cat sat on the mat.\"; let regex = /(f|c|m)at\\./g; console.log(string.match(regex)) /** [ 'mat.' ] */ 2.8 锚点 在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。^ 指定开头，$ 指定结尾。 2.8.1 ^ 号 ^ 用来检查匹配的字符串是否在所匹配字符串的开头。 例如，在 abc 中使用表达式 ^a 会得到结果 a。但如果使用 ^b 将匹配不到任何结果。因为在字符串 abc 中并不是以 b 开头。 例如，^(T|t)he 匹配以 The 或 the 开头的字符串。 let string = \"The car is parked in the garage.\"; let regex = /(T|t)he/g; console.log(string.match(regex)) /** [ 'The', 'the' ] */ let string = \"The car is parked in the garage.\"; let regex = /^(T|t)he/g; console.log(string.match(regex)) /** [ 'The' ] */ 2.8.2 $ 号 同理于 ^ 号，$ 号用来匹配字符是否是最后一个。 例如，(at\\.)$ 匹配以 at. 结尾的字符串。 let string = \"The fat cat. sat. on the mat.\"; let regex = /at\\./g; console.log(string.match(regex)) /** [ 'at.', 'at.', 'at.' ] */ let string = \"The fat cat. sat. on the mat.\"; let regex = /at\\.$/g; console.log(string.match(regex)) /** [ 'at.' ] */ 3. 简写字符集 正则表达式提供一些常用的字符集简写。如下: 简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字，等同于 [a-zA-Z0-9_] \\W 匹配所有非字母数字，即符号，等同于： [^\\w] \\d 匹配数字： [0-9] \\D 匹配非数字： [^\\d] \\s 匹配所有空格字符，等同于： [\\t\\n\\f\\r\\p{Z}] \\S 匹配所有非空格字符： [^\\s] \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\p 匹配 CR/LF（等同于 \\r\\n），用来匹配 DOS 行终止符 4. 零宽度断言（前后预查） 注：在shell上测试不支持，后续看下为啥 先行断言和后发断言都属于非捕获簇（不捕获文本 ，也不针对组合计进行计数）。 先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。 例如，我们想要获得所有跟在 $ 符号后的数字，我们可以使用正后发断言 (?。 这个表达式匹配 $ 开头，之后跟着 0,1,2,3,4,5,6,7,8,9,. 这些字符可以出现大于等于 0 次。 零宽度断言如下： 符号 描述 ?= 正先行断言-存在 ?! 负先行断言-排除 ? 正后发断言-存在 ? 负后发断言-排除 4.1 ?=... 正先行断言 ?=... 正先行断言，表示第一部分表达式之后必须跟着 ?=...定义的表达式。 返回结果只包含满足匹配条件的第一部分表达式。 定义一个正先行断言要使用 ()。在括号内部使用一个问号和等号： (?=...)。 正先行断言的内容写在括号中的等号后面。 例如，表达式 (T|t)he(?=\\sfat) 匹配 The 和 the，在括号中我们又定义了正先行断言 (?=\\sfat) ，即 The 和 the 后面紧跟着 (空格)fat。 let string = \"The fat cat. sat. on the mat.\"; let regex = /[T|t]he(?=\\sfat)/g; console.log(string.match(regex)) /** [ 'The' ] */ 4.2 ?!... 负先行断言 负先行断言 ?! 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 正先行断言 定义和 负先行断言 一样，区别就是 = 替换成 ! 也就是 (?!...)。 表达式 (T|t)he(?!\\sfat) 匹配 The 和 the，且其后不跟着 (空格)fat。 let string = \"The fat cat. sat. on the mat.\"; let regex = /[T|t]he(?!\\sfat)/g; console.log(string.match(regex)) /** [ 'the' ] */ 4.3 ? 正后发断言 正后发断言 记作(? 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。 例如，表达式 (? 匹配 fat 和 mat，且其前跟着 The 或 the。 let string = \"The fat cat. sat. on the mat.\"; let regex = /(? 4.4 ? 负后发断言 负后发断言 记作 (? 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。 例如，表达式 (? 匹配 cat，且其前不跟着 The 或 the。 let string = \"The fat cat. sat. on the mat.\"; let regex = /(? 5. 标志 标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。 标志 描述 i 忽略大小写。 g 全局搜索。 m 多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。 5.1 忽略大小写 (Case Insensitive) 修饰语 i 用于忽略大小写。 例如，表达式 /The/gi 表示在全局搜索 The，在后面的 i 将其条件修改为忽略大小写，则变成搜索 the 和 The，g 表示全局搜索。 let string = \"The fat cat. sat. on the mat.\"; let regex = /The/ig; console.log(string.match(regex)) /** * [ 'The', 'the' ] */ 5.2 全局搜索 (Global search) 修饰符 g 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。 例如，表达式 /.(at)/g 表示搜索 任意字符（除了换行）+ at，并返回全部结果。 let string = \"The fat cat. sat. on the mat.\"; let regex = /The/ig; console.log(string.match(regex)) /** * [ 'The', 'the' ] */ 5.3 多行修饰符 (Multiline) 多行修饰符 m 常用于执行一个多行匹配。 像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 m。 例如，表达式 /at(.)?$/gm 表示小写字符 a 后跟小写字符 t ，末尾可选除换行符外任意字符。根据 m 修饰符，现在表达式匹配每行的结尾。 let string = \"The fat\\ncat.\\nsat.\\non the mat.\\n\"; let regex = /at[.]?$/ig; console.log(string.match(regex)) /** * null */ let string = \"The fat\\ncat.\\nsat.\\non the mat.\\n\"; let regex = /at[.]?$/igm; console.log(string.match(regex)) /** * [ 'at', 'at.', 'at.', 'at.' ] */ let string = `1st place: Winnie 2nd place: Piglet 33rd place: Eeyore`; let regex = /\\w+\\n/gim; console.log(string.match(regex)) /** * [ 'Winnie\\n', 'Piglet\\n' ] */ 6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching) 正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。 let string = \"The fat cat sat on the mat.\"; let regex = /.*at/; console.log(string.match(regex)) /** * [ 'The fat', index: 0, input: 'The fat cat sat on the mat.', groups: undefined ] */ let string = \"The fat cat sat on the mat.\"; let regex = /.*?at/; console.log(string.match(regex)) /** * [ 'The fat', index: 0, input: 'The fat cat sat on the mat.', groups: undefined ] */ 7. 捕获组 捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用。当然，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部。 捕获组有两种形式，一种是普通捕获组，另一种是命名捕获组，通常所说的捕获组指的是普通捕获组。语法如下： 普通捕获组：(Expression) 命名捕获组：(?Expression) 7.1 普通捕获组 编号规则：编号为0的捕获组，指的是正则表达式整体，其他捕获组的编号是按照“(”出现的顺序，从左到右，从1开始进行编号的。 let string = \"12345-23-23-234234234\"; let regex = /(\\d{4})-(\\d{2}-(\\d\\d))/; console.log(string.match(regex)) /* [ '2345-23-23', '2345', '23-23', '23', index: 1, input: '12345-23-23-234234234', groups: undefined ] */ let match = 'a'.match(/a(z)?(c)?/); console.log(match) /** [ 'a', undefined, undefined, index: 0, input: 'a', groups: undefined ] */ let match = 'ac'.match(/a(z)?(c)?/) console.log(match) /** [ 'ac', undefined, 'c', index: 0, input: 'ac', groups: undefined ] */ 7.2 命名捕获组 命名捕获组通过显式命名，可以通过组名方便的访问到指定的组，而不需要去一个个的数编号，同时避免了在正则表达式扩展过程中，捕获组的增加或减少对引用结果导致的不可控。 let string = \"12345-23-23-234234234\"; let regex = /(?\\d{4})-(?\\d{2}-(?\\d\\d))/; console.log(string.match(regex)) /* [ '2345-23-23', '2345', '23-23', '23', index: 1, input: '12345-23-23-234234234', groups: { year: '2345', day: '23', date: '23-23' } ] */ 7.3 捕获组的引用 对捕获组的引用一般有以下几种： 7.3.1 模式中的引用 正则表达式中，对前面捕获组捕获的内容进行引用，称为反向引用； 我们不仅可以在结果或替换字符串中使用捕获组 (...) 的内容，还可以在模式本身中使用它们。 按编号反向引用：\\N 可以使用 \\N 在模式中引用一个组，其中 N 是组号。 为了弄清那为什么有帮助，让我们考虑一项任务。 我们需要找到带引号的字符串：单引号 '...' 或双引号 \"...\"– 应匹配两种变体。 如何找到它们？ 我们可以将两种引号放在方括号中：['\"](.*?)['\"]，但它会找到带有混合引号的字符串，例如 \"...' 和 '...\"。当一种引号出现在另一种引号内，比如在字符串 \"She's the one!\" 中时，便会导致不正确的匹配： let str = `He said: \"She's the one!\".`; let regexp = /['\"](.*?)['\"]/g; // 不是我们想要的结果 alert( str.match(regexp) ); // \"She' 如我们所见，该模式找到了一个开头的引号 \"，然后文本被匹配，直到另一个引号 '，该匹配结束。 为了确保模式查找的结束引号与开始的引号完全相同，我们可以将其包装到捕获组中并对其进行反向引用：(['\"])(.*?)\\1。 这是正确的代码： let str = `He said: \"She's the one!\".`; let regexp = /(['\"])(.*?)\\1/g; alert( str.match(regexp) ); // \"She's the one!\" 现在可以了！正则表达式引擎会找到第一个引号 (['\"]) 并记住其内容。那是第一个捕获组。 \\1 在模式中进一步的含义是“查找与第一（捕获）分组相同的文本”，在我们的示例中为完全相同的引号。 与此类似，\\2 表示第二（捕获）分组的内容，\\3 – 第三分组，依此类推。 如果我们在组中使用 ?:，那么我们将无法引用它。用 (?:...) 捕获的组被排除，引擎不会存储。 不要搞混了： 在模式中用 \\1，在替换项中用：$1 在替换字符串中我们使用美元符号：$1，而在模式中 – 使用反斜杠 \\1。 按命名反向引用：\\k\\ 如果正则表达式中有很多括号对（注：捕获组），给它们起个名字方便引用。 要引用命名组，我们可以使用：\\k。 在下面的示例中引号组命名为 ?，因此反向引用为 \\k： let str = `He said: \"She's the one!\".`; let regexp = /(?['\"])(.*?)\\k/g; alert( str.match(regexp) ); // \"She's the one!\" 7.3.2 模式中的条件判断结构 正则表达式中，(?(name)yes|no)的条件判断结构； 7.3.3 程序中的引用 在程序中，对捕获组捕获内容的引用。 方法 str.replace(regexp, replacement) 用 replacement 替换 str 中匹配 regexp 的所有捕获组。这使用 $n 来完成，其中 n 是组号。 let str = \"John Bull\"; let regexp = /(\\w+) (\\w+)/; // 用$n获取捕获组的引用，然后生成字符串替换 let result = str.replace(regexp,'$2,$1') console.log(result) /** * Bull,John */ //对于命名括号，引用为 $。 //例如，让我们将日期格式从 “year-month-day” 更改为 “day.month.year”： let regexp = /(?[0-9]{4})-(?[0-9]{2})-(?[0-9]{2})/g; let str = \"2019-10-30, 2020-01-01\"; // 有数组的话，对数组中的每一项都进行替换 console.log(str.replace(regexp, '$.$.$')) /** * 30.10.2019, 01.01.2020 */ 7.4 非捕获组(?:) 不需要使用捕获功能是，尽量使用非捕获组 // 捕获组与非捕获组 () => (?:) 8. Unicode 属性（Unicode properties）\\p{…} Unicode 中的每一个字符都具有很多的属性。它们描述了一个字符属于哪个“类别”，包含了各种关于字符的信息。 例如，如果一个字符具有 Letter 属性，这意味着这个字符归属于（任意语言的）一个字母表。而 Number 属性则表示这是一个数字：也许是阿拉伯语，亦或者是中文，等等。 我们可以查找具有某种属性的字符，写作 \\p{…}。为了顺利使用 \\p{…}，一个正则表达式必须使用修饰符 u。 举个例子，\\p{Letter} 表示任何语言中的一个字母。我们也可以使用 \\p{L}，因为 L 是 Letter 的一个别名（alias）。对于每种属性而言，几乎都存在对应的缩写别名。 在下面的例子中 3 种字母将会被查找出：英语、格鲁吉亚语和韩语。 let str = \"A ბ ㄱ\"; alert( str.match(/\\p{L}/gu) ); // A,ბ,ㄱ alert( str.match(/\\p{L}/g) ); // null（没有匹配的文本，因为没有修饰符“u”） 以下是主要的字符类别和它们对应的子类别： 字母（Letter）L: 小写（lowercase） Ll 修饰（modifier） Lm, 首字母大写（titlecase） Lt, 大写（uppercase） Lu, 其它（other） Lo。 数字（Number）N: 十进制数字（decimal digit） Nd, 字母数字（letter number） Nl, 其它（other） No。 标点符号（Punctuation）P: 链接符（connector） Pc, 横杠（dash） Pd, 起始引用号（initial quote） Pi, 结束引用号（final quote） Pf, 开（open） Ps, 闭（close） Pe, 其它（other） Po。 标记（Mark）M(accents etc): 间隔合并（spacing combining） Mc, 封闭（enclosing） Me, 非间隔（non-spacing） Mn。 符号（Symbol）S: 货币（currency） Sc, 修饰（modifier） Sk, 数学（math） Sm, 其它（other） So。 分隔符（Separator）Z: 行（line） Zl, 段落（paragraph） Zp, 空格（space） Zs。 其它（Other）C: 控制符（control） Cc, 格式（format） Cf, 未分配（not assigned） Cn, 私有（private use） Co, 代理伪字符（surrogate） Cs。 因此，比如说我们需要小写的字母，就可以写成 \\p{Ll}，标点符号写作 \\p{P} 等等。 也有其它派生的类别，例如： Alphabetic (Alpha), 包含了字母 L, 加上字母数字 Nl （例如 Ⅻ – 罗马数字 12），加上一些其它符号 Other_Alphabetic (OAlpha)。 Hex_Digit 包括 16 进制数字 0-9，a-f。 …等等 Unicode 支持相当数量的属性，列出整个清单需要占用大量的空间，因此在这里列出相关的链接： 列出一个字符的所有属性 https://unicode.org/cldr/utility/character.jsp. 按照属性列出所有的字符 https://unicode.org/cldr/utility/list-unicodeset.jsp. 属性的对应缩写形式：https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt. 以文本格式整理的所有 Unicode 字符，包含了所有的属性：https://www.unicode.org/Public/UCD/latest/ucd/. 实例：16 进制数字 举个例子，让我们来查找 16 进制数字，写作 xFF 其中 F 是一个 16 进制的数字（0…1 或者 A…F）。 一个 16 进制数字可以表示为 \\p{Hex_Digit}： let string = \"there:0xAA 哈哈\"; let regex = /x\\p{Hex_Digit}\\p{Hex_Digit}/u; console.log(string.match(regex)) /** * [ 'xAA', index: 7, input: 'there:0xAA 哈哈', groups: undefined ] */ 实例：中文字符 让我们再来考虑中文字符。 有一个 unicode 属性 Script （一个书写系统），这个属性可以有一个值：Cyrillic，Greek，Arabic，Han （中文）等等，这里是一个完整的列表)。 为了实现查找一个给定的书写系统中的字符，我们需要使用 Script=，例如对于西里尔字符：\\p{sc=Cyrillic}, 中文字符：\\p{sc=Han}，等等。 let string = \"there:0xAA 哈哈\"; let regex = /\\p{sc=Han}/gu; console.log(string.match(regex)) /** * [ '哈', '哈' ] */ 9. 词边界 \\b 词边界 \\b 是一种检查，就像 ^ 和 $ 一样。 当正则表达式引擎（实现搜索正则表达式的程序模块）遇到 \\b 时，它会检查字符串中的位置是否是词边界。 有三种不同的位置可作为词边界： 在字符串开头，如果第一个字符是单词字符 \\w。 在字符串中的两个字符之间，其中一个是单词字符 \\w，另一个不是。 在字符串末尾，如果最后一个字符是单词字符 \\w。 例如，可以在 Hello, Java! 中找到匹配 \\bJava\\b 的单词，其中 Java 是一个独立的单词，而在 Hello, JavaScript! 中则不行。 let string = `Hello Java!`; let regex = /\\bJava\\b/; console.log(string.match(regex)) /** * [ 'Java', index: 6, input: 'Hello Java!', groups: undefined ] */ let string = `Hello JavaScript!`; let regex = /\\bJava\\b/; console.log(string.match(regex)) /** * null */ 在字符串 Hello, Java! 中，以下位置对应于 \\b： Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-01 10:59:54 "},"articles/tool/cocoapods/常用命令.html":{"url":"articles/tool/cocoapods/常用命令.html","title":"常用命令","keywords":"","body":"常用命令 pod # --verbose可以数据过程log # 安装 受限于 lock $ pod install # 尝试安装最新版 无视 $ pod update # 查看仓库 $ pod repo # 添加仓库 $ pod repo add ql-specs https://gitee.com/dexport/ql-specs.git # 更新仓库的spec $ pod repo update # 更新指定仓库的spec $$ pod repo update ql-specs # 删除仓库 $ pod repo remove ql-specs # 同步podspec文件到specs仓库 $ pod repo push ql-specs QLSum.podspec # 创建lib公测 $ pod lib create QLSum # 测试lib $ pod lib lint Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-29 22:12:53 "},"articles/tool/cocoapods/简单原理.html":{"url":"articles/tool/cocoapods/简单原理.html","title":"Cocoapods简单原理","keywords":"","body":"Cocoapods简单操作 Cocoapods的简单描述 Podfile解析 一切皆对象 Podfile解析，就是执行类似的定义好的方法 # eval_pod.rb $hash_value = {} def source(url) end def target(target) end def platform(platform, version) end def pod(pod) end CocoaPods 对 Podfile 的解析类似上面的代码，构建一个包含一些方法的上下文，然后直接执行 eval 方法将文件的内容当做代码来执行，这样只要 Podfile 中的数据是符合规范的，那么解析 Podfile 就是非常简单容易的。 安装依赖的过程 Podfile 被解析后的内容会被转化成一个 Podfile 类的实例，而 Installer 的实例方法 install! 就会使用这些信息安装当前工程的依赖，而整个安装依赖的过程大约有四个部分： 解析 Podfile 中的依赖 下载依赖 创建 Pods.xcodeproj 工程 生成 Pods.xcodeproj 工程 将依赖中的文件加入工程 将依赖中的 Library 加入工程 设置目标依赖（Target Dependencies） 集成 workspace # install流程 def install! resolve_dependencies download_dependencies generate_pods_project integrate_user_project end # 生成 Pods.xcodeproj def generate! prepare install_file_references install_libraries set_target_dependencies end 参考资料 CocoaPods 都做了什么？ Podfile Syntax Reference Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-29 21:49:25 "},"articles/tool/cocoapods/搭建私有库.html":{"url":"articles/tool/cocoapods/搭建私有库.html","title":"Cocoapods搭建私有仓库","keywords":"","body":"搭建私有库 创建specs仓库和代码仓库 这里使用gitee仓库 specs仓库可以私有 本地添加specs仓库 $ pod repo add ql-specs https://gitee.com/dexport/ql-specs.git 本地新建代码仓库 $ pod lib create QLSum Cloning `https://github.com/CocoaPods/pod-template.git` into `test`. Configuring test template. ------------------------------ To get you started we need to ask a few questions, this should only take a minute. If this is your first time we recommend running through with the guide: - https://guides.cocoapods.org/making/using-pod-lib-create.html ( hold cmd and click links to open in a browser. ) What platform do you want to use?? [ iOS / macOS ] > ios What language do you want to use?? [ Swift / ObjC ] > objc Would you like to include a demo application with your library? [ Yes / No ] > yes Which testing frameworks will you use? [ Specta / Kiwi / None ] > none Would you like to do view based testing? [ Yes / No ] > no What is your class prefix? > QL ... 修改QLSum.specs文件 # # Be sure to run `pod lib lint QLSum.podspec' to ensure this is a # valid spec before submitting. # # Any lines starting with a # are optional, but their use is encouraged # To learn more about a Podspec see https://guides.cocoapods.org/syntax/podspec.html # Pod::Spec.new do |s| s.name = 'QLSum' s.version = '0.1.0' s.summary = 'a lib for sum' # This description is used to generate tags and improve search results. # * Think: What does it do? Why did you write it? What is the focus? # * Try to keep it short, snappy and to the point. # * Write the description between the DESC delimiters below. # * Finally, don't worry about the indent, CocoaPods strips it! s.description = 'MIT', :file => 'LICENSE' } s.author = { 'lifeasy' => 'lvyaner@126.com' } s.source = { :git => 'https://gitee.com/dexport/qlsum.git', :tag => s.version.to_s } # s.social_media_url = 'https://twitter.com/' s.ios.deployment_target = '9.0' # 库文件位于代码仓库中的位置 s.source_files = 'QLSum/Classes/**/*.{h,m}' # 资源文件的位置 # s.resource_bundles = { # 'QLSum' => ['QLSum/Assets/*.png'] # } # s.public_header_files = 'Pod/Classes/**/*.h' # s.frameworks = 'UIKit', 'MapKit' # s.dependency 'AFNetworking', '~> 2.3' end 上传代码仓库 在Example工程中找到ReplaceMe.m文件，此文件位于libname/libname/classes/下，Move to Trash此文件，然后在相同位置编写库文件，编写好之后同步整个lib工程到代码仓库 $ git add . $ git commit -am 'first' $ git remote add origin https://gitee.com/dexport/qlsum.git $ git push origin master # 打tag，对应specs中的版本 $ git tag '0.1.0' $ git push --tags 同步specs文件到specs仓库 $ pod repo push ql-specs QLSum.podspec 代码库升级 修改源代码 修改specs文件，抓要是版本号，比如从0.1.0->0.2.0 上述步骤上传代码，并打tag 0.2.0 同步specs文件 更新对应的本地specs仓库 一些常用的命令 $ git add . $ git commit -am 'first' $ git remote add origin https://gitee.com/dexport/qlsum.git $ git push origin master $ git tag '0.1.0' $ git push --tags $ pod lib create QLSum $ pod repo add ql-specs https://gitee.com/dexport/ql-specs.git $ pod lib lint $ pod repo push ql-specs QLSum.podspec $ pod repo remove ql-specs $ pod repo ql-specs update $ pod repo update ql-specs Copyright © lifeasy.top 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-07-29 22:09:30 "}}