# 汇编

## 总线

* 地址总线
* 控制总线
* 数据总线

## 寄存器

对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。

* 对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制
* 不同的CPU，寄存器的个数、结构是不相同的

### 浮点和向量寄存器

因为浮点数的存储以及其运算的特殊性,CPU中专门提供浮点数寄存器来处理浮点数

* 浮点寄存器 64位: D0 - D31  32位: S0 - S31

现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.

* 向量寄存器 128位:V0-V31

### 通用寄存器

* 通用寄存器也称**数据地址寄存器**通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。
* ARM64拥有有32个64位的通用寄存器 x0 到 x30，以及XZR(零寄存器),这些通用寄存器有时也有特定用途。
  * 那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位.
  * 比如 w0 就是 x0的低32位!

###pc寄存器(program counter)

* 为指令指针寄存器，它指示了CPU当前要读取指令的地址
* 在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息
* CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义
  * 比如 1110 0000 0000 0011 0000 1000 1010 1010 
  * 可以当做数据   0xE003008AA 
  * 也可以当做指令  mov    x0, x8
* CPU根据什么将内存中的信息看做指令？
  * CPU将pc指向的内存单元的内容看做指令
  * 如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过

###SP(x31)和FP(x29)寄存器

* sp寄存器在任意时刻会保存我们栈顶的地址.
* fp寄存器也称为x29寄存器属于通用寄存器,但是在某些时刻我们利用它保存栈底的地址!

 > 注意:ARM64开始,取消32位的 LDM,STM,PUSH,POP指令! 取而代之的是ldr\ldp  str\stp
 > ARM64里面 对栈的操作是16字节对齐的!!

### 修改寄存器的值

```shell
register read pc
register write pc 0x879899
```

### 高速缓存

* CPU先在高速缓存中找指令或者数据
* 高度缓存到内存有映射，类似虚拟内存

## 指令

* 占用四个字节

## 编写汇编代码

```assembly
.text
.global _A, _B
_A:
    mov x0,#0xa0
    mov x1,#0xb0
    add x1,x0,#0x0a
    mov x1,x0
    bl _B
    mov x0,#0x00
    ret

_B:
    add x0,x1,#0x10
    ret
```

## 函数调用栈

常见的函数调用开辟和恢复的栈空间

```objc
sub    sp, sp, #0x40             ; 拉伸0x40（64字节）空间
stp    x29, x30, [sp, #0x30]  ;x29\x30 寄存器入栈保护
add    x29, sp, #0x30            ; x29指向栈帧的底部
... 
ldp    x29, x30, [sp, #0x30]  ;恢复x29/x30 寄存器的值
add    sp, sp, #0x40             ; 栈平衡
ret
```

## 关于内存读写指令

>注意:读/写 数据是都是往高地址读/写
>
>栈空间往低开辟，往高读写

**str(store register)指令**

将数据从寄存器中读出来,存到内存中.

**ldr(load register)指令**

将数据从内存中读出来,存到寄存器中

此ldr 和 str 的变种ldp 和 stp 还可以操作2个寄存器.


###堆栈操作练习

使用32个字节空间作为这段程序的栈空间,然后利用栈将x0和x1的值进行交换.

```
sub    sp, sp, #0x20 ;拉伸栈空间32个字节
stp    x0, x1, [sp, #0x10] ;sp往上加16个字节,存放x0 和 x1
ldp    x1, x0, [sp, #0x10] ;将sp偏移16个字节的值取出来,放入x1 和 x0
```

## bl和ret指令

### bl指令

* CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令
* ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如
  * mov x0,#10、mov x1,#20
* 但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能
* ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令

####bl标号

* 将下一条指令的地址放入lr(x30)寄存器
* 转到标号处执行指令

####ret

* 默认使用lr(x30)寄存器的值,通过底层指令提示CPU此处作为下条指令地址!

>ARM64平台的特色指令,它面向硬件做了优化处理的

####x30寄存器

x30寄存器存放的是函数的返回地址.当ret指令执行时刻,会寻找x30寄存器保存的地址值!

>注意:在函数嵌套调用的时候.需要讲x30入栈!


##函数的参数和返回值

ARM64下,**函数的参数**是存放在X0到X7(W0到W7)这8个寄存器里面的.如果超过8个参数,就会入栈.
**函数的返回值**是放在X0 寄存器里面的.


##函数的局部变量

函数的局部变量放在栈里面!